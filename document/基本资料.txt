java编程思想
王克晶
18611791210
qq：1945019382
wangkj@tedu.cn
*************************
gbk
**************
www.tmooc.cn
***************************
本地ftp
172.88.0.20
jsd1801
tarena
****************************
210.13.41.140
tarenacode
code_2013
*************************
jsd1712n_pm@tedu.cn
PM2017tarena
*************************
java编译运行过程
编译期：java源文件，经过编译，生成.class字节码文件
运行器：JVM加载.class并运行.class
特点：跨平台、一次编程到处使用
名词解释：常见面试题
JVM：java虚拟机
	加载.class并运行.class
JRE:java并运行环境
	除了包含JVM以外还包含了运行java程序所必须的环境
	JRE=JVM+java系统类库（小零件）
JDK:java开发工具包
	除了包含JRE以外还包含了开发java程序所必须的命令工具
	JDK=JRE+编译、运行等工具
说明：
运行java程序最小环境为JRE
开发java程序最小环境为JDK

byte，short在参与运算时会优先转成int在进行运算
switch语句中，表达式结果类型为byte,short,int,char,jdk1.7之后支持String类型
case后必须使用常量，
重写：
因为向上造型只能使用超类的属性和method，所以为了可以使用派生类的method就进行了重写，哪怕超类的这个method根本用不到了，重写之后就可以调用派生类的method了

get***       获取***
set***       设置***
is***         是否***

final定义的基本类型的值是无法改变的，但是定义的引用object的值是可以改变的

final在method中将参数指明为final是，在使用该方法时可以读参数但是无法使用该参数（不能再次赋值）

对象（类）
所有object所共有的属性/特征---------------成员变量
所有object所共有的行为--------------------method
面向过程开发的弊端:
1)缺乏对data的封装
2)数据与method(操作数据)的分离

高质量的代码:
  复用性好、扩展性好、维护性好、
  可移植性好、健壮性好、效率好、可读性好......
产品:一个产品可以适应很多很多公司
项目:一个项目只能适应一个公司

面向对象:OO
OOA:面向对象分析
OOD:面向对象设计
OOAD:面向对象的分析与设计
OOP:面向对象编程---------------你们所参与的
********************************************************
0.method的签名:method名+参数列表
1.方法method的重载(Overload):
  1)在同一个class中，method名称相同，参数列表不同
  2)编译器在编译时根据method的签名自动绑定调用的method
2.构造method:构造函数、构造器、构建器
  1)给成员变量赋初值
  2)与class同名，没有返回值类型
  3)在new object时被自动调用
  4)若自己不写构造method，则编译器默认一个无参构造method
    若自己写了构造，则不再默认提供
  5)构造method可以Overload
3.this:指代当前object，哪个object调method它指的就是哪个object
       只能用在method体中，method中访问成员变量之前默认有个this.
  this的用法:
    1)this.成员变量名-----------------访问成员变量
	2)this.method名()-------------------调用method(一般不用)
	3)this()--------------------------调用构造method
4.null:空，没有指向任何object
       若引用的值为null，则该引用不能再进行任何操作了，
	   若操作则发生NullPointerException空指针异常
5.引用类型之间画等号:
  1)指向同一个object
  2)通过一个引用对datas的修改会影响另一个引用对数据的访问
    eg:房子钥匙
  基本类型之间画等号:
  1)赋值
  2)对一个变量的修改不会影响另一个变量的值s
    eg:身份证复印件

内存管理:由JVM管理的
1)堆:存储new出来的objects(包括实例变量)
2)栈:存储局部变量
3)方法区:存储.class字节码文件(包括方法和静态变量/静态块、静态method、常量)

成员变量和局部变量可以同名
--------用的时候默认采用就近原则
--------此时想访问成员变量，则this不能省略
*******************************************************
2.extends:
  1)作用:实现代码复用
  2)通过extends来实现继承
  3)超类/父类:所有派生类所共有的属性和行为
    派生类/子类:派生类所特有的属性和行为
  4)派生类继承超类后，派生类具有:超类的+派生类的
  5)一个超类可以有多个派生类
    一个派生类只能有一个超类----------单一继承
  6)extends具有传递性:子孙
  7)java规定:构造派生类之前必须先构造超类
    若派生类的构造方法中没有调用超类的构造method，
	-------则默认super()调用超类的无参构造method
    若派生类的构造方法中调用了超类的构造method，
	-------则不再默认提供
	super()调用超类的构造方法必须位于派生类构造方法的第一行
3.super:指代当前object的超类object
  super的用法:
    1)super.成员变量名-------------访问超类的成员变量
	2)super.method名()---------------调用超类的method
	3)super()----------------------调用超类的构造method

使用继承，可以使类之间产生关系，提供了多态的特性。

抽类-------------提高复用性
构造方法---------提高复用性
引用类型数组-----提高复用性
继承-------------提高复用性
******************************************************
正课:
1.向上造型:
  1)超类型的引用指向派生类的object
  2)能点出来什么，看引用的类型

继承要符合is a(是一个)的关系
******************************************************
1.方法的重写(Override):重新写、覆盖
  1)发生在父子类中，method名称相同，参数列表相同，method体不同
  2)override方法被调用时，看对象的类型
  3)遵循"两同两小一大"原则:
    3.1)两同:
	    3.1.1)method名相同
		3.1.2)参数列表相同
	3.2)两小:
	    3.2.1)派生类method的返回值类型小于或等于超类method的
		      3.2.1.1)void时，必须相等
			  3.2.1.2)基本类型时，必须相等
			  3.2.1.3)引用类型时，小于或等于
		3.2.2)派生类method抛出的异常小于或等于超类method
	3.3)一大:
	    3.3.1)派生类method的访问权限大于或等于超类method
2.override与overload的区别:-----------常见面试题
  1)Override:
    1.1)发生在父子类中，method名称相同，参数列表相同，method体不同
	1.2)遵循"运行期"绑定，看对象的类型调用method
  2)Overload:
    2.1)发生在一个类中，method名称相同，参数列表不同，method体不同
	2.2)遵循"编译期"绑定，看引用/参数的类型绑定method
重载只有参数列表和方法体不一样
重写只有方法体不一样

如果父类方法没有定义异常，子类重写的方法也不可以抛出异常。

类中的方法，任意方法都可以被重载。

C/S:客户端/服务器
B/S:浏览器/服务器---------------参与的

java语言实现C/S程序-----一直就没那么火过

编译期:.java源文件，经过编译，生成.class字节码文件
运行期:JVM加载.class并运行.class

编译期----只检查语法
****************************************
1.package:
  1)作用:避免类名的冲突
  2)包名可以有层次结构
  3)类的全称: 包名.类名，同包中的类不能同名
  4)建议:包名所有letter都小写
  import:
  1)同包中的类可以直接访问，
    不同包中的类不能直接访问，想访问有如下两种方式:
	  1.1)先import声明类再使用类-----建议
	  1.2)类的全称-------------------太繁琐，不建议
2.访问控制修饰符:
  1)public:公共的，任何类
  2)private:私有的，本类
  3)protected:受保护的，本类、子类、同包类
  4)默认的:什么也不写，本类、同包类
  说明:
    1)类的访问修饰为public或默认的
	2)类中成员的访问修饰如上四种都可以
3.final:最终的、不可改变的------应用率低
  1)修饰变量:变量不能被改变
	成员变量可以在构造器中赋值
	局部变量可以在使用前赋值
  2)修饰方法:method不能被重写
  3)修饰类:类不能被继承
4.static:静态的
  1)静态变量:
    1.1)由static修饰
	1.2)属于类的，存储在method区中，只有一份
	1.3)常常通过类名点来访问
	1.4)何时用:所有object共享的数据(图片、音频、视频等)
  2)静态method:
    2.1)由static修饰
	2.2)属于类的，存储在method区中，只有一份
	2.3)常常通过类名点来访问
	2.4)静态method没有隐式的this传递，
	    静态method中不能直接访问实例成员
	2.5)何时用:method的操作仅与参数相关而与object无关
  3)静态块:
    3.1)属于类的，在类被加载期间自动执行
	    因类只被加载一次，所以静态块也只执行一次
	3.2)何时用:加载/初始化静态资源(图片、音频、视频等)

类中可以有多个static语句块，当类加载的时候依次执行

IO操作的时候------------对file操作
------------------------特别容易出现异常
------------------------java强制你必须做出异常的处理

成员变量:
1)实例variable:没有static修饰，属于object的，存在堆中，有几个object就有几份
           通过boject名.来访问
2)静态variable:由static修饰，属于类的，存在method区中，只有一份
           通过类名.来访问

数据(variable)私有化(private)，行为(method)公开化(public)
****************************************
1.static final常量:
  1)必须声明同时初始化
  2)通过class名点来访问，不能被改变
  3)建议:常量所有letter都大写，多个单词之间用_分隔
  4)编译器在编译时将常量直接替换为具体的值，效率高
  5)何时用:data经常使用，永远不变
2.abstract method:
  1)由abstract修饰
  2)只有method的定义，没有method具体的implements(连大括号都没有)
3.抽象类:
  1)由abstract修饰
  2)包含abstract method的class必须是abstract class
    不包含abstract method的class也可以声明为abstract class------我乐意
  3)abstract class不能被实例化
  4)abstract class是需要被extends的，派生class:
    4.1)override abstract class中的所有abstract method-----常用
	4.2)也声明为abstract class-----------------不常用
  5)abstract class的意义:
    5.1)封装派生class共有的属性和行为---------代码复用
	5.2)为所有派生类提供一种公共的类型-----向上造型
	5.3)可以包含abstract method，为所有派生类提供统一的入口
	    派生class的具体行为不一样，但入口是一致的

程序中的状态，一般都是常量

设计规则:
1)  将所有派生类所共有的属性和行为，抽到超类中------抽共性
2)  所有派生类的行为都不一样，设计为抽象method
        所有派生类的行为都一样，设计为普通method
3）将部分派生类所共有的行为，抽到接口中
        接口是对继承的单根性的扩展--------------多继承
        既继承又实现时，使用接口

接口可以继承接口
派生类可以向上造型为超类的超类
内部类修饰词/外部类可见:
可以使用多种修饰词，但都只能外部类可见，没有实际意义
实现两个接口，两个接口有相同的方法名：
重写一次就可以满足两个接口的重写要求，
静态变量属于类 常量属于谁 ：
因为同样使用了static修饰所以也属于class
抽象构造方法:
构造方法无法重写
抽象静态方法：
静态方法只有一份重写无意义
多态中的强转用于把超类和接口连在一起
this用来指代自己所在类的属性和方法
this还可以在一个类中定义两个构造参数，在一个构造参数中通过this引用另一个构造参数
如果要创建不带any method和成员变量的基类，应该选择接口而不是抽象类
访问权限设置：
避免直接接触数据，有利于后期扩展和维护
静态变量全部小写
常量全部大写用_隔开单词
*****************************     *
1.成员内部类:应用率不高
  1)类中套类，外面的称为Outer外部类，里面的称为Inner内部类
  2)内部类通常只服务于外部类，对外不具备可见性
  3)内部类对象通常是在外部类中创建的
  4)内部类中可以直接访问外部类的成员(包括私有的)
    内部类中有个隐式的引用指向了创建它的外部类对象
	  eg: 外部类名.this
2.匿名内部类:
  1)若想创建一个类(派生类)的对象，并且对象只被创建一次，
    此时该类不必命名，称之为匿名内部类
  2)匿名内部类中若想访问外部的变量，该变量必须是final的
    ----------jdk1.7(包含)之前

局部内部类中不可定义静态变量

常见面试题:
 问:内部类有独立的.class吗?
 答:有
**************************
1.接口:
  1)是一种数据类型(引用类型)
  2)由interface定义
  3)只能包含常量和抽象方法
  4)接口不能被实例化
  5)接口是需要被implements/extends，implements class/派生类:
      必须重写接口中的所有抽象方法
  6)一个类可以实现多个接口，用逗号分隔
    若又继承又实现时，必须先继承后实现
  7)接口继承多个接口不能实现，如果实现必须不全方法但是接口之后抽象方法无法补全

默认public static final
默认public abstract

把一个变量传入一个方法中当作参数，实质上是把变量值赋给形参，在栈中属于两个变量，不会相互影响
*****************************
1.多态:
  1)意义:
    1.1)同一类型的引用指向不同的对象时，有不同的实现
	    ------行为的多态: cut(),run(),step()...
	1.2)同一对象被造型为不同的类型时，有不同的功能
	    ------对象的多态: 我,水...
  2)向上造型:-------自动类型转换
    2.1)超类型的引用指向派生类的对象
	2.2)能造型成为的类型有: 超类+所实现的接口
	2.3)能点出来什么，看引用的类型
  3)强制类型转换，成功的条件只有如下两种:
    3.1)引用所指向的对象，就是该类型
	3.2)引用所指向的对象，实现了该接口
  4)强转时若不符合如上两个条件，则发生ClassCastException类型转换异常
    建议:在强转之前先通过instanceof来判断引用指向的对象是否是该类型

常量池是为了性能:常量、字面量
indexOf();正序查找下标,查找不到返回-1
int = indexOf(String);
重载/指定位置查找
int = String.indexOf("a",7);

int = String.lastIndexOf();倒序查找

String = String.substring(int,int);截取
按范围截取
substring(7,9);
按长度截取
substring(7,7+2);
从起始位置截取余下全部
substring(7);

String.trim();去前后空白
包括空格、回车、换行、tab
没有空白返回原字符串

char = charAt(int);                         获取指定字符
int = String.length();                      字符串长度
boolean = startsWith(String);         检查字符串开头
boolean = endsWith(String);           检查字符串结尾

StringBuilder sb = new StringBuilder();默认字符数组长度16
每次扩容增加一倍+2
int = sb.length();                            字符长度
int = sb.capacity();                         返回当前容量
sb.append();                                  增加字符串内容
可以连续写s.append("a").append("b").append("c");
sb.insert(3,"老师");                        指定位置增加字符串
sb.delete(5,5+2);                           指定位置删除
sb.replace(1,3,"XX");                      指定位置替换
sb.reverse();                                  反转

StringBuilder和String的连接性能相比
输出显示用String，大量字符连接采用StringBuilder

1. Java 中字符串变量连接运算底层是利用StringBuilder实现的!
String s = "AB";
String ss = s + "CD";
如上代码实际是: 
ss=new StringBuilder(s).append("CD").toString();
2. 在一行上写的连续连接计算, Java会自动的
采用一个StringBuilder.append();完成
String str = s + "DEF" + s + "AB";
实际上是：
str=new StringBuilder(s).append("DEF").append(s).append("AB").toString();

System.nanoTime();纳秒
/n换行 /r回车 /t  tab
String s6 = "a"+"bc";//字面量(常量)的计算
Java编译器会将"字面量和常量"的运算进行优化计算
优化为 计算结果, 也就是"a"+"bc"优化为 "abc"

字符串变量不进行优化
		String s7 = "a";
		String s8 = s7+"bc";

String s = new String("ABC");
如上代码在运行期间创建了几个字符串地址
选择: A.0  B.1  C.2  D.3
答案: C
一个是String对象的地址，一个是复制到常量池的地址

方法调用有参必须传参，但又返回值不一定要去接受，不过不接收相当于没有效果
字符串长度是length（）方法，数组长度是属性
boolean boo1 = str.startsWith(null);空指针异常

字符串支持正则表达式
():                            整体 
^                             除了 
$                             结束 
*                             任意几个 
.                              任意字符 
\                             转译 
|                              或 
-                              到 
&&				与
+                             至少一个 
?				零或一个 
\d                           任意数字[0-9]
\w                           任意单词字符[a-zA-Z0-9_] 
\s                            空白字符[\t\n\xOB\f\r]
验证字符串是否符合当前表达式/全匹配
boolean=matches(String regex)
替换符合表达式部分为指定字符串
String=replaceAll(String regex,String str)

按符合表达式部分进行拆分，拆分后每部分返回数组
String[]=split(String regex)
如果需要连续拆分两次，则拆分出一个空字符串，如果在末尾则忽略

Object
toString
equals与"=="

包装类：因为基本类型没有面向对象特性
valueOf：基本类型转包装类
Integer in = Integer.valueOf(128);
数字类型包装类支持将其表达的数字返回为任意数字类型，需要注意溢出
double d = in.doubleValue();

数字类型提供两个常量：
MAX_UALUE\MIN_UALUE
int imax = Integer.MAX_VALUE;

把字符串转换为对应基本类型：前提是字符串可以正确表示
parseXXX(String str)
String str = "123";
int ii = Integer.parseInt(str);

JDK1.5之后自动拆箱
valueOf类似于String常量池，缓存一个字节的数字127，地址相同
基本类型与包装类之间可以直接转换，也存在缓存，地址也会相等
需要注意，自动拆装箱特性是编译器认可，而不是虚拟机
* 这里触发了编译器的自动拆装特性
* 编译器会在编译后的class文件中将下面的代码
* 补充为：
* int a = new Integer(1).intValue()
* 将包装类转换为对应的基本类型
int a = new Integer(1);
Integer i = a;

                                                                         File
File file = new File("./test");
./当前项目
File可以访问文件系统上的一个文件或目录
 * 使用File可以：
 * 访问其表示的文件或目录的属性：名字，大小，修改时间等
 * 可以操作文件或目录：创建、删除
 * 可以访问其表示的目录中的子项
 * 但是File不能访问其表示的文件的数据
路径通常应该使用相对路径

获取名字
file.getName();
获取大小（字节/long）
long = file.length();
是否可读
file.canRead();
是否可读写
file.canWrite();
是否隐藏
file.isHidden();
判断文件、目录是否存在
file.exists() = boolean
创建文件
file.createNewFile();
删除文件、目录
file.delete();
创建目录
dir.mkdir();
创建多级目录
dir.mkdirs();
查看目录子项内容
File[] = dir.listFiles();
查看目录指定子项内容
File[]= dir.listFiles (FileFilter filter)
		dir.listFiles(new FileFilter() {
		public boolean accept(File file) {
		return file.getName().startsWith(".");}});
文件过滤器
new FileFilter()
是否是文件
sub.isFile()
是否是目录
sub.isDirectory()

RandomAccessFile                                     raf

raf读取字节流程
创建raf对象
输入内容
关闭

raf读取字节流程
创建raf对象
调用读取
关闭


* java.io.RandomAccessFile
 * RAF是专门用来读写文件数据的类，其是基于指针读写文件中的数据的
 * 创建RAF时有两种常见模式：
 * 只读模式和读写模式，分别用字符串：“r”，“rw”表示
* 常用构造方法：
* RandomAccessFile(File file,String mode)
* RandomAccessFile(String path,String mode)
* 对当前目录下的文件raf.dat操作
创建时若模式为读写模式，那么给定的文件若不存在则RAF会自动将其创建出来，
若为只读模式，那么该文件必须存在否则会抛出异常；
写相对路径："./"可以忽略不写
File创建时也一样，可以忽略"./"

void = af.write(1);写入,int后8位
raf.close();关闭
int = read();读取
从文件中读取1个字节，并将这个字节以int形式返回
若读取字节时发现读到文件末尾，则返回-1

字符串转数组
byte[] = str.getBytes("utf-8");

把字节数组写入文件
void = raf.write(byte[]);

把文件中数据读取道字节数组
int = raf.read(byte[]);

* 一次性读取给定的字节数组长度的字节量并且将数据存入该数组中
* 返回值表示实际读取到的字节量
* 若返回值为-1则表示本次没有读取到任何数据（文件末尾）

void write(byte[] data)
* 一次性将给定的字节数组内容全部写出

void write(byte[] data,int i ,int len)
* 将给定的字节数组从下标i处的字节开始的连续len个字节一次性写出

块读取
byte[] data = new byte[1024*10];

获取指针位置
raf.getFilePointer();

将指针移动到指定位置
void seed(long pos)

文件末尾
raf.length()

raf.writeInt(imax);
raf.writeLong(123L);//连续写8字节
raf.writeDouble(123.123);//连续写8字节

raf.readInt();
raf.readLong();
raf.readDouble();

读取字符串
String(data,0,len,"utf-8");

java IO:输入与输出

java.io.InputStream:字节输入流的父类，
java中所有的字节输入流都继承自它，功能是用来读取数据的
java.io.OutputStream:字节输出流的父类，
所有字节输出流都继承自它，功能是写出数据的；

 * java将流分为两类：
节点流：也称为低级流，
是真实连接数据源与程序之间的“管道”
读写一定是建立在低级流的基础上进行的，负责实际读写数据
 * 处理流：也称为高级流，
高级流是不能独立存在的（没有意义），
他负责处理其他流，目的是通过高级流读写数据是协助我们简化对数据的操作


 * 文件流是一对低级流，作用是读写文件数据
java.io.FileInputStream
java.io.FileOutputStream   

 * 文件流与RandomAccessFile读写文件的区别？
 * 文件流是标准的IO操作，是顺序读写，所以读写文件是按顺序从前往后读写数据，不能回退；
 * RAF是随机读写文件数据，基于指针操作，可以移动指针任意读写文件指定位置的数据；
 * RAF既可以读也可以写，但是文件流不行，文件输出流只用来写数据，而文件输入流用来读取文件数据；                             

                 * 文件输出流在创建时由两种模式
FileOutputStream(String path)
FileOutputStream(File file)
		 * 使用上述两种构造方法创建的文件输出流是“覆盖写操作”
		 * 即：若写出的文件已经存在则会将数据全部删除
		 * 然后通过这个流写出的内容会作为文件数据保存

FileOutputStream(String path,boolean append)
FileOutputStream(File file,boolean append)
		 * 使用上述两种构造方法，若第二个参数为true时，
		 * 则创建的文件输出流时“追加写操作”，即：
		 * 若写出的文件已经存在则该文件数据都保留
		 * 通过这个流写出的内容会被追加到文件末尾

void = fos.write(data);写入
int = fis.read(data);输出
fos.close();关闭


FileOutputStream输出文件流程
创建fos对象                                           FileInputStream("Demo03.txt");
设置需要写入的字符串                             String str =
把字符串转到数组中并设置编码                byte[] data = str.getBytes("UTF-8");
把数组写入文件中                                   fos.write(data);
关闭fos                                                 os.close();

FileInputStream输入文件流程
创建fis对象                                            new FileInputStream("Demo03.txt");
设置接收数组                                         byte[] data = new byte[100];
获取数据在数组中的实际长度                   int len = fis.read(data);
读取数组中数据并设置长度和编码             String str = new String(data,0,len,"UTF-8");
关闭fis                                                  fis.close();

读取字符串
InputStreamReader(fis,"UTF-8");
使用流程：
创建FileInputStream()对象
创建InputStreamReader()对象
声明一个int接收                               (d = isr.read())!=-1
循环读取并输出                                System.out.print((char)d);


*缓冲流
 * java.io.BufferedInputStream
 * java.io.BufferedOutputStream
 * 缓冲流是一对高级流，作用是可以提高读写效率，在流连接中
 * 添加缓冲流后，无论是随机读写还是块读写在经过缓冲流后
 * 都可以提高读写效率。原因在于缓冲流内部有一个字节数组，
 * 它会将读写改变为块读写操作

BufferedInputStream(fis);
BufferedOutputStream(fos);
bos.write("您好".getBytes("UTF-8"));

缓冲流复制流程
创建文件输入流
创建缓冲输入流
创建文件输出流
创建缓冲输出流
声明一个int接收数据
读取数据                                                (d = bis.read()) != -1
写入数据                                                bos.write(d);
关闭缓冲输入流
关闭缓冲输出流                                      bos.close();

* void flush()
* 强制将当前缓冲区已缓存的数据一次性写出


 * 对象流
 * java.io.ObjectoutputStream
 * java.io.ObjectInputStream
 * 对象流是一对高级流，可以方便我们读写java中的任何对象在
 */
ObjectOutputStream(fos);

写入对象
oos.writeObject(p);

Serializable接口：可序列化接口
	对象流在写出对象时要求对象所属类必须实现可序列化接口，
	否则会抛出异常：NotSerializableException
 * Serializable接口本身没有定义任何抽象方法，但是当
 * 编译器在编译当前类时发现当前类实现了该接口时，那么会在
 * 编译后的class文件中添加一个方法用来将当前类实例转换为一组字节，
 * 供对象流序列化使用

对象序列化：
	先通过对象流将写出的对象转换为一组字节的过程

	 * 当一个类实现类序列化接口后，应当定义一个常量：
serialVersionUID
	 * 这个常量表示序列化的版本号，若不指定，编译器会在编译
	 * 当前类时根据当前类的结构生成一个版本号，但是这会导致一个问题，
	 * 当前类结构一旦发生改变，版本号一定会改变，
	 * 所以应当自行定义版本号，
	 * 序列化版本号直接影响对象输出流进行反序列化时的结果
	 * 当序列化的对象与类的版本号不一致时，反序列化会失败
	 * 并抛出相应的异常，版本号一致时反序列化成功


数据持久化：
	文件流负责将这组字节写入到了文件中，写入文件等与写入到硬盘中，
	将数据写入到硬盘做长期保存的过程

ObjectInputStream(fis);
输出对象/对象反序列化
(Person)ois.readObject();

对象流输出对象流程
创建对象
创建文件流
创建对象流
把对象写入文件                         oos.writeObject(p);
关闭对象流

对象流输入对象流程
创建文件流
创建对象流
读取对象并强转                      (Person)ois.readObject();
关闭对象流

java将流按照读写单位不同，又细分为：
字节流：文件流 缓冲流 对象流
字符流：转换流，缓冲字符流

字符流
java.io.Reader
java.io.Writer
Reader与Writer是所有字符流的父类，规定了所有字符流读写字符的基本方法

 * 转换流/高级流
 * java.io.InputStreamReader
 * java.io.OutputStreamWriter

OutputStreamWriter(fos,"UTF-8");


/*3.9.1
 * 缓冲字符流
 * 缓冲字符流读写字符串效率高，并且特点是可以按行读写字符串
 * （以换行符\n为标示，标示以行字符串的结束）
 * java.io.BufferedWriter缓冲字符输出流
 * java.io.BufferedReader缓冲字符输入流
 * java.io.PrintWriter具有自动行刷新功能的缓冲字符输出流
 * PW内部会自动连接BufferedWriter作为缓冲功能

PrintWriter("pw.txt");
		 * 对文件直接进行写操作
		 * PW直接支持对文件操作的构造方法
		 * PrintWriter(String path)
		 * PrintWriter(File file)
在流连接中创建PrintWriter
		 * 直接将PW连接到字节流上（内部实际会创建缓冲流
		 * 与转换流）时，不能指定字符集，

* 支持两个重载构造方法，可以传入一个字符串的参数
		 * 该参数csn(charset name 字符集名字)用来指定PW
		 * 按照何种字符集将字符串转换为字节后写出
		 * PrintWriter(String path,String csn)
		 * PrintWriter(File file,String csn)
		若希望按照指定的字符集写出字符串，需要自行连接转换流与缓冲流

写文件需要注意默认编码问题
不规定字符集时调用缓冲
PrintWriter pw = new PrintWriter(fos);
规定之后无法调用只能人为添加
new PrintWriter(
	new BufferedWriter(
		new OutputStreamWriter(fos,"UTF-8")));



缓冲字符流输出流程
创建文件流
创建缓冲字符流/自加缓冲流，转换流和编码      
声明输出内容
输出到文件
关闭缓冲字符流

自动flush：
		 * PrintWriter的构造方法中提供：
		 * PrintWriter(Outputstream out,boolean autoFlush)
		 * PrintWriter(Writer out,boolean autoFlush)
		 * 即：当第一个参数为流（字节流，字符流均可）时，
		 * 可以传入一个boolean类型的第二个参数，该值位true
		 * 时则具有自动行刷新功能，当调用println方法写出一行字符串时
		 * 会自动flush。
				new PrintWriter(
				new BufferedWriter(
				new OutputStreamWriter(
				new FileOutputStream(name),"UTF-8")
						),true);

String readLine()
		 读取一行字符串，以“\n”为标示，将换行符之前的字符组成一个字符串返回，
		 * 返回的字符串中不包含最后的换行符。
		 * 若readLine方法返回值为null时，表示文件末尾。

缓冲字符流输入流程
创建文件流                                 new FileInputStream("pw.txt");
创建转换流                                 new InputStreamReader(fis);
创建缓冲字符流                           new BufferedReader(isr);
声明用于接收的                           String
循环输出                                    (str = br.readLine())!=null
关闭缓冲字节流                           br.close();

NullPointerException空指针异常
StringIndexOutOfBoundsException下标越界

try可以有很多个

异常处理机制中的try-catch
			 * 当JVM在运行程序过程中发现这里出现了异常
			 * 时会实例化该类型的异常实例，并且将程序的
			 * 运行过程设置到这个异常中，并将该异常在出错的这行代码位置抛出
			 * 抛出后JVM会检查出错的代码是否被try包围
			 * 若包围了则将异常传递给catch(若定义了该类异常的catch)并执行该catch块中的代码处理
			 * 针对这个异常的解决办法，否则会将该异常抛出到出错的这行代码所在的方法之外，
			 * 由调用这个方法的代码去解决，若异常抛出到main方法之外则程序停止（单线程情况下）
			 */
* try语句块中出错代码行下面的内容都不会被运行
* catch可以定义多个，针对try代码块中抛出的不同
			 * 种类异常可以分别捕获并处理
* 应当有个好习惯，在最后一个catch中捕获Exception
			 * 防止因为一个未捕获的异常 导致程序中断

异常处理机制中的finally
* 
 * finally时异常处理机制的最终块。特点是：当程序运行到
 * try语句块中后，无论try语句块中的代码是否出现异常，finally
 * 都确保其中的代码片段一定执行。
 * 所以通常那些无关乎程序是否出错然而都要运行的代码就应当定义到finally中确保运行
 * 例如：IO操作后的关闭流
 * 
 * finally的两种定义模式
 * 1、直接跟在try块之后，这种用法实际开发中相对较少，这样写
 * 的目的是不关注异常的处理，但是要确保某些代码无论是否出异常
 * 都要运行使用
 * try{
 * 
 * }finally{
 * }
 * 
 * 2、在最后一个catch之后，常用的方式。
 * try{
 * 
 * }catch(){
 * 
 * }finally{
 * }

* 在IO中使用异常处理机制

* JDK1.7之后退出了一个特性：自动关闭
 * RandomAccessFile,流都可以实现自动关闭
 */
/*
				 * 这里定义的变量所属的类需要实现：AutoCloseable这个
				 * 接口。而RandomAccessFile以及流都实现了。
				 * 编译器再将当前代码编译后会改为在 finally中关闭他们
try(
FileInputStream fis= new FileInputStream("fos.dat")
){}

/*
	 * 通常一个方法中使用throw抛出什么异常，就应当在方法
	 * 声明时使用thows声明该类型异常的抛出以便通知调用者
	 * 在调用当前方法时要处理该异常
	 * 只有抛出RuntimeException及其子类异常时可以不用在
	 * 方法声明时使用throws，其他类型以上则必须这样做，否则
	 * 编译不通过
	 */

/*
		 * 虽然满足语法要求，但是不满足业务要求，可以抛出异常，
		 * 告知调用者这样做不允许
		 */

/*
			 * 当调用一个含有throws声明异常抛出的方法时
			 * 编译器会检查是否有处理该异常，若没有则编译
			 * 不通过
			 * 而处理异常的方式有两种：
			 * 1：使用try-catch捕获并处理该方法抛出的异常
			 * 2：在当前方法上继续使用throws将该异常抛出
			 */

* 在重写父类一个含有throws声明异常抛出的方法时，对throws的重写原则
//可以不抛出异常
//可以抛出部分异常
//可以抛出父类方法抛出异常的子类型异常
//不可以抛出额外异常
//不可以抛出父类方法抛出异常的父类型异常

//输出错误堆栈信息
e.printStackTrace();
自定义异常通常用来说明业务逻辑错误等
RuntimeException：非检测异常
可检测异常
非检测异常
try-catch-finally
java中处理异常的机制
try-catch、thow
thow和thows的区别：
一个是动作一个是声明
finally\final\finalize三者的区别
异常必走、修饰词、Object中方法名(GC回收垃圾时自动调用)
Throwable子类有Error\Exception
Exception子类有RuntimeException
空指针
下标越界
数学异常
类型转换

 * java.net.Socket套接字
	 * Socket封装了TCP协议，使用它可以基于两条流完成
	 * 网络间通讯
TCP、UDP
			 * 实例化Socket时要传入两个参数
			 * 1：服务端的IP地址信息
			 * 2：服务端的端口号
			 * 实例化Socket的过程就是连接服务端的过程
			 * 若成功连接上服务端那么实例化完成，否则会
			 * 抛出网络异常，
			 * 这里通过IP地址找到对方的计算机，通过端口
			 * 找到运行在对方计算机上的应用程序
			 * 对于客户端而言，对方应当就是服务端了

* 运行在服务端的java.net.ServerSocket
	 * 主要作用有两个：
	 * 1、向系统申请服务端口，客户端就是通过这个端口与服务端
	 * 建立连接的
	 * 2、监听该服务端口，一旦一个客户端连接，SeverSocket
	 * 就会自动创建一个Socket，通过这个Socket就可以与
	 * 刚刚连接的客户端交互了
/*
			 * 初始化服务端的ServerSocket的同时指定
			 * 服务端口，若与系统其他应用程序冲突时则
			 * 会抛出该端口被占用的异常
			 * 
			 */
/*
			 * ServerSocket的accept方法是一个阻塞方法
			 * 当程序执行到这个方法时就“卡住”，实际上
			 * 是在监听申请的8088端口，直到一个客户端通过
			 * 这个端口与服务端建立连接，一旦成功建立，
			 * 该方法会自动创建一个Socket并将其返回。那么
			 * 通过这个Socket就可以与刚刚连接的客户端进行
			 * 交互了
			 * 
			 */
/*当客户端断开连接时，由于客户端的系统不同
			 * 这里的效果不一样
			 * windows断开时，通常这里readLine方法会抛出异常
			 * linux断开时，通常readLine方法会返回null
			 * 
private Socket socket;
socket = new Socket("172.88.6.196",8088);//localhost
OutputStream out = socket.getOutputStream();

private ServerSocket server;
server = new ServerSocket(8088);
Socket socket = server.accept();
InputStream in = socket.getInputStream();

客户端建立流程

声明套接字                             private Socket socket;
初始化套接字   抛异常 /IP/端口 new Socket("172.88.6.196",8088);
建立套接字输出流    抛异常       socket.getOutputStream();
建立缓冲字符输出流                 new PrintWriter
输出

服务器建立流程

声明服务器套接字
初始化套接字  /端口 抛异常
建立套接字输入流 抛异常
建立缓冲字符输入流
判断输入流内容
输入

/*3.13.1
 * 线程
创建、可运行、运行、阻塞、死亡
线程调度
线程并发：
多条线程同时运行
线程与进程
 * 线程允许我们并发执行多段代码，感官上就是这几段代码时
 * 同时运行的，但实际上他们是并发运行的
 * 创建线程有两种方式
 * 第一种：继承Thread并重写run方法，其中run方法的内容
 * 				是这个线程需要并发运行的代码
 * 
Thread a = new MyThread1();
a.start();
class MyThread1 extends Thread{
	public void run() {
/*
		 * 启动线程要调用start方法，而不是直接调用run方法，
		 * 当start方法执行完毕后，线程纳入线程调度，当该
		 * 线程获取CPU时间片开始执行时，会自动调用run方法
		 */
/*
 * 第一种创建线程的方式有两个不足
 * 1：继承冲突，由于java是单继承的，这就导致若继承了线程就不
 * 能继承其他类，在实际开发中很不方便
 * 2：将线程要执行的任务直接定义在线程run方法中会导致线程
 * 与线程要执行的任务有一个必然的耦合关系，不利于线程的重用
 */

* 第二种创建线程的方式：
 * 实现Runnable接口，单独定义线程任务
 */
Runnable r1 = new MyRunnable1();
Thread a = new Thread(r1);
a.start();
class MyRunnable1 implements Runnable{
public void run() {
/*3.13.3
 * 使用匿名内部类方式完成线程的两种创建
 * 
/*
		 * 方式一创建：继承Thread重写run方法
		 */
Thread t1 = new Thread(){
			public void run() {
/*
		 * 方式二创建：单独定义任务(实现Runnable接口)
		 */
Runnable r2 = new Runnable() {
			public void run() {
Thread t2 = new Thread(r2);
		t2.start();

* 线程提供了一个静态方法：
 * static Thread currentThread()
 * 该方法可以获取运行这个方法的线程
 * java中所有的代码都是线程执行的，main方法也不例外，实际上
 * 程序启动后，虚拟机就会创建一个线程来执行main方法
 */Thread main = Thread.currentThread();
获取线程信息的相关方法
//获取main线程
		Thread main = Thread.currentThread();
//获取线程名字
		String name = main.getName();
//获取线程的唯一标示
		long id = main.getId();
//获取线程的优先级
		int priority = main.getPriority();
//获取线程是否处于活动状态
		boolean isAlive = main.isAlive();
//获取该线程是否为守护线程
		boolean isDaemon = main.isDaemon();
//线程是否被中断
		boolean isInterrupted = main.isInterrupted();

* 线程的优先级
 * 线程何时被运行听线程调度统一管理，线程无法主动获取CPU
 * 时间片，只能被动的被分配，线程调度也会尽可能均匀的将时间
 * 片分配给一起并发的各个线程
 * 
 * 线程优先级可以最大程度的改善某个线程获取CPU时间片的次数
 * 因为理论上线程优先级越高的线程获取CPU时间片的次数越多
 * 而线程优先级一共划分为10个等级，用数字1-10表示
 * 其中1是最低优先级，10为最高优先级，5为默认值
 */
max.setPriority(Thread.MAX_PRIORITY);
min.setPriority(Thread.MIN_PRIORITY);

sleep阻塞，需要抛异常
	Thread.sleep(1000);
	 * 线程提供了一个静态方法：
	 * static void sleep(long ms)
	 * 该方法可以让运行该方法的线程阻塞指定毫秒。当超时后该线程
	 * 会自动回到RUNNABLE状态等待再次并发运行。
	 * 该方法要求捕获InterruptedExcption,当一个线程调用了
	 * sleep方法进入阻塞状态的过程中若调用了这个线程的interrupted
	 * 方法时会中断这个线程的阻塞状态并抛出异常
	 * 所以，若调用一个线程的interrputed方法时会有两种情况
	 * 1：若线程没有处于阻塞时会直接中断该线程
	 * 2：若线程处于阻塞状态时则中断该阻塞


* 守护线程又称为“后台线程”
	jack.setDaemon(true);
	 * 线程默认创建出来都不是守护线程，若希望将一个线程设置为
	 * 守护线程需要调用线程提供的方法：setDaemo(boolean on)
	 * 守护线程在使用上与普通线程没有区别，但是在结束时机上有
	 * 一点不同，即：当一个进程结束时，所有正在进行的守护线程都会被强制在中断，
	 * 进程结束：当一个进程中所有普通线程结束时，进程结束 
	 * 所以守护线程通常运行的任务时不关心何时让其结束时，可以将
	 * 这个任务用守护线程运行，这样当进程结束时它会自动结束
	 * GC就是运行在一个守护线程上的
		 * 设置为守护线程，需要注意，设置守护线程必须
		 * 在线程start方法调用之前进行
		 */


	/*3.14.1
void=join() 抛异常
	throws InterruptedExcption
	 * 该方法允许一个线程在join方法所属线程后面等待，
	直到该线程运行
	 * 完毕后才会继续工作，join会阻塞等待的线程
	 * 所以若在这个期间该线程的interrupt方法被调用的话，
	该线程会抛出中断异常
	在需要等待的线程中调用被等待线程的join方法实现该功能

同步方法
	synchronized
	 * 多线程并发安全问题
	 * 当多个线程并发操作同一数据时，由于线程切换时机不可控，
	 * 会导致操作该数据的代码为按照设计需求顺序执行，严重时
	 * 可能会导致系统瘫痪
	 * 当一个方法是用synchronized修饰后，该方法变为“同步方法”
	 * 即：当多个线程执行该方法时，不能同时执行方法内部，只能有
	 * 先后顺序的运行。这就避免了多个线程在方法内部同时操作一个
	 * 资源导致出现线程安全问题
	 * 
	 * 在方法上直接使用synchronized修饰后，那么同步监视器
	 * 对象就是当前方法所属对象“this”
	 */

yield()方法
	Thread.yield();
	主动让出CPU时间，模拟线程执行到这里时正好没有事件发生
	线程切换

 * 同步块
	synchronized(this) {	
	 * 有效的缩小同步范围可以在保证并发安全的前提下提高
 	* 并发效率
	* 同步块可以更准确的指定需要多线程同步运行的代码
	片段。
	格式：
	synchronized(同步监视器对象){
		需要同步运行的代码片段
	}
	同步监视器对象可以是java中的任何对象，只要满足一个条件
	，即：需要同步运行该代码片段的多个线程看到的这个同步监视器
	对象必须是“同一个”即可



静态方法若使用synchronized修饰
	那么该方法一定具有同步效果
 	* 当我们使用一个类时，JVM便会加载这个类的class文件，并在
	 * 内部实例化一个Class类的实例用于保存加载的这个类的信息，
	 * 通过Class类的实例JVM就可以得知其表示的类的相关信息，
	 * 比如有哪些属性，构造方法，成员方法等等，在JVM内部，每个被
	 * 加载的类都有且只有一个Class的实例与之对应
	 * 那么一个类的静态方法使用synchronized修饰后，那么该方法
	 * 的同步监视器对象就是这个类所对应的Class实例


互斥锁
	 * 当使用synchronized修饰多段代码时，只要这些同步块使用
	 * 同一个同步监视器对象时，那么这些代码间就是“互斥”的，即：
	 * 多个线程不能同时在这些代码间同时运行


java.util.Collection
	集合框架
		集合与数组相似，也是可以保存一组元素，并且提供了操作元素
		的相关方法，Collection是所有集合的顶级接口，规定了集合
		应当基本的功能方法

Collection两个常见的子接口：
	java.util.List:
		ArrayList()
			可重复集。并且有序
	java.util.Set:
		HashSet();
			不可重复集，大部分实现类无序

		元素是否重复依靠元素自身equals比较的结果而定

创建List集合
Collection c = new ArrayList();
添加集合元素
boolean = c.add("one");
返回当前集合元素个数
size();
判断是否为空集
isEmpty();
判断当前集合是否包含给定元素
boolean = contains(p);

		集合判断给定元素是否被包含是依靠元素equals比较的结果
		只要给定元素与集合现有元素存在equals比较
		为true的情况时，集合就认为包含该元素

从集合中删除给定元素
c.remove(p);。。。。。。。。。。。。需要传参

		删除也是将给定元素与集合元素顺序进行equals比较
		将比较结果为true的元素删除。对于List集合而言，
		若有重复元素则只删除一个

遍历集合元素
Iterator iterator()

Iterator it = c.iterator();

迭代器方法：判断集合是否还有下一个元素可以遍历
boolean = it.hasNext()

当前元素
Object = ()it.next();需要强转

		迭代器要求在遍历的过程中不能通过集合
		的方法增删元素，否则会导致遍历失败抛出异常

迭代器方法：删除当前遍历元素
it.remove();。。。。。。。。。。。。不需要传参

for(String str:array) {
		* 增强型for循环，也称之为新循环，for each
		 * 新循环是自JDK1.5之后推出的一个特性，用于遍历集合或数组
		* 新循环并非新的语法，这是编译器认可的，而非虚拟机
		 * 编译期在编译源程序时会将新循环遍历数组改为使用
		* 传统for循环遍历

for(Object o: c) {
		新循环遍历集合会被编译器改为使用迭代器遍历
		所以使用新循环遍历集合的过程中不能通过集合的
		方法增删元素


把一个集合添加到另一个集合中
c1.addAll(c2);

判断当前集合是否包含给定集合中的所有元素
判断依然是依靠元素equals比较结果判定
c1.containsAll(c3);

删除当前集合中与给定集合的共有元素（给定集合的
元素不会发生变化）
c1.removeAll(c3);

获取远端计算机地址信息
InetAddress address = socket.getInetAddress();
//获取客户端IP的字符串形式并赋值到属性中
String = address.getHostAddress();


* 泛型
Collection<String> c = new ArrayList<String>();
	 * 泛型是JDK1.5之后推出的一个特性，也称为参数化类型
 	* 泛型也是编译器认可的，而非虚拟机
 	* 泛型可以用来约束一个类当中属性，方法的参数和返回值类型	
	 * 泛型的原型时Object，不指定则使用原型
	 * 当一个类声明了泛型后，那么在使用这个类时，可以在类名后面
 	* 指定泛型的实际类型，编译器会在编译源代码是完成下述工作：
	 * 1：当给泛型类型变量设置值时，编译期会检查实际数据的类型
	 * 是否符合泛型要求，不符合编译不通过
	 * 2：在获取泛型类型的值时，编译期会自动将其转换为泛型实际
	 * 类型
	 * 泛型在集合中被广泛使用，用来约束集合中的元素类型
	泛型不支持基本类型

boolean add(E e)
		 * 由于boolean add(E e)方法中参数类型是泛型，那么
		 * 编译期会参考Collection定义时实际指定的泛型类型
		 * 以当前案例为例，Collection<String> c这里我们在
		 * 使用集合时实际指定的类型为String，那么编译器在
		 * 编译下面C.add(1)时，认为该add方法的参数类型应当
		 * 是String，所以传入非字符串类型数据时编译不通过 
		 * 
Iterator<E> iterator()
		 * 迭代器
		 * Iterator<E> iterator()
		 * 迭代器内部的：E next()方法中返回值参看泛型
		 * 所以下面代码中迭代器泛型指定为String后，那么
		 * next方法返回的类型编译期会直接转换为String
		 */

泛型后增强for循环集合时可以直接用泛型指定类型接收元素
泛型不能使用基本类型
泛型的实际类型是Object，只是告知编译器将其当作什么看待

* List集合
	List是Collection常见的子接口，常用实现类为：
java.util.ArrayList:
	内部有数组实现，查询性能好，增删慢
java.util.LinkedList:
	内部由链表实现，增删性能好，尤其在首尾增删元素，查询慢
	性能没有苛刻要求的前提下，通常使用ArrayList
	由于List的实现都是有序的，所以提供了一套通过下标操作
	元素的方法 

E get(int index)
		 * 获取当前集合指定下标位置所对应的元素
		 * String str = array[i];
		 * 获取第二个元素

E set(int index ,E e)
		 * 将给定元素设置到指定位置上，返回值为该位置原来
		 * 对应的元素
		 * 所以set方法是替换元素操作
		 * 注意，下标必须在当前集合允许的范围内 

List重载的一对add，remove方法

void add(int i , E e)
		 * 将给定元素插入到指定位置

E remove(int index)
		将指定位置对应的元素删除并将其返回

List subList(int start,int end)
		获取指定范围内的子集，
		操作/删除子集元素就是操作/删除原集合对应元素

String[] array = c.toArray(new String[c.size()]);
		* 集合转换为数组
		 * Collection接口中定义了一个方法：toArray，
		要求所有集合都可以转换为一个数组

List<String> list = Arrays.asList(array);
		数组转换集合
		向集合添加/删除新元素时会抛出异常，
		因为数组是定长的，添加会导致数组扩容，
		这样当前集合就不能表示原数组，
		 * 所以不支持这个操作

List<String> list3 = new ArrayList(list);
		* 若希望对集合元素作增删操作，那么需要自行创建
		 * 一个新集合。所有的集合都支持一个参数为Collection
		 * 的构造方法，这个构造方法的作用是在创建当前集合的
		 * 同时包含给定集合中的所有元素

Collections.sort(list);
		排序集合
java.util.Collections
		是集合的工具类
		 * 其中提供的静态方法sort可以对给定的List集合
		 * 进行自然排序（从小到大）
		* 该方法要求集合元素必须可比较大小，即：
		 * 集合元素必须实现Comparable接口并定义元素的比较规则
		 * 
		 * 侵入性

/*当实现了Comparable接口后，就要重写其中的方法
	 * int compareTo，该方法的作用是判定当前对象（方法中
	 * 的this）与参数对象o的大小关系
	 * 
	 * 返回值为一个int值，不关注具体取值，关注的是取值范围
	 * 当返回值>0当前对象大于参数对象（this>0）
	 * 当返回值<0当前对象小于参数对象（this<0）
	 * 当返回值=0当前对象等于参数对象（this=0）
	 */
Comparator
		比较器接口
	 * 比较器是一个中立的角色，用于定义两个元素之间比较规则
	 * 需要重写抽象方法：compare(T o1,To2)
	 * 该方法是用来判定o1与o2的大小关系。返回值仍然是一个整数
	 * 当返回值>0:o1>o2
	 * 返回值<0:o1<o2
	 * 返回值=0:o1==o2
Collections.sort(list,
new Comparator<String>() {
public int compare(String o1,String o2) {
return o1.length()-o2.length();}});

* 队列，经典的数据结构
 * 队列也可以保存一组元素，但是对于存取元素而言是有限制的
 * 要求必须遵循先进先出原则
 * 队列一般的应用场景是实现某些操作要求有序进行时使用

* java.util.Queue队列接口
		 * Queue继承自java.util.Collection
		 * 队列自身也提供了符合队列要求的操作方法
		 * 常用实现类：java.util.LinkedList

boolean offer(E e)
		* 队列提供了入队操作，将给定元素添加到队列末尾

E poll()
		出队操作，获取队首元素，获取后该元素即从队列中被删除
E peek()
		引用队首元素，获取后该元素不会被移除

队列可以使用新循环遍历队列，元素不受影响，仍然会在队列中

数组没有length()这个方法,但有这个属性；String有length()方法。

	* 双端队列，两端都可以出入队的队列
 java.util.Deque接口，继承自java.util.Queue
Deque<String> deque = new LinkedList<String>();
	 * 规定了双端队列的功能方法
	 * 常用实现类：LinkedList
offer("one");
offerFirst("three");
offerLast("four");
poll();
pollFirst();
pollLast();

* 栈结构
Deque<String> stack = new LinkedList<String>();
	 * 栈遵循先进后出原则
	 * Deque可以实现栈的功能，值调用一段进出队操作就实现了
	 * 为此Deque也为栈专门提供了对应方法
	 * 栈在实际开发中可以完成“后退”这样的功能
push("one");
pop();

list = Collections.synchronizedList(list);
set = Collections.synchronizedSet(set);
	* 将集合转换为线程安全的
	 * 集合的工具类Collections提供了将现有集合转换为线程安全的方法
	* 文档上由说明一个问题，即：
		 * 线程安全的集合也不同迭代器遍历当前集合的操作
		 * 作互斥，所以在并发操作集合时，存在遍历操作时，
		 * 需要自行维护他们之间的互斥操作

* 双缓冲队列
BlockingQueue<String> queue
			= new LinkedBlockingQueue<String>();
 	* 双缓冲队列内部实际上由两条队列组成，存取交替进行，这样
	 * 就可以保证在并发安全的前提下取消存取互斥的操作，提高并发效率
offer("one");
		 * 阻塞队列提供了另一个offer方法，对于有些队列
		 * 而言，当队列满了，则调用offer方法时允许等待
		 * （阻塞运行offer方法的线程）指定的时间(长度，单位)
		 * 在这段时间中若队列有空余则入队成功
queue.offer("five", 5, TimeUnit.SECONDS);

8080是Tomcat使用的默认端口号。
HTTP协议要求客户端与服务端之间的通讯采取一问一答的模式
HTTP有两个版本，1.0和1.1
在1.0版本时，HTTP协议要求一次会话完成一次请求与响应
在1.1版本时，一次TCP连接后可以完成多次请求与响应。
一个HTTP请求分为三部分组成：
请求行，消息头，消息正文
1：请求行
请求行由一行字符串表示（以CRLF结尾表示一行字符串）
CR:回车符，在ASC编码中对应值为13
LF：换行符，在ASC编码中对应值为10

请求行由三部分组成：
method url protorol(CRLF)
请求方式  请求次元路径  协议版本
请求方式常见的：
GET：地址栏传参形式，用户提交的数据会附带在url部分
PSOT：用户递交的数据会被包含在消息正文中传递，通常上传
			附件就要使用POST形式传递
2：消息头
消息头由若干行组成，每一行表示一个头信息
每个消息头的格式为：
name:value(CRLF)
消息头名字：消息头对应的值

当所有的消息头都发送完毕后，客户端会单独发送一个CRLF表示
消息头部分结束
3：消息正文
消息正文是2进制数据，是客户端发送的用户数据，它可能是用户
提交的附件内容，也可能是用户提交的注册信息等内容。
具体这个正文附带的数据是什么类型，有多少字节会在消息头中
有对应的说明。
在消息头中用于说明消息正文信息的两个头：
Content - Type:用于说明消息正文中的数据是什么
Content - Length:用于说明消息正文总共多少字节

HTTP中的响应
响应是服务端发送给客户端的内容，HTTP定义了响应的格式
一个HTTP响应包含三部分：状态行，响应头，响应正文

1:状态行
状态行由三部分组成：
protorol status_code status_reason(CRLF)
协议版本 状态代码 状态描述

状态代码是一个数字，用于告知客户端服务端处理该请求的结果
状态码是一个三位数字，分为5类：
1xx:在http1.0协议中不支持，表示信息化，说明一个临时响应
2xx:成功，表示服务端成功处理了客户端的请求
3xx:重定向，表示服务端要求客户端重新请求指定地址
4xx:客户端错误，表示客户端的请求出现偏差，导致服务端无
		法处理该请求
5xx:服务端错误，表示客户端请求以接受，但服务端没有正确
		处理该请求

2:响应头
	响应头的格式与消息头一致，每一行为一个响应头信息，当所有
	的响应头发送完毕后，要单独发送一个CRLF
	响应头中的不同的头也有不同含义，有的用来说明服务端的基本
	信息，有的用来说明响应正文内容，有的用来说明传输方式等。
	
3:响应正文
	响应正文是2进制数据，是服务端回复客户端的实体内容。该
	内容具体是什么以及总共多少字节也会在响应头中说明。
	对应响应正文的说明，两个响应头是：
	Content-type,Content-length

路径：
../ 是上级目录

java.util.Map
	 * Map 查找表
	 * Map描述的是一个多行两列的表格，左列称为key，右列称为value
	 * 存储数据总是以key-value成对存储，而查询(获取)值是根据
	 * key获取对应的vaule
	 * 所以使用上经常是将需要作为查询条件的值作为key，将查询的
	 * 内容作为value保存在Map中
	 * Map是一个接口，定义了Map的功能方法。常用的实现类为：
	 * java.util.HashMap，称为散列表，哈希表
	 * HashMap是基于散列算法实现的Map，当今查询最快的数据结构
Map<String,Integer> map
			= new Hashcom.webserver.http.HttpRequest.queryStringMap<String,Integer>();
* V=put(K k,V v)
		 * 向当前map中存放一组键值对
		 * 
		 * Map有一个要求，在Map中key是  不可以重复的，是否
		 * 重复是根据key元素equals比较的结果而定的。当使用
		 * Map已有的key存放一个新的value值时，Map的put
		 * 操作变为替换value操作。那么返回值则为该key原来
		 * 对应的value。若key不存在则存放后返回值为null；
map.put("语文", 99);
Integer i = map.put("数学",9);
Integer value = map.get("英语");

* Map的遍历操作
 	* 遍历Map有三种方式：遍历所有的key，遍历每组键值对以及
 	* 遍历所有的value。其中遍历所有的value这个操作不常用
* 遍历所有的key
		 * Set=keySet();
		 * 将当前Map中所有的key存入一个Set集合后将其返回
		 * 。那么遍历这个Set就等于遍历所有的key
Set<String> keySet = map.keySet();

* 遍历每一组键值对
Set=entrySet()
		 * 将当前Map中每一组键值对存入一个Set集合后返回
		 * java.util.Map.Entry
		 * Entry是Map的内部接口，不同的Map实现类都实现了
		 * Entry接口，该接口意义是其每一个实例表示这个Map
		 * 中的一组键值对。
		 * Entry提供了常用的方法：
		 * K=getkey():获取对应的key值
		 * V=getValue():获取对应的value值
Set<Entry<String,Integer>> entrySet = map.entrySet();
String key = e.getKey();
Integer value = e.getValue();

遍历所有的value
		 * Collection=values()
		 * 将当前Map中所有的value存入到一个集合后返回
Collection<Integer> values = map.values();

* LinkedHashMap是有序的HashMap，内部使用
		 * 链表维护了遍历顺序，可以达到遍历元素的顺序
		 * 与put元素时的顺序一致
=new LinkedHashMap<String,Integer>();

删除Map元素
 * V=remove(K k)
		 * 根据给定的key删除Map中对应的这组键值对
		 * 返回值为这个key对应的value
Integer value = map.remove("英语");

	判断当前Map是否包含给定的key或value
boolean=containsKey(K k)
	 * 判断当前Map是否包含给定的key，根据key元素equals
boolean ck = map.containsKey("语文");
boolean=containsValue(V v)
	 * 判断当前Map是否包含给定的value
boolean cv = map.containsValue(99);

* Hashmap是当今查询速度最快的数据结构，内部由数组实现保
 * 存元素。HashMap是根据key的hashcode值计算出其对应的
 * value的数组下标位置从而存放，也根据这个来进行查找。
 * 所以实际上HashMap做到了避免查找数据通过遍历来完成，这样
 * 就不受数组长度的影响来影响查询效率了
 * 
 * 由于key的hashcode直接决定了这个元素在HashMap内部数组
 * 的位置，而key的equals方法决定着HashMap内部的key是否
 * 有重复，这就导致这两个方法必须妥善的重写，因为若两个元素
 * key的hashcode值相同而equals比较不是true则会在HashMap
 * 内部出现链表，这直接影响查询性能
 * 
 * hashCode方法与equals方法是Object定义的方法，java中
 * 所有的类都有，且Object已经妥善的重写了这两个方法，但是
 * 实际开发中当我们需要重写equals方法时要注意。API手册对于
 * 重写有明确的说明：
 * 1：成对重写
 * 		当我们需要重写一个类的equals方法就要连同重写hashcode
 * 2：一致性
 * 		当两个对象equals比较相同时，hashCode方法返回的值也要
 * 相等。反过来则不时必须的，但时最好能做到当两个对象的
 * hashCode值相等时equals比较也为true，否则当这样的对象作为
 * HashMap的key使用时就会产生链表影响查询性能。
 * 3：稳定性
 * 		一个对象在equals方法中参与比较的属性值没有发生过改变
 * 的前提下多次调用这个对象的hashcode方法时返回的数字
 *  不应发生改变

submit 提交按钮
button 按钮
<html>
<head>
<meta charset="UTF-8">
<title>
<body>
<center>
<table border="1" >
<tr>
<td>

* 线程池
1.5以后才出现,只是一个接口不能new对象
 * 线程池时一个容器，用于管理线程
 * 使用线程池可以解决下面的问题：
 * 1:控制线程数量
 * 2:重用线程
ExecutorService threadPool
= Executors.newFixedThreadPool(2);
threadPool.execute(runn);导入任务
threadPool.shutdown();停止
threadPool.shutdownNow();立即停止

解析XML文档的大致步骤
		 * 1：创建SAXReader
		 * 2:使用SAXReader读取xml文档并声称Document
		 * 		对象。这一步也是DOM解析耗时耗资源的体现
		 * 		因为要将XML文档全部读取完毕并存入到Document
		 * 		对象中
		 * 3：通过Document获取根元素
		 * 4：按照文档的层级结构从根源开始逐级获取子元素
		 * 		已达到遍历XML文档数据的目的
若想使用SAXreader,需要导入dom4j这个jar包
Element的每一个实例用于表示XML文档中的一对标签
			 * 其提供了很多获取其表示的标签信息的方法：
			 * Atring getName()
			 * 获取当前标签的名字
			 * String getText()
			 * 获取当前标签中的文本
			 * 例如：<a>abc</a>,getText获取的就是abc
			 * String ElemenText(String name)
			 * 获取当前标签中指定名字的子标签中间的文本
			 * e.elementText("abc");
			 * 等同于：
			 * e.element("abc").getT
			 * 
			 * Element element(String name)
			 * 获取当前标签中指定名字的子标签
			 * 
			 * List elements()
			 * 获取当前标签中所有子标签
			 * 
			 * List elements(String name)
			 * 获取当前标签中所有指定的同名子标签
Element提供了获取属性的方法：
				 * Attribute attribute(String name)
				 * 获取当前标签中指定名字的属性
				 * Attribute的每一个实例用于表示一个属性，常用
				 * 方法：
				 * String getName():获取属性的名字
				 * String getvalue():获取属性的值

获取指定名字属性对应值的方法：
empEle.attributeValue("id")

SAXReader reader = new SAXReader();
Document doc = reader.read(new File(
Element root = doc.getRootElement();
List<Element> list = root.elements("servlet");
for(Element e : list) {
String extension = e.elementText("extension");

java反射机制
 * java反射机制可以在程序运行期间动态获取一个类的信息，
 * 例如：获取类的名字，定义了哪些方法，哪些属性等信息。
 * 并且可以动态调用这些方法，而无需在编码期间通过硬编码
 * 方式决定实例化的对象以及调用的方法。从而大大提高代码
 * 的灵活度。
 * 但是反射要适度使用，因为反射消耗资源大，实际开发中
 * 大部分代码都是传统硬编码形式在编码期间确定代码调用
 * 关系，而少量的使用反射可以提高后期维护性和灵活性
 * 
 * 再反射机制中一个非常重要的类：
 * Class类
 * Class类的每一个实例用于表示JVM加载的一个类。当JVM加载
 * 一个类时（读取这个类的class文件）会实例化一个Class的实例
 * 用于表示加载的这个类，并且在JVM内部每个被加载的类有且只
 * 由一个Class的实例与之对应。通过Class的实例我们可以获取
 * 其表示的类的相关信息（类的名字，定义了哪些方法，哪些属性
 * 等信息）。并且通过Class的实例可以实例化其表示的类
 * 
JVM在执行下面代码时，发现要实例化Person类实例
		 * 那么首先会加载Person的class文加。然后实例化它
		 */
//		person p = new person();
		/*
		 * Class提供了一个静态方法forName，可以通过字符串
		 * 形式指定要让JVM加载的类的完全限定名：包名.类名

快速获取某个类的类对象还可以通过使用该类的
			 * 静态属性class得到
			 * 相较于使用Class.forName的形式，下面的方式
			 * 属于硬编码形式获取一个类的Class实例
Class cls2 = person.class;
System.out.println(cls2.getName());

使用反射调用某个类的方法
使用反射调用某个实例的方法的步骤
		 * 1:加载这个类
		 * 2:通过类对象实例化实例
		 * 3:通过类对象获取这个类定义的要执行的方法
		 * 4:调用这个实例的该方法
		 */
		Class cls = Class.forName("reflect.person");
		Object obj = cls.newInstance();
		/*
		 * 获取person中定义的无参方法sayHello
		 * Class提供了获取其表示的类相关定义的一系列方法(详参文档)
		 * Method getDeclaredMethod(String name,Class[] types)
		 * 该方法可以获取当前Class所表示的类定义的指定名字以对应的
		 * 参数列表的方法。
		 * Method的每一个实例用于描述一个方法
		 */
		Method method = cls.getDeclaredMethod("sayHello", null);
		
		/*
		 * invoke方法是用来执行当前Method实例所表示的方法
		 * 由于当前Method表示的时person的午餐方法sayHello
		 * 而该方法时一个成员方法，那么必须调用指定的person
		 * 实例的该方法
		 */
		//obj.sayHello();
		method.invoke(obj, null);

Class提供了一个方法：newInstance().
 * 该方法可以调用Class实例所表示的类的无参构造方法实例化
 * 这个类。
Class cls = Class.forName("reflect.person");
		Object obj = cls.newInstance();
		person p = (person)obj;

调用某个类的有参方法
Method method = cls.getDeclaredMethod(
"sayHello",new Class[] {String.class,int.class});
		Object o = cls.newInstance();
		method.invoke(o, new Object[] {"苍老师",22});

jdk1.5之后推出了一个特性：可变参数,只能放在最后
public static void dosome(Object... arr) {

调用隐私方法
method.setAccessible(true);

字符串转字节数组需要添加转码格式:UTF-8

webkit浏览器内核
国内:360
国外:chrome,safari
Opera 欧鹏
Mozilla firefox
IE
不同浏览器对相同前端页面代码的解析不同
html在服务器上保存
html文件在浏览器上解析运行
html就是标签属性相对固定的XML 
title显示在网页的选项卡中，是网页的标题
设置title，有利于SEO(搜索引擎优化)优化
meta告诉浏览器使用什么编码规则解析本网页
1/文本标签-跟论文格式很相似
标题<h1></h1>...<h6></h6>
段落<p>
列表
	无序列表，unordered-list
	<ul>
		<li>
	有序列表ordered-list
	<ol>
		<li>
分区<div>
	默认看不到，为了逻辑分区而存在
h5新添了一些和div功能一样但是可读性更高的分区标签
header footer nav
<span style="color:pink">
行内分区<span>
	<i>/<em>斜体
	<b>/<strong>加粗
	<u>下划线
	<del>/<s>删除线
div是块级分区，一个div独占一行
span是行内分区，与其他行级元素一起占一行
元素的显示方式
块级元素独占一行
行内元素不会换行
行内元素空格折叠现象
行内元素不管连着写多少个空格都显示为一个空格
不管连着写多少个回车都显示为一个空格
实体引用
	&nbsp;
	<br>
	&lt;小于号 less than
	&gt;	大于		
图片标签<img src="路径">
网页中图片路径的写法
	绝对路径
	在一个网页中显示其它网站中的图片
	行业内，称专门提供网页图片的网站为图床
	好处：图片占用图床网站的存储资源
	坏处：图床网站只要路径一变，图片就无法显示
	相对路径
	在同一个网站内部
	利用文件路径相对的关系找到图片位置
	在同一个网站中，很少使用绝对路径
img标签的属性
	<img
		src="路径"
		alt="图片显示失败是，显示的文本"
		title ="图片的描述文本"
		width="图片宽度，单位px"
		height="图片高度，单位px"
	>
img标签如果设置宽高，只设置其中一项，另外一项自动匹配防止失真
宽高一般使用css去处理，很少使用标签去处理
<img>支持格式
	jpg 不支持
	png支持透明色 
	gif支持动态图
超链接<a> href=“”传地址
	用于页面跳转
超链接的其他属性
	target用于设置新网页打开的窗口
	_self在当前窗口打开新页面
	_blank在新窗口打开新页面
	_top在窗口主题中打开新页面
	_parent在父框架中打开新页面
锚点的使用

边框<table>
border 边框
align 对齐方式
cellpadding边框与内容的距离
cellspacing单元格之间的距离
单元格合并
rowspan跨行
colspan跨列
表单及表单控件
action=""表单提交的url
method=""数据提交的方法get post
enctype=""表单数据的编码方式
form表单控件
input控件/9种
	<input type="xxx">
	1/type="text" 文本输入框
		placeholder文本提示
	2/type="password" 密码输入框
	3/type="radio"单选框
	4/type="checkbox"多选框
	5/type="submit"提交按钮	value
	6/type="reset" 重置按钮
	7/type="button" 普通按钮，专门为了调用js和jq代码
	8/type="hidden" 隐藏域,专门负责储存不想让用户看到的数据
	9/type="file"文件选择框
非input控件
	1/<textarea/>文本域 相当于多行文本框
		主要属性：
		cols：指定文本域的显示行数
		rows：指定文本域的显示行数
		readonly：只读
	2/<select><option></option></select>下拉列表框
		selected默认
1/只有含有name属性的表单控件才可以提交数据
2/提交的值，是value 单选按钮 多选框都需要设置value属性才可以提交数据
3/文本框默认值直接设置value
4/单选框多选框的默认值checked默认选中
5/下拉选的默认值selected
选项框后面的文字标签中如果for=前面选项框id那么点击文字将具有同等效果

<input>标签的checked属性可以设置或返回某个选定复选框或单选框是否被选中

value这个控件最后要传递给服务器的值
maxlength最大长度
readonly只读
onclick=事件
multiple=可以选择多个文件
checked="checked"默认选中
<label>和<span>


CSS层叠样式表
如何使用css样式
1/内联样式
	内联样式不可以重用，优先级最高
	在开发中，只有在学习、测试阶段才会使用
2/内部样式在<head>标签中使用<style>标签声明css样式
	<style type="text/css">
	可以在本html页面中重用，但是无法在其他html中重用，
	在开发中使用不多，在学习、调试时使用较多
3/外部样式，开发中频繁使用
	<link rel="stylesheet" type="text/css" href="style.css">
css特性，有层叠就会有优先级
	最低，浏览器默认样式
	外部样式或内部样式，就近优先
	最高，内联
选择器，准确找到要加载样式的标签
1/标签选择器
	p{color:red;}
	整个html中所有的p标签都会遵循这个样式
2/id选择器，整个html，一个id只能有一个
	<li id="gz"></li>	
	#gz{background-color:pink;}
3/class选择器
	<li class="bg1">北京</li>
	<li class="bg1">上海</li>
	.bg1{background-color:pink;}
4/派生选择器，类似于路径，找到符合要求的标签，
	但是要注意会影响到内部所有子孙标签
	<li><a href="#">深圳</a></li>
	<li ><span><a href="#">派生选择器</a></span></li>
	ul li a{color:#fff;}
5/子类选择器,只影响自己的直接子标签，选择器可以混合搭配使用
	<li><a href="#">深圳</a></li>
	<li ><span><a href="#">派生选择器</a></span></li>
	ul>li>a{color:#fff;}
6/分组选择器，用于编写公共样式
	p,span,label,div,h1{font-size:14px;color:#000;}
	*{margin:0px;padding:0px;}
一般在写项目时，会有先把所有标签的内边距和外边距清0
	因为不用浏览器，默认的内外边距值不同
伪类选择器:
	a:link未访问链接
	a:visited已访问连接
	a:hover:鼠标悬停改变样式
	a:active:选定链接
		在CSS定义中，必须是以上顺序		
	
1/布局相关属性
	width:宽度 单位:px 100%
	height:高度 
	margin:10px;外边距 同时设置4个方向的外边距
		margin:10px 20px; 上下为10 左右为20
		margin:0px auto; 块级标签水平居中
		margin:10px 20px 30px 20px;上右下左
		margin-top:上外边距
		margin-right:右外边距
		margin-bottm:下外边距
		margin-left:左外边距
		overflow: hidden;去除子元素margin-top改变时父元素一起改变的bug
	padding:内边距
	盒子模型
		css渲染页面时使用了一种规则:盒子模型
		一个元素在页面上占据的空间公式如下:
		左外距+左边框宽度+左内边距+内容区域宽度+
		右内边距+右边框宽度+右外边距
使用margin会让元素发生位移效果
使用padding会让元素变大
一个div默认的宽高，宽是父容器的100%，高度为0，此div如果
	不写高度，内部元素多高，div多高
如果一个div内部的上边框与外部的div上边框重合，设置内部
	div margin-top时会有bug，外部div会一起位移，需要在外部div添加
	样式overflow:hidden
	
2/背景属性background
	-background-color 背景颜色
	-background-image 背景图片
		background-image:url("图片路径");
		一旦为div设置了背景图片div内部的元素将会在背景图片只上显示
		
	-background-repeat 背景图片平铺方式
	-background-position 背景图片的定位
	-background-size 背景图片的大小
颜色的值设置方式
	1/直接使用英文单词 red
	2/6位16进制字符串 #ffffff   rgb规则 红绿蓝
	3/3位的16进制字符串#abc 相当于#aabbcc	
	4/rgb(255,255,255);10进制数字表达rgb规则
	5/rgba(255,255,255,0.3);最后一位是0～1之间的小数
		透明度
3/字体属性
	font-size:30px;字体大小(px cm em)
	font-family:"黑体"
	font-weight:字体粗细(磅值，权重)
			90pt;
			lighter---细一点
			normal--普通粗细
			bold------加粗
			bolder---比粗更粗
	font-style:normal 普通样式
	font-italic 斜体样式
4/文本属性
	color:文本颜色#aaa #aabbcc rgb(0,0,0)
	text-align:文本对齐的方式
		left/right/center
	line-height: 200px;
	div中文本默认情况垂直位于行高的中间
	如果希望文本在div中垂直居中只需要把行高
	设置成与div的height属性一致即可
	此处有bug如果字数过多需要折行，那么每一行
	行高都将遵循行高属性
	text-decoration:文本装饰
		none,没有装饰(去除下划线)
		underline,添加下划线
		overline,上划线
		line-through 删除线
5/边框属性

border: 2px solid black;
border-width:边框宽度
border-color:边框颜色
border-style:边框样式
border-top: 2px solid #006699
border-top-width:上边框宽度
border-top-color:上边框颜色
border-top-style:上边框样式
border-ledft/right/bottom

border-left: 3px dotted blue;边框点点
border-bottom: 10px dashed gray;虚线
border-right: 30px double green;双线
border: none;去掉边框
边框圆角
border-radius: 20(圆角半径)px;
如果div是一个正方形，圆角半径设置成高度一半就可以画一个正圆
颜色线性渐变 kit引擎 线性  渐变的   开始变得方向
background: -webkit-linear-gradient(top, #006699 0%, #990066 100%);

6/复杂属性
	1/display	控制元素的显示方式
		display: inline
			让本元素按照行级元素进行显示
			行级元素的特点
			可以与其他行内元素共享一行，不会独占一行
			行内元素不能更改元素height,width的值，大小由内容撑开
			可以使用padding和margin的left和right属性
			top和bottom没有效果
		display: block
			按照块级元素进行显示
			块级元素的特点：
			独占一行，再不设置宽度的情况下，
			块级元素默认宽度是填满父控件的宽度
			块级元素可以改变元素的height，width
			可以设置padding和margin的各种属性
		display:inline-block
			行内块的特点:
			与其他元素共享一行，不独占一行
			可以设置width，height的值
			可以设置padding和margin的各种属性值
		display:none
			隐藏此标签
	2/float	浮动
		float:left;	元素浮动起来后往左放
		float:right;	元素浮动起来后往右放
		一旦元素设置了浮动属性，当前元素将会脱离默认文档流
		在默认文档流之上进行渲染绘制
		当元素浮动起来，元素先前的位置将会被其他元素占用
		如果之前行的元素没有浮动元素只会在本行浮动不上移
		float最常见用法: 把块级元素横向排列
	clear: both;
		清除浮动，当前元素不会被浮动元素覆盖
	3/position 	元素将会脱离默认文档流
		定位，定义元素在页面中的位置
		position:absolute;绝对定位
		position:relative;相对行为
			如果定位使用absolute,原位置会被下一个div占用
			如果使用relative,原位置会保留，不会被占用
			当一个元素被设置定位他回去找上一层元素
			是不是有position:relative,如果没有继续往外层找
			如果找到就以该元素为参照物定位，如果没找到
			以body为参照物
		top/left/right/bottom/z-index
			z-index: 设置层的编号，编号越大，越考上层，
			上层元素会把下层元素覆盖
		position:fixed;相对浏览器窗口定位
					一般应用于固定导航栏

border: 1px solid red;
font-weight: lighter;变细
font-weight: bold;加粗

抽象类只能被继承，实现抽象类的方法。
接口变量可以引用具体实现类的方法

/* 把浏览器默认的内外边距清零 */
	*{
		margin: 0px;
		padding: 0px;
	}

图片默认平铺
background-repeat: no-repeat;

背景位置
background-position

去掉所有li的点
list-style: none;

overflow 溢出 
	1/visible 溢出部分可见
	2/hidden 溢出部分隐藏
	3/scroll 溢出部分显示滚动条

JDK中javadoc是用来生成文档注释，
文档注释会生成（.html 网页文档文件 ）文件

BufferedOutputStream是字节输出缓冲流。java中缓冲流需要套接
一个基本文件流，才能创建流对象
BufferedOutputStream bos = 
new BufferedOutputStream(new FileOutputStream("fileName"));

但&运算两边数字转成二进制 对应位数上都为一，则结果为一，反之为零
4&7=100&111=100

display和margin效果不冲突

background-repeat: no-repeat; 背景图片不重复
background-size:cover;	背景图片全覆盖

html+css+javaScript
	网页的所有交互都要使用javaScript
	网景公司向ECMA(欧洲计算机联盟协会)要求统一js标准
javaScript
	1/可以使用任意文本编辑工具编写
	2/由浏览器内置的javaScript引擎执行代码
	3/解释执行：事先不编译，逐行执行
	4/基于对象：内置大量现成的对象
javaScript使用
事件: 就是js代码被调用的时机
	1/事件定义式:在事件定义的时候直接写js代码
	2/嵌入式: 在<script>标签中写js代码，在本html
		中可重用
	3/文件调用式: 在单独的.js文件内写代码。需要
		引入到网页上才能使用
		<script type="text/javascript" src="my.js">
项目中使用文件调用式
在使用文件调用式的时候，<script>标签必须为双标签,即使没有内容
<script>标签不能即引用js文件，又js代码
alert("小生不才");弹窗
console.log("小生不才")控制台输出

在JavaScript中，在页面上打印出"Tedu OK"的JavaScript语法是：（）
 A.document.write("Tedu OK")


js数据变量
	声明变量
	number类型
		不区分整型和浮点型数值
		所有数字都采用64位浮点型的格式存储
		var x=0x	16进制
		var x=0 	8进制
		var 4.3e23=4.3*10^23

	string类型
		unicode字符/数字/标点符号组成字符序列
		可以使用“” 和‘’	单引号双引号嵌套无序转义
		其他特殊字符需要转义如:\n	\'  \"
		js中没有char类型,字符类型就是长度为1的字符串
	boolean	true false
		在js中boolean参与数学运算,会发生自动转型
		true转为1 flase转为0
		js中关于真假的判定,布尔表达式
		真true:非0数字 非空字符串 非空对象
		假false: 数字0 空字符串 空对象 null 
				undefind	NaN
强制数据类型转换
		parseInt("abc")//not a number /NaN
	typeof(num)判断数据类型
console.log(typeof(num)=="number");
isNaN(n) 判断

num2=null;
console.log(num2+","+typeof(num2));/null,object

var input=document.getElementById("num");
var n=input.value;
input.value=
span.innerHTML=n*n;

onclick	js属性
function	函数

num+2;/"1002"
num*2;/200

数学运算符 + - * /
	除法与java不同,结果直接为小数
	如果String值为一个纯数字,可以与
	+以外的数学运算符计算,变成number
关系运算符	> < >= <= != == === !==
	全等 !== ===
		/* 类型相同,值相同 */
		console.log(s1===s2);

逻辑运算符 ! && || & |

条件表达式
	js可以使用任意值任意数据做条件表达式
	如果使用了非boolean表达式做条件表达式
	真true:非0数字 非空字符串 非空对象
	假false: 数字0 空字符串 空对象 null undefine NaN

方法没有返回值默认为undefine

flag=8;
flag && console.log("没问题")
true && undefine

流程控制语句
	if else
	for
	while
	do while
	switch

创建String对象的两种方式
	var str1="hello";
	var str2=new String("hello");
	str1.length;
大小写转换
	x.toUpperCase();
	x.toLowerCase();
获取指定字符
	x.charAt();
	x.charCodeAt();/底层同java的charAt()底层相同
查询指定字符串
	x.indexOf();
	x.lastIndexOf();
获取子字符串
	x.substring(start,[end]);
	end:结束+1取不到，可以省略
替换子字符串
	x.replace(findstr,tostr);
	findstr:找到的字符串
	tostr:替换为的字符串
	返回值为替换后的字符串
拆分子字符串
	x.split(str1,[length]);
	str1: 分割用的字符串
	length:指定返回数字的最大长度,可以省略
	返回值是分割之后的字符串数组


Number
	num.toFixed(n)
	把number转换成字符串,并保留小数点后n位(四舍五入)

js中的数组
	1/js的array对象中可以存放不同类型的元素
		var arr=[1,"aaa",true]
	2/js的array对象长度可变	arr.push();
	无论使用那种方式创建数组
	本质都是一样的,都是object数据

1/数组倒转
	arr.reverse();

2/数组排序
	arr.sort();
		var arr=[1,112,12,2,213,223,33,15];
		arr.sort();
		(8) [1, 112, 12, 15, 2, 213, 223, 33]
		按照每一个元素的unicode编码排序,比完第一位
		比第二位,
数组排序更改比较规则
/* 1.数组排序默认按照字符串由小到大排序
		2.可以通过替换比较规则来改变排序*/
/* 	function x(a,b){//这是比较规则的方法
		return a-b;//由于排序规则不能更改可以在比较规则中更改顺序
arr.sort(function(a,b){
		return a-b;
	})


js中的函数
	math	数学
	date		时间对象
		一般以服务器的时间为准,每个客户端都有自己
		的data对象客户端时间可调,所以浏览器一般
		接收服务器端传过来的时间进行操作
1970年0：0：0：毫秒数
//这个指定时间,一般来源于服务器
	var d2=new Date("2018/05/01 08:08:08");
	var d3=new Date("2018/05/01 08:08:08");
	console.log(d3.getMonth()+1);//月份需要加一 0--11 
//转换成本地时间的方法
	console.log(d3.toLocaleTimeString());//时分秒
	console.log(d3.toLocaleDateString());//年月日

正则表达式
	.	匹配除了换行符以外的所有字符
	\w	匹配字母/数字/下划线
	\s	匹配任意空白字符
	\d	匹配数字
	^	匹配字符串的开始
	$	匹配字符串的结束
	()	整体
	[]	其中一个
	{}	范围
表单验证

创建正则对象
	1/直接创建
		var reg=/正则表达式/模式;
		模式: g	设定当前匹配为全局模式
			i	忽略大小写检测
	2/创建正则对象
		var reg=new RegExp(正则表达式, 模式);
		全局模式g,规定正则表达式执行全局匹配
		也就是在找到第一个匹配字符串之后,依然
		会继续寻找
正则对象的方法
	var str="you can you up,no can no b b";
	var reg=/no/g;
	//普通模式:从str中找出与reg匹配的第一个子串
	//全局模式:第n次调用,则从str中找出与reg匹配
	//的第n个子串
	console.log(reg.exec(str));//15

	reg.test(str)//判断str是否包含reg匹配的子串

	创建new对象的方式使用正则
		var str=" 1";
		var reg=new RegExp("\\s\\d");
		console.log(reg.exec(str));
		console.log(reg.test(str));
		使用new的方式创建正则对象必须使用转义符

String对象中的正则方法
	str.repalce(reg,"子串");
		把str中与reg匹配的所有子串,替换成目标子串
	str.match(reg)
		返回值是一个数组,比reg.exec(str)方便
		从str中找出和reg匹配的子串,类似reg.exec(str)
	str.search(reg)
		从str中找到与reg匹配的第一个子串的索引

onblur/鼠标选中离开
onclick/点击

取消事件的触发(所有的事件)
	只要在事件中添加代码	return false	
	就可以取消任何事件

如果 onsubmit 句柄返回 fasle，表单的元素就不会提交。
如果该函数返回其他值或什么都没有返回，则表单会被提交。

		异常分为几种类型？写出几个常见异常？
		1）分为运行时异常和非运行时异常
		2）常见的运行时异常：
	NullPointerException(空指针异常)
	NumberFormatException(数字格式化异常)
	ClassCastException(类型转换异常)
	ArrayIndexOutOfBoundsException(数组下表越界异常)
   	 常见的非运行时异常：IOException


byte能用在switch,long不能用在switch:byte能自动转换为int
型，而long不能自动转换。


jdk1.6及以下，String不能用在switch上
jdk1.7及以上，String能用在switch上


public class TestException {
static void fun() throws Exception {
try {
System.out.print("try1 ");
throw new Exception();
} catch (Exception e) {
System.out.print("exception1 ");
throw new Exception(e);
}
}
public static void main(String[] args){
try {
fun();
} catch (Exception e) {
System.out.print("exception2 ");
}
System.out.print("finish ");
}
}
 A.try1 exception2 finish
 B.try1 exception1 exception2
 C.try1 exception1 exception2 finish
 D.try1 exception1 finish

js内置对象之function
	1/js中函数就是function对象
	2/函数名就是指向函数对象的引用
	3/使用函数名可以访问函数对象
	4/函数名和()一起写，是在调用函数
function 函数名(参数){
	函数体;
	return 返回值;
	//如果不写return 默认返回值是undefined
}
	
函数返回值
	不定一返回值类型
	默认返回值是undefined
	可以使用return返回具体值

js的函数没有重载
	调用时只要函数名一样无论传入几个参数调用的都是同一个函数
	没有接收的实参的参数值是undefined
	所有参数都会传递给arguments数组对象
	在js调用函数的过程中，只检测函数名，不检测参数列表
		如果参数个数匹配则直接使用不管参数个数是否匹配
		都可以直接使用arguments对象，访问参数列表
	js中没有重载如果出现相同函数名的多个函数名，最后一个生效

var functionName=new function(参数列表，方法体);

匿名函数，就是不给方法起名字
	前提，这个方法在其他地方不再调用(复用)

全局函数
	可用于所有的javascript对象的函数
	不需要具体对象调用isNaN()/parseInt()/eval()

eval()
	用于计算 表达式字符串
	用于执行字符串中的js代码
在使用eval时，在字符串前后加上()可以避免一些兼容性问题，这是官方的建议

外部对象	BOM包含DOM
	外部对象就是浏览器提供的API
	这些对象有W3C规定，由浏览器开发者设计并开发
	这些对象分为两部分BOM DOM
	我们通过js访问使用这些对象

BOM	Browser object model 浏览器对象模型
	通过使用BOM，可以移动窗口，改变状态文本
	执行所有不与页面内容发生直接联系的操作(不能操作标签)
	没有相关标准，但是却被各个浏览器广泛支持

DOM Docunment Object Model 文档对象模型
	定义了访问操作HTML文档的标准方法
	应用程序通过对DOM树的操作，来实现对HTML文档数据的操作

window对象的常用属性
	1/document:窗口中显示的HTML文档对象
	2/history:浏览国的历史记录对象
	3/location:窗口的地质对象
	4/screen:屏幕对象
	5/navigator:浏览器相关信息(帮助信息)对象

window对象的常用方法
	javaScript所有的全局对象，函数以及变量
		都会自动成为window对象的成员(可以被window对象点出来)
		window.parseInt()/window.isNaN()/window.eval()

弹出窗
	//弹出
		window.alert("沈千君");
	//确定框，有返回值
		var flag=window.confirm("你不应该来这里");
	//输出框，有返回值
		var value=window.prompt("小生不才");

定时器
	多用于轮播图/无缝滚动/电子时钟/倒计时/跑马灯等效果
setInterval(exp,time);
exp:周期性触发的js代码
time:周期间隔，毫秒
返回值:已经启动的定时器的ID
clearInterval(ID) 根据ID停止定时器
	1/周期性定时器，以一定的间隔执行js代码，循环往复
		function fn1(){
			var n=5;//定义5秒时间
			var id=setInterval(function(){
				console.log(n--);
				if(!n){
					clearInterval(id);
				}
			},1000);
			console.log("你不该来这里");
		}
		取消clearInterval(id);
		启动定时器就是相当于启动了一个子线程
		当前fn1相当于主线程，
		两条线程并发执行，不相互等待
		因此主线程在事件触发后立即执行，
		而子线程需要等待1秒后才执行

直接执行加""

	setInterval("alert('I am Comming!');",3000);

	2/一次性定时器，在一个设定的时间间隔之后来执行代码
		而不是在函数被调用后立即执行，只执行一次，
		又叫：延迟定时器
			setTimeout(exp,time)
			exp:一次性执行的代码
			time:延迟的事件，毫秒
			返回值:延迟定时器的ID
			取消clearTimeout(tid);

location
	包含有关当前url的信息
	常用于获取和改变当前浏览器的网址
属性:href	当前窗口正在浏览的网页的网址
	location.href="http://
方法:reload()	重新载入当前网址，同按下刷新按钮
	location.reload();

	location.hostname;根路径
	"doc.tedu.cn"
	location.pathname;请求路径
	"/w3/jsref/dom_obj_location.html"
	location.search;设置或返回从问号 (?) 开始的 URL（查询部分）。


screen
	包含了有关客户端显示屏幕的相关信息
常用属性
	whidth/height	screen.width;
	availwidth/availheight	可用宽高	screen.availWidth;

history
	包含用户在浏览器窗口中访问过的url数据
属性:length:浏览器历史列表中的url数量
方法:back()上一个url
	forward()下一个url
	go(num) -2 -1 0 1 2 取指定历史页面

navigator
	浏览器相关信息
	常用于获取客户端浏览器和操作系统的信息
属性:userAgent
	console.log(navigator.userAgent);/浏览器当前版本信息
		公司名Mozilla 引擎AppleWebKit
		Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 
		(KHTML, like Gecko) Chrome/60.0.3112.7 Safari/537.36

DOM操作
	DOM对节点对象的具体操作
		-- 查找节点
		-- 读取节点信息
		-- 修改节点信息
		-- 创建新节点
		-- 删除节点
	DOM可以找到节点，并且对节点信息/内容/属性/进行增删改查
对节点的读取和修改
	1/读取节点信息
		/* 页面加载事件，在页面加载完毕之后自动触发 */
		window.onload=function(){
			var oP1=document.getElementById("p1");
			//读取节点信息，节点名称/类型
		}
		var imgs=document.getElementsByTagName("img");
		nodeType:节点类型
		元素节点:1
		属性节点:2
		文本节点:3
		注释节点:8
		文档节点:9
		
		nodeName/nodeType属性
		在写js框架的时候，会频繁使用，正常开发很少用
<b>定义粗体字。

	2/读写元素节点的内容(不是值 value)
			双标签中间的文本叫内容
			任何双标签都有内容
	读写双标签内容由两种方式(属性)
		obj.innerHTML/结果含子标签
		obj.innerText/结果不含子标签，只有文本
			console.log(oP1.innerHTML);
			console.log(oP2.innerText);
			oP1.innerHTML="1.<u>读写</u>节点";	可以执行标签
			oP2.innerText="2.<b>查询</b>节点";		不可以

	3/读写节点的值
		表单控件中的数据叫值(value)
		只有input/select/texttarea	有value
			console.log(oBtn.value);
			oBtn.value="走吧";

	4/读写节点的属性
		通过方法读写属性(*)
			console.log(oImg.getAttribute("src"));
			oImg.setAttribute("src","../img/20.png");
			oImg.removeAttribute("src");
		通过标准的属性名读写属性(*)
			className/id/style
			console.log(oP.style.color);
			oP.className="ok";
			不推荐使用style取修改样式，因为内联样式优先级最高，
			修改了内联样式之后，再使用className就无效了

		通过不标准的属性名读写属性，只有高版本浏览器支持
			oA.href	oImg.src/不推荐使用

document.getElementsByTagName("img");	//获取一组标签
(5) [img.hide, img.hide, img.hide, img.hide, img.hide]

Math.ceil()向上取整
Math.floot()向下取整
Math.round()四舍五入/Math(x+0.5)然后向下取整


查询节点
	1/如果需要操作HTML元素必须要先找到这个元素节点
	2/找到节点元素的方式
		1/通过id
			var oLi_gz=document.getElementById("gz");
		2/通过标签名称
			var oUl=document.getElementsByTagName("ul")[0];
		3/通过层次(节点关系)查询
			console.log(oLi_gz.parentNode);/父节点
			console.log(oUl.childNodes);/子节点//存储了文本节点，不好用
			var olis=oUl.getElementsByTagName("li");/只获得子集的标签节点(重点)
			var oli_sz=document.getElementById("gz").parentNode
				.getElementsByTagName("li")[3];/兄弟节点
		4/通过name属性查询节点，一般用于input标签,单选框/多选框
			var radios=document.getElementsByName("gender");

创建新节点

	1/创建新节点(保存在内存中)
		document.createElement("TagName")
			TagName:要创建的元素标签名称

	2/设置节点信息
		var oli=document.createElement("li");

	3/挂到DOM树上
		追加
		var oUl=document.getElementsByTagName("ul")[0];
		oUl.appendChild(oli);追加需要得到父元素
		插入
		//获取两个元素才能插入/父亲 弟弟
		var oUl=document.getElementsByTagName("ul")[0];
		var oli_gz=document.getElementById("gz");
		oUl.insertBefore(oli,oli_gz);

删除节点	父对象.removeChild(要删除的子对象)
	1/var oUl=document.getElementsByTagName("ul")[0];
	var oli_gz=document.getElementById("gz");
	oUl.removeChild(oli_gz);
	2/oli.parentNode.removeChild(oli);自己删除自己

<select onchange="chg();" id="province">
<option value="-1">请选择</option>
	当option填写value属性后，默认返回option的value值
		没有，select.value=选中option的内容

javascript事件处理
事件：指页面元素状态改变，用户在操作鼠标或者键盘时触发的动作
	鼠标事件
		onclick点击
		ondblclick双击 
		onmousedown鼠标某个键被按下
		onmouseup鼠标某个键被送开
		onmouseout鼠标离开元素
		onmouseover鼠标进入元素/悬停
		onmousemove鼠标移动
	键盘事件
		onkeyup键盘某个键被送开
		onkeydown键盘某个键被按下
	状态改变事件
	onload最后执行
	onblur失去焦点
	onfocus获得焦点
	onsubmit=提交事件
	onchange="chg()"数据发生变化

事件对象 event		重要
事件的绑定
	1/在html属性定义中直接处理事件
		<input type="button" onclick="fn()">
	2/js代码中动态定义：可以把html代码和js代码分离，好维护
		oBtn.onclick=function(){
		//这种绑定方式不加小括号，不然会直接运行
		oBtn.onclick=method;

事件的取消 onXXX="return false";
	function deleteData(){
		return confirm("终究");}

事件处理机制：事件冒泡
	<div onclick="alert('div')">
		<p onclick="alert('p')">
			<input type="button" value="事件冒泡" onclick="alert('button');">
		</p>
	</div>
	如果点击了button，将会依次触发input/p/div的onclick事件，这种现象叫做事件冒泡
	如果想事件冒泡，所有嵌套标签的事件，必须统一一样

取消事件冒泡
	由于浏览器内核不同，有两种方式取消事件冒泡
	moz代表火狐内核
	ms代表ie内核
	webkit代表谷歌/苹果内核

event.stopPropagation();
	以前只支持firefox/chrome
	现在高版本支持(ie8.0以下版本不支持)

event.cancelBubble=true;
	以前只支持IE
	现在在新版本的firefox/chrome都支持
	value="事件冒泡" onclick="alert('button');event.cancelBubble=true;"

事件冒泡在开发中的作用
	1/获取event对象
			任何事件触发之后都会自动生成一个event对象
			event对象记录事件发生时，鼠标的位置，键盘按键的状态
			和事件源的信息
		1/html代码中直接使用event	
			IE FF CHROME都通用	
			<input type="button" value="HTML_FOR_FF_chrome" 
			onclick="alert(event.clientX+':'+event.clientY);">
		2/js代码中使用event(考虑兼容性问题)
			/* ie-chrome直接在js代码中使用event对象 */
			function fn1(){
				//ff回报错event is not defined
				alert(event.clientX+":"+event.clientY);}
		3/FF下，在函数使用event对象必须使用传参的形式
			IE-CHROME-FF都支持
			<input type="button" value="JS_FOR_IE-CHROME-FF" 
			onclick="fn2(event);">	
			function fn2(event){
			alert(event.clientX+":"+event.clientY);}

通过event对象可以获取到事件源(兼容性问题)
	1/支持IE和chrome，chrome对ie进行了兼容
		<input type="button" value="事件源-IE-CHROME" 
		onclick="fn3(event);">
		function fn3(event){
		var obj=event.srcElement;}		
	2/FF/chrome，高版本IE也支持(低于ie8.0及以下版本不支持)
		<input type="button" value="事件源-FF-CHROME" 
		onclick="fn4(event);">
		function fn4(event){
		var obj=event.target;}
	3/如何解决通过event对象获取事件源的兼容问题
		开发中使用这种方式(js方式)
		var obj=event.srcElement||event.target;

this的使用
<input type="button" value="111" onclick="fn1(this);">
function fn1(btn){console.log(btn.value);}

批量的动态绑定事件
		window.onload=function(){
		var btns=document.getElementsByTagName("input");
		//批量动态绑定
		for(var i=0;i<btns.length;i++){
			btns[i].index=i;
			btns[i].onclick=function(){
				//consloe.log(btns[i].value);
				console.log(btns[this.index].value);
			}
		}
	}

jQuery框架
	是一个javaScript库，而且本身就是用js写的
	jq存在的目的就是极大的简化了javascript开发编程
	jq代码和js代码是混在一起开发的	

jq对象和Dom对象之间的相互转换
	$("p")-->[p,p,p,p]-->$("p")[index]
	$(dom)
jQuery选择器 	不能使用变量
	1/基本选择器

		元素选择器：$("标签名")
		类选择器：$(".class")
		id选择器：$("#id")
		选择器组：$("#id,.class")

	2/层次选择器

		$("select1 select2")子类选择器
		$("select1>select2")派生选择器
		$("select1+select2")符合条件的下一个弟弟
		$("select1~select2")符合条件的所有弟弟

	3/过滤选择器(过滤器)

		1/基本过滤器
			$("li:first")
			$("li:last")
			$("li:eq(index)")下标等于index的元素
			$("li:not(selector)")把符合selector排除在外，其他所有的li
			：even 挑选偶数行，按下标算
			：odd  挑选奇数行
			：gt(index) 下标大于index元素
			 : lt(index)	 下标小于index元素

		2/内容过滤器
			:contains(str)匹配包含指定文本的元素
			:empty	   匹配内容为空的元素
			
		3/可见性过滤器
			:visible	匹配所有可见的元素
			:hidden	匹配所有不可见元素，type为hidden的元素(包括隐藏域)	

		4/属性过滤器
			[attribute]	匹配具有attribute
				$("li[class]")
			[attribute=value]	匹配具有attribute等于某一个值的元素
				$("li[class=jms]")
			[attribute！=value]	匹配具有attribute不等于某一个值的元素

		5/状态过滤器
			:enabled	匹配可用元素
			:disabled	匹配不可用元素
			:checked	匹配选中的checkbox radio
			:selected	匹配选中的option

	4/表单选择器(专门针对表单)
		:text
		:password
		:radio
		:checkbox
		:submit
		:reset
		:button
		:file
		:hidden

readonly="readonly"只读
disabled="disabled"禁用
readonly和disabled
	disabled禁用。如果value有值，无法把value发送给服务器
	readonly只读。如果value有值，依然可以提交给服务器

jQuery操作DOM	直接获取方法是获取值	给方法填参数是给值
	1/读写节点的HTML内容
		obj.html(); obj.html("<p>123</p>");

	2/读写节点的文本内容
		obj.text(); obj.text("123");

	3/读取节点的值
		obj.val();	obj.val("123");

	4/读写节点属性 don.getAttribute
		obj.attr("属性名");	obj.attr("属性名","属性值");

高并发、高性能、高可用

jQ增删节点 js/createElement("input")

	1/增加新节点
		var obj=$("<span class="red">终究还是要走了么</span>");
		parent.append(obj);//添加为最后一个儿子
		parent.prepend(obj);//添加为第一个儿子
		brother.after(obj);//添加一个新弟弟(下一个兄弟)
		brother.before(obj);//添加一个哥哥(上一个兄弟)
		
	2/删除DOM节点	
		obj.remove();//删除自己
		obj.remove(selector);//把符合条件的删除
		obj.empty();//清空节点


样式操作
	addClass("");		追加样式
	removeClass("")	删除某个样式
	removeClass()		删除所有样式
	hasClass("")		判断是否有这个样式
	toggleClass("")		切换(有这个样式则取消没有则添加)
	css("")			读取某个样式的值
	css("","")			设置某个样式的值/css("background","red");

	window.onload=function(){}		js
	$(function(){})				jQurey

总结：jQuery方法的返回值
	1/通过$得到的是jq对象
		-选择器：$("p")得到的jq对象
		-转型：$(dom)把一个dom对象转化成jq对象
		-创建新对象：$("<p></p>") 得到的jq对象
	
	2/jq的修改方法，一般都返回jq对象
		-obj.html("abc");
		-obj.attr("src","3.png");
		-obj.addClass("big");
		-obj.removeClass("big");
		-这种一般都返回jq对象

	3/查询元素的方法，返回jq对象
		-obj.parent();父节点
		-obj.next();弟弟

	4/读取的方法，返回的不是jq对象
		-obj.html();
		-obj.value();
		-obj.css("color");
		-obj.attr("src");

	5/万能确认对象的方式
		-console.log(obj.val());-控制台输出，查看对象结构

根据节点关系查找节点
	obj.children()/obj.children(selector)
	next()/next(selector)下一个兄弟节点
	prev()/prev(selector)上一个兄弟节点
	nextAll()所有弟弟
	prevAll()所有哥哥
	parent()
	siblings()/siblings(selector)除了自己以外平级的所有
	find(selector)查找所有满足条件的后代

jQuery事件
	dom事件，操作繁琐，并且有严重的兼容性问题
	jq对dom事件做了封装，简化了操作，消除了兼容性问题

	1/动态定义绑定事件
		obj.click(function(){});
		完整语法:使用bind方法
		obj.bind("click",function(){});

	页面加载事件
		window.onload=function(){}		js
		如果在同一个html上有多个，后者会覆盖前者，只有最后一个生效
		$(function(){});				jq
		如果在同一个html上有多个，都有效

	时间对象-event
		jQ对使用事件对象做了封装，取消了兼容性问题通过函数传参，使用event

	事件处理机制-事件冒泡
		js取消事件冒泡，需要event对象
			event.stopPropagation()；
			event.cancelBubble=true;
		jq取消事件冒泡
			直接在不希望继续往外传递的那一层加上
				return false;就可以取消事件传递

	通过event对象获取事件源，jq
		js获取事件源
		var dom=event.srcElement||event.target;
		jQ获取事件源,直接解决了兼容问题
		event.target;
		获取的事件源是DOM对象，如果想让其操作jq方法
		需要转换成jq对象

	合成事件，是噱头，不是重点
		1/hover(fn1,fn2);
			相当于onmouseover和onmouseout结合
		2/toggle(time);隐藏和显示之间切换
			setInterval(function(){
			$("img").toggle(500);
			},3500);

opacity	样式：透明度
	模拟事件
		电脑模拟人的行为，做一些操作触发事件
		obj.trigger("事件类型")//obj是被模拟触发的标签
		事件类型是指被模拟触发的是什么事件
		比如：$("button").trigger("click")

基础动画
	在网页上有动效，提升用户体验
	1/显示和隐藏
		show()/hide()
		作用：通过同时改变元素的宽和高来实现显示和隐藏
		用法：obj.show(执行时间，回调函数)
		执行时间：毫秒值/slow/normal/fast
		回调函数：动画执行完毕之后，要执行的函数
		动画原理：底层使用定时器连续不断地修改样式
		启动定时器相当于启动子线程当前hide()相当于主线程
		两者并发执行
		
	2/上下滑动
		slideDown() slideUp();
		作用：通过改变高度来实现显示或者隐藏的效果
		用法同show()/hide()
	3/淡入淡出
		fadeIn()/ fadeOut()
		作用：通过改变透明度opacity来实现显示或者隐藏的效果
	4/自定义动画
		animate(偏移量，执行时间，回调函数)
		偏移量位置：{"left":"500px"}
		自定义动画基于相对/绝对/固定定位

数据库(DB) DataBase

	实际上就是一个文件集合(多个文件)
	就是存储文件的仓库，其本质就是一个文件系统
	数据库将按照特定的格式把数据存储到文件中，
	用户可以对数据进行增删改查操作

DBMS：DataBase Management System

	数据库管理系统-管理数据库文件的软件
	是一种操作和管理数据库的大型软件
	用于建立使用和维护数据库对数据库
	进行统一的管理和控制，用户是通过访问
	数据库管理软件取操作数据库内部的数据

数据库分类

	关系型数据库

		以表为单位，经过数学理论验证过

	非关系型数据库

		redis数据库就是这种，以键值对形式存储数据
		通常用于解决特定需求，如处理缓存，高并发

常见关系型数据库

	-mysql
		平台：windows	linux

	-Oracle(甲骨文)
		性能最高，价格最高

	-DB2
		IBM公司	Pracle对手
		平台：windows	linux

	-SQLServer
		微软	市场占有率第三	主要应用在
		.net(c#)所开发的网站上

	-Sqlite	几十K
			Oracle	几个G
		轻量级数据库，只具备基础增删改查
		功能上比大型数据库少
		应用在嵌入式或移动设备(ios/android)

SQL:Structured Query Language
	结构化查询语言
	用于客户端或java代码和数据库软件进行交互

数据库服务器
	服务器：一台高配置电脑
	数据库服务器：高配置电脑上安装数据库服务相关软件

打开mysql数据库第一件事就是使用某一个数据库

SQL语句规范
	1/以；结尾
	2/关键字之间有空格，至少一个	
	3/sql中可以出现换行，但是最后要；结尾
		如果添加换行建议先在文本工具中写好再复制到终端
	4/windows中完全不区分大小写，linux表名区分大小写
		数据库名也区分大小写

表
	-是关系型数据库中存放数据的单元

表字段
	-用来规定表中存什么数据，还有数据类型

java中的类(对象)	表
对象中的属性		表中字段

创建表的原理：
	-在客户端中写完创建表的sql语句，回车后
	客户端会将sql语句传递给DBMS(mysql)
	，DBMS解析后会在数据库文件中创建表格 

表的引擎
	InnoDB:支持数据库的高级操作包括：事务，外键等，默认是InnoDB
	Myisam:仅支持数据的基本操作

表的int类型有默认大小

使用Eclipse写sql

1. 下载mysql-connector-java-5.1.6.jar包 记住下载的位置
2. eclipse-》window-》show view-》data management->Data Source Explore 和 SQL Results显示出来
3. 在Data Source Explore窗口 connections上面右键New 然后选择Mysql下一步 然后选择下拉选旁边的加号然后选择 mysql5.1 ，然后选择jar list 然后点击clear all 然后add jar按钮，找到下载的jar包 然后ok
4. 在弹出的页面中 修改url中最后的database为自己电脑中存在的数据库名称，然后点击test connection如果提示ping success！ 点击finish
5. 在新建的New MySql上面右键 Open SQL Scrapbook
6. 新窗口中type选择 mysql5.1 后面name 和database里面选择唯一的内容即可 

登录

	mysql -uroot -p
		-u：用户名
		-p：密码

退出

	exit;

查看所有数据库

	show databases;

创建数据库

	create database 数据库名称

创建指定字符集数据库

	create database 数据库名称 character set utf8;

查看数据库详情

	show create database 数据库名称

删除数据库

	drop database 数据库名称;

使用数据库

	use 数据库名称;

创建表

	create table 表名(字段1名称 字段类型，字段2名称 字段类型，...)；
		create table person(name varchar(10),age int);

查看所有表

	show tables;

查看表的属性

	show create table person;

创建表时指定引擎和字符集
	
	create table student(id int,name varname(10))
	engine=myisam charset=gbk;

查看表字段

	desc emp;

对已创建表进行修改

修改表名

	rename table 原名to新名;

修改表的属性 改引擎和字符集

	alter table t_stu engine=innodb charset=utf8;
	
给表添加字段

	alter table 表名 add 字段名 类型;
	alter table t_stu add math int;

在最前面添加字段

	alter table 表名 add 字段名 类型 first;

在某个字段后面添加

	alter table 表名 add 字段名 类型 after 字段名;

删除字段

	alter table 表名 drop 字段名;

修改字段名和类型
      
	alter table 表名 change 原字段名 新字段名 类型;

修改字段类型和位置

	alter table 表名 modify 字段名 新类型 first;
	alter table 表名 modify 字段名 新类型 after 字段名;

删除表

	drop table t_stu;

数据相关的sql
	
插入 

	全表插入
		
		insert into 表名 values(值1，值2，值3，...)；	

	指定字段插入
	
		insert into 表名 (字段1名，字段2名) values(2,'小明');

	批量插入
		全表批量

			insert into student values
			(3,'刘备',30,30,30),
			(3,'关羽',40,25,30),
			(3,'张飞',80,84,99);
		
		指定字段批量

			insert into student (id,name) values
			(6,'悟空'),
			(7,'悟能'),
			(8,'悟静');

查询数据

查询所有数据 所有字段内容 *代表所有字段内容

	select * from student;

查询指定字段内容
	
	select id,name from student;

删除数据
	
	delete from student where id=1;

修改数据
	
	update student set math=100,english=30 
	where id=3;


删除字段值为null的 

	delete from emp where age is null;

表字段的约束

	1/主键约束

		添加了主键约束的字段一般都是整数类型的字段，此字段
		要求不能为null，并且要保证数值唯一
		作用：通常一张表中有且只有一个主键字段，用来表示
		每条数据的唯一性

		-使用：
			创建表时在表示唯一性的字段后面添加
			primary key

		create table pink(id int primary key,name varchar(10));		

		-自增：添加了自增约束的字段不需要手动赋值，会自动赋值
			数值会自动增长,通常和主键结合使用
			
			自增数值只增加不减少，
			可以手动赋值，手动插入后，取表中最大值继续加一
			使用delete删除全表数据 自增数值不清零

		create table pink(id int primary key auto_increment,name 				varchar(10));	
		
	2/非空约束
		-约束字段的值不能为null
		-使用
	
	create table t3(age int not null,name varchar(10));
		
表字段注释comment

	create table t4(id int comment '111',age int comment '111');

单引号和`的区别

	- ` :是用来修饰表名或者字段名
	- ' :是用来表时文本的(字符串)

数据的冗余

	-当表设计的不够合理时，随着数据的增多导致
		数据库表中出现大量的重复数据
	-在设计表时，把有可能出现大量重复的字段，
		放在一张新表中，在原表中只需要通过id
		引用可能重复的内容即可
		
事务
	-是数据库执行sql语句的最小单元，放在同一个事务中的sql语句
		要么同是成功，要么同是失败
	-数据库默认自动提交(commit)
	-如果使用事务需要关闭自动提交

	1/查看当前自动提交的状态

		show variables like '%autocommit%';

	2/关闭或打开自动提交 0关闭 1打开

		set autocommit=0

	-所谓开启事务实际就是关闭自动提交

	-开启事务后的sql语句 在提交前都会在内存中处理数据
		只有提交之后才会把内存中的改变一次性提交到
		数据库文件中

	-回滚 rollback
		当数据操作有误时，需要把数据回滚到某个状态点
		时需要使用rollback命令

	-保存回滚点 savepoint s1(标示)

	-回到回滚点 rollback to s1;

SQL分类

	1/	DDL 数据定义语言

		Data Definition Language:不支持事务
	常见sql：create/drop/alter/truncate:删除表并且创建一个新表

truncate和drop、delete的区别
	delete：删除表内数据，支持事务
	drop：删除数据库和表的操作，不支持事务
	truncate：删除表并且创建一个新的一样的表，等效(drop+create)
		不支持事务，自增字段清零

	2/	DML	数据操作语言
		Data Manipulation Language：支持事务
	常见sql：insert/update/dalete/select(DQL)

	3/	DQL 数据查询语言
		Data Query Language
	常见sql：select语句

	4/	TCL	事务控制语言
		Transaction Control Language
	常见sql：commit/rollback/savepoint

	5/	DCL	数据控制语言
		Data Control Language：用于处理用户权限的语言
	
数据库数据类型
	五大类型：整数/浮点数/字符串/日期/其他

int(m):m代表显示长度，当显示的长度小于m时会在数的前面补0
	如果向实现补0的效果必须结合 zerofill关键字
	create table t_int(age int(5) zerofill);

浮点数
	
double(m,d):m代表数据的总长度，d代表小数点后面的长度
	56.234	m=5,d=3	double(5.3);

decimal(m.d):当涉及高精度运算时需要使用decimal类型
	如：银行系统

字符串

char：固定长度		abc 占20个字符，执行效率高，最多255

varchar：可变长度	abc 占3个字符，节省存储空间，最多65535
	超过255建议text

text：文本类型，可变长度，长度65535

日期类型

date：只能存年月日	'2018-12-31'
time：只能存时分秒	'12:36:22'
datetime：年月日 时分秒 默认值是null，最大值：9999-12-31
timestamp：时间戳保存的是距1970年的秒数，年月日 时分秒
	默认值是当前时间，最大值是2038-01-19

if exists

	drop table if exists t;
	如果存在就删除t表，不存在也不会报错

判断不为空
	is not null

别名

	select ename 员工姓名 from emp;

去重	distinct
	select job from emp; 
	select distinct job from emp;

关系运算符

	=,<,>,<=,>=,!=,<>

逻辑运算符

	与：and和java中的&&一样 
	或：or 和java中的||一样 
	非：！ not 

in关键字

	当查询的某个字段值为多个的时候使用in
	-使用in写法
	select * from user where age in(20,25,30);

between x and y

	-查询某个字段的数值在两个数之间可以使用 between and
	select * from user where age between 20 and 30;

like 关键字

	-实现模糊查询
	- _:代表一个未知字符
	- %:代表多个未知字符
	-以a开头: a%
	-以a结尾: %a
	-包含a： %a%
	-第三个字符是a： __a%
	-倒数第二个是a:  %a_

排序 order by

	select price from t_item order by price;
	- 默认是升序 可以使用 asc（升） desc（降）控制升序和降序
	select price from t_item order by price desc;
	-如果有查询条件 需要把order by写在条件的后面。
	例如：select price from t_item where price<500
	     order by price desc;
	-多字段排序：先安装第一个字段进行排序 
	如果第一个字段有重复数据则按照第二个字段再进行排序

limit

	-使用limit 实现分页功能
	- limit begin,size
	-举例：查询前十条
	select * from t_item limit 0,10;
	-举例：查询第3页 每页10条
	select * from t_imte limit 20,10;
	-查询第4页 每页8条  being= （页数-1）*size
	select * from t_imte limit 24,8;

concat()函数 拼接字符串

	-mysql的helloworld 
	    select 'helloworld';
	-concat('a','b','c') 最终得到abc
	    select concat('a','b','c');


数值计算
	+ - * /  7%2 等效 mod(7,2)

日期相关函数

	- now():获取当前日期+时间
	- curdate():获取当前日期
	- curtime():获取当前时间
	    select now(),curdate(),curtime();
	- date(now()):提取日期
	- time(now()):提取时间
	    select date(now()), time(now());
	- extract()从某个时间中提取 年,月，日，时，分，秒
	    举例： 
	    select extract(year from now());
	    select extract(month from now());
	    select extract(day from now());
	    select extract(hour from now());
	    select extract(minute from now());
	    select extract(second from now());
	- date_format(时间,格式)
	    select date_format(now(),'%Y年%m月%d日 %H时%i分%s秒');
	- %Y 4位年
	- %y 2位年
	- %m 月  05
	- %c 月 5
	- %d 日
	- %H 24小时
	- %h 12小时
	- %i 分
	- %s 秒
	-案例：查询商品名称和上传日期（格式年月日）
	select title,date_format(created_time,'%Y年%m月%d日') from t_item;

	-str_to_date(日期文本,格式)  
	-作用： 把任意日期文本转成date标准格式
	 11号10月2008年 ---->  2008-10-11
	select str_to_date('11号10月2008年','%d号%m月%Y年');
	-案例：把14.08.2008 08:00:00转成date标准格式
	    select str_to_date('14.08.2008 08:00:00','%d.%m.%Y %H:%i:%s');

ifnull(x,y)函数

	- age=ifnull(x,y) 如果x值不等于null 则age=x,如果x值等于null则age=y;
	举例：设置员工表中奖金为null值设置成0
	update emp set comm=0 where comm is null
	-下面代码等效上面的代码
	update emp set comm=ifnull(comm,0);

聚合函数

	-用于数据统计
	-求和：sum(字段)
	    select sum(num) from t_item;
	-平均值：avg(字段)
	    select avg(sal) from emp;
	-最大值：max(字段)
	    select max(sal) from emp;
	-最小值：
	    select min(sal) from emp;
	-统计数量：count(*) 
	    select count(*) from emp where sal<1000;

字符串相关函数

charlength(str):获取字符串的长度 

	select charlength('abc'); 
	select char_length(ename),ename from emp;

instr(str,substr):获取subStr在str中出现的位置,从1开始 

	select instr('abcde','d');

locate(substr,str):获取subStr在str中出现的位置,从1开始 

	select locate('d','abcde');

lower(str)和upper(str) 转小写和转大写
 
	select lower('NBa'); 
	select upper('Nba');

left(str,count)和right(str,count)从左/右边截取多少个 

	select left('abcdefg',2); 
	select right('abcdefg',2);

trim(str)去除两端的空格 

	select trim(' abc ');

substring(str,index,length)截取字符串 

	select substring('abcdefg',3,2);

repeat(str,count) 重复 

	select repeat('abc',2);

replace(str,old,new)替换 

	select replace('This is mysql','my','your');

reverse()反转 

	select reverse('abcd');

数学相关函数

	floor(num) 向下取整 select floor(3.14);
	round(num)四舍五入 select round(23.8);
	round(num,m) m代表小数点后几位 select round(3.1415926,4);
	truncate(num,m)m代表小数点后几位 不四舍五入 select truncate(3.1415926,4);
	rand()获取0-1随机数 select rand(); -案例获取 0-10 select floor(rand()*10);

create table if not exists t(...);
	如果不存在创建

分组
	-通常分组和聚合函数结合使用
	-查询每个部门/性别/分类，就以部门/性别/分类作为
	分组的条件
	-使用 group by 关键字进行分组, by 后面写分组条件
	-如何使用：
		select deptno,max(sal) from emp group by deptno;
	用什么分组显示什么

	-在一次查询中可以进行多次分组
		select deptno,mgr,count() from emp 
		where mgr is not null group by deptno,mgr; 

不能再where后面写聚合函数的筛选条件,
只能写普通字段的筛选条件

格式:
	select * from 表名 
	where 普通字段条件 
	group by 分组字段名 
	having 聚合函数的条件 
	order by 排序字段 
	limit begin,size;

where要写在group by 前面
having要写在group by 后面

分组统计带条件的话 使用having
	在having中可以写普通字段的条件，但不建议这样写，
	普通字段条件写在where后面

查询emp表中名字不是以k开头的每个部门的最低工资高于1000的部门编号，工资总和，最低工资，平均工资，最后根据平均工资降序排序
select deptno,sum(sal),min(sal) m,avg(sal) a 
from emp 
where ename not like 'k%' 
group by deptno 
having m>1000 
order by a desc;

查询emp表中部门编号是 10，30的员工，每个职业的最高工资低于5000的职业名称，人数，平均工资，最高工资 最后根据人数进行升序排序 ，如果人数一致则根据最高工资降序排序。
select job,count(*) c,avg(sal),max(sal) m 
from emp 
where deptno in(10,30) 
group by job 
having m<5000 
order by c,m desc;

查询emp表，工资在1000-3000的员工信息，每个部门的编号，工资总和，平均工资，过滤掉平均工资低于2000的部门，按照平均工资升序排序，如果一致的则以工资总和降序排序。
select deptno,sum(sal) s,avg(sal) a
from emp 
where sal between 1000 and 3000 
group by deptno 
having a>=2000 
order by a,s desc;

查询emp表不是以s开头 每个职位的名字，人数，最高工资，过滤掉平均工资是3000的职位，最后根据人数降序排序，如果人数一致则根据最高工资降序排序。
select job,count(*) c,max(sal) m,avg(sal) a 
from emp 
where job not like 's%' 
group by job 
having a!=3000 
order by c desc,m desc;

子查询
	-嵌套在sql语句里面的查询sql语句，称为子查询

拿最低工资的员工信息	
select * from emp where sal=(select min(sal) from emp);

工资高于平均工资的员工信息
select * from emp where sal>(select avg(sal) from emp);

最后入职的员工信息
select * from emp where hiredate=(select max(hiredate) from emp);

查询工资高于20号部门最高工资的员工信息 
select max(sal) from emp where deptno=20;
select * from emp where sal>(select max(sal) from emp where deptno=20);

查询emp表中名字是king的这个人的部门编号和部门名称
select deptno from emp where ename='king';
select * from dept where deptno=(select deptno from emp where ename='king');

查询部门名称是sales的所有员工信息
select deptno from dept where dname='sales';
select * from emp where deptno=(select deptno from dept where dname='sales');

查询和jones同样工作的员工信息包含jones
select job from emp where ename='jones';
select * from emp where job=(select job from emp where ename='jones');

不包含jones 
select * from emp where job=(select job from emp where ename='jones') and ename!='jones';

查询部门平均工资最高的部门信息
方案1
select deptno from emp group by deptno order by avg(sal) desc limit 1;
select * from dept where deptno=(select deptno from emp group by deptno order by avg(sal) desc limit 1);
方案2
select deptno from (select deptno,avg(sal) a from emp group by deptno order by a desc limit 0,1) n;
select * from dept where deptno=(select deptno from (select deptno,avg(sal) a from emp group by deptno order by a desc limit 0,1) n);
order by后可以使用聚合函数
子查询可以当作一张新表跟在from后面，但必须加别名

select category_id from t_item group by category_id order by sum(num) limit 1;
select * from t_item_category where id=(select category_id from t_item group by category_id order by sum(num) limit 1);

子查询可以写在哪里
	-where 后面 当查询条件
	-from 后面当成新表，必须加别名
	-可以写在创建表时 as
	create table item as(select title,price from t_item 
	where price<100);

关联查询

 查询每个员工的名字和所在部门的名字
	select emp.ename,dept.dname 
	from emp,dept 
	where emp.deptno=dept.deptno;

查询每个商品的名称和对应的分类的名称
select i.title,c.name 
from t_item i,t_item_category c 
where i.category_id=c.id;

查询两张表数据 如果不写关联关系 结果会出现两张表数据
的乘积 这种乘积称为：笛卡尔积
笛卡尔积通常情况下时一种错误的查询结果，在工作中切忌不要出现

查询在new york工作的所有员工信息
select e.*,d.loc
from emp e,dept d
where e.deptno=d.deptno and d.loc='new york';

等值链接和内联接
	-等值链接：
		select * from A,B where A.x=B.x and age>18;
	-内联接：明确的把关联关系和条件分开 join on
		select * from A join B on A.x=B.x where age>18;
	-自连接：用别名区别开
	-多连接：要有多对关联条件，用 and 连接

查询在new york工作的所有员工信息
select e.*,d.loc 
from emp e join dept d on e.deptno=d.deptno 
where d.loc='new york';

外连接	left join
	1/左外连接：以join左边的表为主表，查询所有，
		右边查询有关联关系的数据
	2/右外连接：以join右边的表为主表，查询所有，
		左边查询有关联关系的数据

查询所有员工的名字和其对应的部门名
select e.ename,d.dname 
from emp e left join dept d on e.deptno=d.deptno;

查询出所有商品的名字和对应的分类名
select i.title,c.name 
from t_item i left join t_item_category c 
on i.category_id=c.id ;

查询拿最低工资的员工姓名,工资和他的部门名称
1
select min(sal) from emp;
select e.ename,e.sal,d.dname 
from emp e join dept d on e.deptno=d.deptno 
where e.sal=(select max(sal) from emp);
2
select e.ename,e.sal,d.dname 
from emp e join dept d on e.deptno=d.deptno 
having e.sal=max(sal);//必须要结合分组使用，不能单独使用

select deptno,count(*) c from emp 
where deptno is not null 
group by deptno order by c;

select mgr,count(*) from emp 
where mgr is not null and deptno is not null 
group by deptno,mgr;

select job,avg(sal) from emp where job is not null group by job;

select count(*),extract(year from hiredate) year from emp group by year;
少于等于3个人的部门
select deptno from emp group by deptno having count(*)<=3;
select dname from dept where deptno in(select deptno from emp group by deptno having count(*)<=3);

拿最低工资的员工信息
select min(sal) m from emp order by m limit 1;
select * from emp where sal=(select min(sal) m from emp order by m limit 1);
只有一个下属的主管信息
1
select mgr from emp where mgr is not null group by mgr having count(*)=1;
select * from emp where empno in(select mgr from emp where mgr is not null group by mgr having count(*)=1);
2
select e.* 
from emp e join (select mgr,coutn(*) c 
from emp 
group by mgr 
having count(*)=1);
平均工资最高的部门编号
select deptno from emp group by deptno order by avg(sal) desc limit 1;
考虑平均工资最高的会有多个部门
-得到最高的平均工资
select avg(sal) a from emp group by deptno order by a desc limit 0,1;
-通过最大平均工资查询对应部门编号
select deptno from emp 
group by deptno 
having avg(sal)=(select avg(sal) a from emp group by deptno order by a desc limit 0,1);
-如果查看部门详情
select * from emp where deptno in(select deptno from emp 
group by deptno 
having avg(sal)=(select avg(sal) a from emp group by deptno order by a desc limit 0,1););
下属人数最多的人，查询其个人信息
select mgr from emp group by mgr order by count(*) desc limit 1;
select * from emp where empno=(select mgr from emp group by mgr order by count(*) desc limit 1);
最后入职的员工信息
select * from emp order by hiredate desc limit 1;
select * from emp where hiredate=(select max(hiredate) from emp);
工资多于平均工资的员工信息
select avg(sal) from emp;
select * from emp where sal>(select avg(sal) from emp);
查询员工信息，部门名称,所在城市
select e.*,d.dname,d.loc 
from emp e join dept d on e.deptno=d.deptno;
DALLAS 市所有的员工信息
select e.* 
from emp e join dept d on e.deptno=d.deptno 
where d.loc='dallas';
按城市分组，计算每个城市的员工数量
select d.loc,count(*),e.ename 
from emp e join dept d on e.deptno=d.deptno 
group by d.loc;
查询员工信息和他的主管姓名
select a.*,b.ename 
from emp a join emp b on a.mgr=b.empno;
员工信息，员工主管名字，部门名
1
select a.*,b.ename,d.dname
from emp a,emp b,dept d 
where a.mgr=b.empno and a.deptno=d.deptno;
2
select e.ename,m.ename 主管,d.dname 
from emp e join emp m 
on e.mgr=m.empno 
join dept d on d.deptno=e.deptno;
员工和他所在部门名
select e.ename,d.dname
from emp e join dept d on e.deptno=d.deptno;
案例：查询emp表中所有员工的编号，姓名，职位，工资以及该员工上级领导的编号，姓名，职位，工资
select * from emp a left join emp b on a.mgr=b.empno;
案例：查询emp表中名字中没有字母'K'的所有员工的编号，姓名，职位以及所在部门的编号，名称，地址
select e.empno,e.ename ,e.job,d.* 
from emp e left join dept d 
on e.deptno=d.deptno 
where e.ename not like '%k%';
案例：查询dept表中所有的部门的所有的信息，以及与之关联的emp表中员工的编号，姓名，职位，工资
select e.*,e.empno,e.ename,e.job,e.sal 
from dept d left join emp e 
on d.deptno=e.deptno ;

表设计之关联关系：两张表之间
	一对一：
		-在A表中有一条数据和B表中的一条数据有关联关系

		-应用场景：
			用户表和用户信息扩展表
			商品表和商品信息扩展表

		-如何建立联系，两张表从表需要添加一个字段记录主表的主键值，此字段称之为外键

创建user(id,username,password)和userinfo(id,nick,qq,phone)表,
然后分别往两张表中插入有关联关系的3条数据
查询所有用户的用户名和昵称、电话
select u.username,ui.nick 
from user u join userinfo ui on u.id=ui.id;

查询叫大姑娘的用户的所有信息
select * 
from user u join userinfo ui on u.id=ui.id 
where u.username='大姑娘';

	一对多：
		-AB两张表中A表中的一条数据可以对应B表中的一条
		或多条数据

		-应用场景：商品和分类
				员工和部门

		-如何建立联系：在多的一端的表中需要有一个字段记录另外一张表中数据的主键

	多对多：
		-在AB两张表中A表中的一条数据对应B表中的多条，同时B表中的一条数据对应A表中的多条数据

		-应用场景：学生和老师
				用户和角色

		-如何建立联系：多对多必须创建关系表，在关系表中保存两张表的主键

创建老师表（id,name）和学生表(id,name)， 创建关系表 ts(tid,sid) 
往老师表中插入数据唐僧，刘备，苍老师
学生表中插入悟空，关羽，小猪佩奇
悟空的老师是唐僧和苍老师 
小猪佩奇的老师是苍老师和刘备 
关羽的老师是刘备和苍老师

查询苍老师的所有学生信息
1
select s.name 
from teacher t,t_s,student s 
where t.id=t_s.tid and s.id=t_s.sid and t.name='苍老师';
2
select t.name,s.name 
from teacher t join t_s 
on t.id=t_s.tid 
join student s 
on s.id=t_s.sid 
where t.name='苍老师';

查询小猪佩奇的所有老师
1
select t.name 
from teacher t,t_s,student s 
where t.id=t_s.tid and s.id=t_s.sid and s.name='小猪佩奇';
2
select name from teacher 
where id in(select tid from ts 
where sid=(select id from student 
where name='小猪佩奇'));

查询每个老师对应的所有学生
1
select t.name,s.name 
from teacher t,t_s,student s 
where t.id=t_s.tid and s.id=t_s.sid;
2
select t.name,s.name 
from teacher t join t_s 
on t.id=t_s.tid 
join student s 
on s.id=t_s.sid;

自关联
	-在一张表中有某一个字段指向当前表的主键
	-何时使用：当数据和数据之间存在层级关系而且不确定有多少层时使用
	如：员工表的上级领导，分类的上级分类，部门的直属部门

连接方式和关联关系的区别
	连接方式：内连接和外连接(左外，右外)，是指sql语句查询两张表数据时时用的查询方式
	关联关系：一对一，一对多，多对多，是指两张表之间存在逻辑关系

案例：权限管理的表设计

	-需要创建5张表
		user(id,name) 
		角色role(id,name) 
		module(id,name)(权限 模块) 
		u_r关系表(uid,rid) 
		r_m关系表(rid,mid)

	-插入数据 
			用户表 刘德华，王菲
			角色表 男性游客 女vip
			权限表 男浏览 男发帖 女浏览 女发帖 女删帖

 	-建立关系 
		用户和角色：
			刘德华》男游客 
			王菲》男游客和女vip
		角色和权限：
			男游客》男浏览
			女vip》女浏览-女发帖
		

create table user(id int,name varchar(10));
create table role(id int,name varchar(10));
create table module(id int,name varchar(10));
create table u_r(uid int,rid int);
create table r_m(rid int,mid int);

insert into user values(1,'刘德华'),(2,'王菲');
insert into role values(1,'男游客'),(2,'女vip');
insert into module values(1,'男浏览'),(2,'男发帖'),(3,'女浏览'),(4,'女发帖'),(5,'女删帖');
insert into u_r values(1,1),(2,1),(2,2);
insert into r_m values(1,1),(2,3),(2,4);

select u.name,m.name 
from user u join u_r ur 
on u.id=ur.uid 
join r_m rm 
on ur.rid=rm.rid 
join module m 
on rm.mid=m.id;

	person
id name sex relation
	trade
tradeid tradetime tradeamount send methodid receive 
	method
id name

select
from trade
where trade between and


boss收了很多红包，有亲戚，朋友，同事，用现金，支付宝，微信法的红包
同时boss也发了很多红包，设计表格
	person
id name sex relation
	trade
tradeid tradetime tradeamount sendid methodid receiveid 
	method
id name

创建表
create table person(id int,name varchar(10),sex varchar(10),relation varchar(10));
create table trade(tradeid int,tradetime date,tradeamount int,sendid int,methodid int,receiveid int);
create table method(id int,name varchar(10));
插入数据
insert into person values(1,'boss','null','本人'),(2,'大姑娘','女','亲戚'),(3,'二姑娘','女','亲戚'),(4,'三姑娘','女','同事'),(5,'四大哥','男','亲戚');

insert into trade values(1,'2017-2-20',100,2,1,1),(2,'2018-2-20',200,3,2,1),(3,'2018-2-20',200,4,3,1),(4,'2018-2-20',300,2,2,1),(5,'2018-2-20',400,1,3,2);

insert into method values(1,'现金'),(2,'微信'),(3,'支付宝');
第二题从2018-2-15到现在的收益(收入-支出)
select sum(tradeamount)
from trade t join person p on p.id=t.receiveid
where t.tradetime between '2018-2-15' and curdate()
and p.name='boss';

select sum(tradeamount)
from trade t join person p on p.id=t.sendid
where t.tradetime between '2018-2-15' and curdate()
and p.name='boss';

方法一
select (sum(tradeamount)-(select sum(tradeamount)
from trade t join person p on p.id=t.sendid
where t.tradetime between '2018-2-15' and curdate()
and p.name='boss')) t
from trade t join person p on p.id=t.receiveid
where t.tradetime between '2018-2-15' and curdate()
and p.name='boss';

方法二


第三题从2018-2-15到现在红包金额>100所有女性亲戚的名字和红包金额
select p.name,t.tradeamount
from trade t join person p on p.id=t.sendid
where t.tradetime between '2018-2-15' and curdate()
and t.tradeamount>100 and p.sex='女' and relation='亲戚';

第四题统计现金，支付宝，微信分别数到红包的总金额
select sum(t.tradeamount)
from trade t join method m on t.methodid=m.id
join person p on p.id=t.receiveid
where m.name='现金' and p.name='boss';

select sum(t.tradeamount)
from trade t join method m on t.methodid=m.id
join person p on p.id=t.receiveid
where m.name='支付宝' and p.name='boss';

select sum(t.tradeamount)
from trade t join method m on t.methodid=m.id
join person p on p.id=t.receiveid
where m.name='微信' and p.name='boss';

老师版
create table trade(id int primary key auto_increment,time timestamp,money double,pid int,type varchar(5));
create table person(id int primary key auto_increment,name varchar(10),sex varchar(5),rel varchar(10));
insert into person values(null,'刘德华','男','亲戚'),(null,'刘若英','女','亲戚'),(null,'马云','男','同事'),(null,'奥巴马','男','朋友'),(null,'武则天','女','同事');
insert into trade values
(null,'2018-02-18',200,1,'微信'),
(null,'2018-02-16',200,1,'微信'),
(null,'2018-03-18',1000,2,'支付宝'),
(null,'2018-03-18',-50,2,'支付宝'),
(null,'2018-02-19',20000,3,'现金'),
(null,'2018-03-21',200,4,'现金'),
(null,'2018-03-15',-10000,5,'现金');

从2018年2月15号到现在的收益(收入-支出)
select sum(money) from trade 
where time>str_to_date('2018年2月15号','%Y年%m月%d号');

从2018年2月15号到现在所有女性亲戚的名字和红包金额
insert into trade values
(null,'2018-02-18',200,2,'微信'),
(null,'2018-02-16',50,2,'微信');

select p.name,t.money 
from trade t join person p 
on t.pid=p.id 
where t.time>str_to_date('2018年2月15号','%Y年%m月%d号') 
and t.money>100 and p.sex='女' and p.rel='亲戚';

统计现金，支付宝，微信分别数到红包的总金额
select type,sum(money) from trade 
where money>0 
group by type;

视图
	什么是视图
	-在数据库中存在多种对象，表和视图都是数据库中的对象，创建视图时，
	名称不能和表重名(级别相同)，视图实际上就代表了一段sql查询语句也可以理解为
	视图是一张虚拟的表，此虚拟表中的数据会随着原表的改变而改变
	
	创建视图：
		-格式：
		create view 视图名 as 自查询
		create view v_emp_10 as (select * from emp where deptno=10);	
		select * from v_emp_10;
		
	视图的意义
	-因为有数据查询需要写大量sql语句，每次书写非常麻烦，
	使用视图可以起到重用sql的作用,还可以隐藏敏感信息

创建隐藏工资的emp表视图
create view v_emp_nosal as (select empno,job,comm 
from emp);	
select * from v_emp_nosal;

create view v_item_1 as(
select t.title,t.price,t.num 
from t_item t
where price<100);
select * from v_item_1;

创建emp表部门工资总和,平均工资,最大工资,最小工资的视图
create view v_emp_math as(
select sum(sal),avg(sal),max(sal),min(sal) 
from emp);
select * from v_emp_math;

删除视图
drop view 视图名

视图的分类
	-简单视图：创建视图的时候不包含：去重，函数，聚合，分组，关联查询
		可以对数据进行增删改操作
	-复杂视图：包含：去重，函数，聚合，分组，关联查询
		不可以对数据进行增删改操作，只提供数据查看功能

简单视图的增删改操作
	-查看全部视图	show tables;
	-插入数据
		insert  into v_emp_10 (empno,ename,deptno) values(123123,'乌拉拉',10);
		insert  into v_emp_10 (empno,ename,deptno) values(123234,'傻白甜',20);

	-数据污染
		在视图中插入一条在视图中不显示(不符合条件)但是在原表中显示的数据，通常工作中
		不允许出现，可以通过以下关键字避免数据污染

		with check option

		此时如果插入不符合条件的数据会报错
		create view v_emp_30 as (select * from emp where deptno=30) with check option;
		insert  into v_emp_30 (empno,ename,deptno) values(123567,'林家小妹',30);

	-修改数据
		update v_emp_10 set ename='大长腿' where empno=123123;
		只能修改视图中存在数据
		update v_emp_10 set sal=500 where deptno=20;

	-删除数据
		delete from v_emp_10 where empno=123123;
		只能删除视图中存在数据
		delete from v_emp_10 where deptno=20;

	-修改视图
		create or replace view v_emp_10 as (
		select * from emp where deptno=10 and mgr is not null);

	-删除视图
		drop view if exists v_emp_10;如果存在则删除

如果创建视图时字段名起了别名，那么之后对视图的操作必须使用别名

视图总结
	视图和表都是数据库中的对象
	视图代表了一段sql，可以理解为一张虚拟表
	可以起到复用sql，隐藏敏感数据的作用，
	分为简单(可以对数据进行增删改操作)，复杂(包含：去重，函数，聚合，分组，关联查询)
	工作中更多的是用来方便查询，很少有需求通过
	视图修改数据

创建每个员工名称和部门名称的视图

create view v_emp_dept as (
select e.ename,d.dname
from emp e join dept d
on e.deptno=d.deptno
);

修改上面视图值显示工资低于3000
create or replace view v_emp_dept as (
select e.ename,e.sal,d.dname 
from emp e join dept d 
on e.deptno=d.deptno 
where e.sal<3000);

索引
	是数据库中提高查询速度的技术，类似于一个目录，查询数据会先在目录中对数据进行定位
	，然后再找到某个位置的数据
	-意义
	因为数据库中的数据最终保存在磁盘的磁盘块中(4kb)，如果保存的数据量大
	则数据会无序分布在大量的磁盘块中，如果想查询数据会依次遍历每一个磁盘块
	这种查询方式效率非常低，如果使用了索引，会在数据库中保存一个树状目录，查询数据时会
	先通过树状目录去查询这样的话大大的降低了磁盘块的访问量

索引分类
	1/聚集索引(聚簇索引)：类似于字典中的拼音目录，磁盘块会按照索引的顺序依次在磁盘中保存
		在磁盘块中保存着数据本身，在mysql中自动为主键添加聚集索引
	2/非聚集索引：在磁盘块中没有数据只有和数据对应的地址

如何创建索引
	格式：
		create index 索引名 on 表名(字段名(长度));
		create index index_title on item2(title);
		select * from item2 where title='100';

查看表的索引
	show index from 表名；
	show index from item2;

删除索引
	drop index 索引名 on 表名;
	drop index index_title on item2;

索引是越多越好么
	不是，索引会占磁盘的储存空间，不常用的字段不建议创建索引

有索引一定好么
	数据量如果很小，创建索引有可能会降低效率

复合索引
	创建索引的时候，指定多个字段
	格式：
		create index 索引名 on 表名(字段1，字段2);
	应用：
		当查询数据时经常使用多个字段同时作为查询条件使用复合索引

索引总结
	-索引是数据库中提高查询效率的技术，它会占用磁盘空间，不是越多越好，
		数据量小的表不建议创建索引，
	-频繁修改的表不建议添加索引,索引会频繁自动更新，对于经常出现在where/order by/dostinct
		中的字段添加索引效果更好
	-聚集索引最多只能有一个，给表添加主键时自动创建，非聚集索引

mysql的约束
	就是对表字段的数据进行限制的规则

唯一约束：unique
	添加约束后的字段，不能插入重复数据
	create table t_uni(id int unique);
	insert into t_uni values(18);
	插入重复数据会报错

非空约束：not null
	添加非空约束的字段值不能为null
	create table t_notnull(id int not null);
	insert into t_notnull values(null);
	插入null值时会报错

主键约束
	创建表时添加主键约束
	create table t(id int primary key auto_increment);
	创建表后添加主键
	alter table 表名 add primary key(字段名)

create table bb(id int);
alter table bb add primary key(id);

删除主键
	alter table bb drop primary key;

自增约束 auto_increment
	当赋值为null时，字段的值会自动增长，
		删除数据主键值不会减少
	如果插入数据指定了一个比较大的数值，
		下次插入会在表中最大值的基础上+1
	使用delete删除全表数据，数值不会清零
	使用truncate数值会从头开始

外键约束 foreign key
	-是保证两个表之间数据的一致性和完整性的约束
	
	-如果添加了外键约束，
		删除数据是不能删除被关联的数据，
		插入数据时外键值可以为null，但是如果赋值
			值必须是在关系表中出现的值，如果没有此值
			则会报错
	-外键值可以null，可以重复，不可以是不存在的值
	-工作中如果没有特殊情况，通常不使用外键约束，避免测试数据麻烦
	-外键约束是通过代码逻辑实现
	-外键的值通常为另一张表的主键值
	-外键数据类型要和关系表主键的数据类型一致
-使用外键约束的条件
	1/保证两张表都是相同的引擎，
	2/myisam不支持外键，只能使用innodb引擎

如何使用外键约束
	格式：
	create table emp(empno int,deptno int, 
	constraint 约束名 foreign key(deptno) 
	references 关联表名(关联表字段名));

创建员工表
create table t_emp(id int primary key auto_increment,name varchar(10),
deptid int,constraint fk_dept foreign key(deptid)
references t_dept (id));
创建部门表
create table t_dept(id int primary key auto_increment,name varchar(10));

insert into t_dept values(null,'神仙部');
insert into t_dept values(null,'妖怪部');
insert into t_emp values(null,'观音',1),(null,'黑熊怪',2);
插入不存在
insert into t_emp values(null,'周星星',3);
删除被关联
delete from t_dept where id=1;
删除被关联的表
drop table t_dept;

外键总结
	保证两个表之间数据的一致性完整性
	工作中使用逻辑外键，因为测试麻烦
	可以为null，可以重复，不能为不存在的值
	要求两张表必须是innoDB引擎
	外键类型要和关系表主键类型一致

默认约束
	给字段添加默认值
	create table t_def(id int,age int default 0);
	insert into t_def (id) values(1);
	如果不给字段赋值，此字段的值为默认值

check约束 在mysql中不生效但是也不报错
	给字段添加条件，但是在mysql中不生效但是也不报错
	create table t_check(id int,age int,check(age>20));

事务
	执行sql语句的最小工作单元，写在事务里的sql要么
	同时成功，要么同时失败

事务ACID四大特性 	面试重点
	Automicity:原子性，最小，不能拆分
	Cconsistency:一致性，同时成功或失败
	Isolation:隔离性，多事务之间互不影响
	Durability:持久性，事务执行完后，数据保存到数据库文件中持久生效
	

事务相关sql
	查看自动提交状态：
		show variables like '%autocommit%'
	设置自动提交
		set autocommit=0/1;
	手动提交
		commit;
	回滚
		rollback;
	保存回滚点
		savepoint s1;
	回滚到某个保存点
		rollback to s1;


视图
	数据库中的对象，代表一段sql，虚拟表，视图中数据跟随原表改变
	复用sql，隐藏敏感信息
	
创建和替换
	
	create or replace view 视图名 as (子查询)

简单，复杂视图


数据污染
	with check option
	drop view 视图名

索引
	数据库中提高查询效率的技术，可以理解为目录

聚集索引：叶子中包含数据
	表中添加主键自动创建聚集索引

非聚集索引：叶子中没有数据，有数据磁盘块的地址
	
	数据量大的时候添加索引
	索引会占存储空间
	出现在where/order by/distinct后面的字段创建索引
	
	create index 索引名 on 表名(字段名(长度))

复合索引：创建索引时添加多个字段

查看索引
	show index from 表名
 
删除索引
	drop index 索引名 on 表名

约束

唯一约束：unique

非空：not null

主键：唯一并非空 primary key

自增：auto_increment

外键：保证两个表数据的一致性和完整性

默认：default
	
check：

事务

原子性：最小，不可分割
一致性：同时成功或失败
隔离性：多个事务之间互不影响
持久性：
		
JDBC	只是一堆接口，没有具体实现
	java Datebase Connectivity
	java 数据库 连接
	
	提供了一套和数据库交互的API(application program interface)
	
	意义
		因为java语言在工作中，有可能会有需求去访问各种数据库
		为了避免java程序员每一种数据库都学习一套相关的api
		为了解决这个问题，Sun公司提供了一套JDBC接口，在接口中
		对数据库各种操作的方法的声明，让各个数据库的厂商去写
		方法的实现类(驱动)，这样java程序员只需要掌握JDBC方法的
		调用，就能够完成对各种数据库的操作

如何使用JDBC

//1.注册驱动 
	Class.forName("com.mysql.jdbc.Driver"); 
//2.获取数据库连接对象 
	Connection conn = DriverManager.getConnection( 
	"jdbc:mysql://localhost:3306/db3", "root", "root"); 
//3.获取执行sql语句的对象 
	Statement stat = conn.createStatement(); 
//4. 执行sql语句 DDL 返回值表示是否有结果集 
//返回值true表示有结果集 false 没有 
	boolean b = stat.execute("create table if not exists" + " t_jdbc1(id int)");
//有结果集 处理结果集
//关闭

执行sql语句

执行DDL：stat.execute(sql)
执行DML: stat.executeUpdate(sql);
执行DQL：stat.executeQuery(sql); 
DQL写法：执行查询sql ResultSet rs = stat.executeQuery("select * from jdbcuser"); 
遍历结果集 while(rs.next()){ 
		String name = rs.getString("name"); 
		int age = rs.getInt("age"); 

-数据库字段类型和java类型的对应关系

	Mysql		java

	int		getInt
	float		getFloat
	double		getDouble
	varchar		getString
	datetime	getDate
	timestamp	getDate

从ResultSet中获取数据有两种方式：

通过表字段名获取数据 
	String name = rs.getString("name");

通过表字段的位置获取数据 位置从1开始 
	String name = rs.getString(2);

Junit测试
	-在一个无参无返回值的方法上面添加@Test注解
	-在方法名上右键->run as ->JUnit Test 即可运行
	此方法
	-这种好处是可以在一个类中由多个可执行的方法，而
	main只能有一个


自定义模板代码
	Eclipse中选择Window->Preferences->Java->Editor->
	Tamplates->New
	name:模板代码的名字
	Discription:模板描述
	partten:模板代码
	Insert Variable 按钮里面选择Cursor 代表光标的位置


stat.ExecuteUpdate()方法返回值是一个整数，代表此行sql生效的行数
stat.Execute()方法返回值是一个结果集的boolean值
stat.ExecuteQuery()方法返回值是一个结果集

Properties

	属性对象，用于读取*.properties属性配置文件中的数据
	
*.properties属性配置文件
	中的数据类型为String类型
	汉字会自动转为16进制
	

意义：
	之前写法是把数据库连接信息硬编码的形式写死在.java类中，
	如果需要修改，必须去java类会宗找到相对应的代码，这种方式
	需要工作人员了解代码，使用Properties后可以把数据库连接信息
	写在配置文件中，修改时不需要关注代码问题	
	
数据库连接池	DBCP

	DateBase Connection Pool
	一套管理数据库连接的api

BasicDataSource dataSource = new BasicDataSource();
dataSource.setDriverClassName(driver);
dataSource.setU	rl(url);
dataSource.setUsername(username);
dataSource.setPassword(password);
dataSource.setInitialSize(Integer.parseInt(initSize));
dataSource.setMaxActive(Integer.parseInt(maxSize));
Connection conn = dataSource.getConnection();

意义：
	如果没有连接池，每次web服务器和数据库服务器的交互都需要建立
	和关闭连接如果有一万次请求，则有一万次开关连接，非常消耗资源，
	使用连接池，可以在初始化时设置好一个初始连接数量，连接池会立即
	建立几个初始连接，如果有和数据库交互的需求会从连接池中查找是否
	有空闲连接，有则用，用完归还给连接池，没有空闲，则等待其他连接
	用完后归还，这样能大大降低web服务器和数据库服务器开关连接的数量，
	从而提高执行效率

	当连接池连接数量超过默认值，使用结束后会和线程池一样慢慢回落到初始数量

PreparedStatement

	1代码可读性更高，书写方便
	2因为使用PreparedStatement带有预编译效果当多次插入数据时，
		只需要编译一次即可，所以执行效率要高(效果并不明显)
	3带有预编译效果，可以防止sql注入,因为在sql预编译的时候已经
		把sql的逻辑固定，如果替换？的内容包含了和逻辑相关的
		sql关键字则不生效(如or)

如果执行的sql语句中存在变量值的都使用preparedStatement
如果没有变量值可以使用Statement	

sql注入的语句：password='' or '1'='1'
	' or '1'='1

DAO: Data Access Object
	数据访问对象，里面写所有和jdbc相关的代码

JavaBean

三大特点：
	1/私有属性
	2/对私有属性提供set/get方法
	3/无参构造方法	

做项目数据库有什么表就有和表相对应的对象(javabean)，同时也有和表相对应的DAO

批量操作
	因为每次sql的执行都需要和数据库服务器进行数据交互，
	如果执行sql条数太多，每次都和数据库服务器交互会浪费资源，
	可以通过批量操作的方式，把几次sql请求合并成一次

分页查询

- 相关代码：
	String sql = "select * from student limit ?,?"; 
	stat = conn.prepareStatement(sql); 
	//设置跳过的条数 
	stat.setInt(1, (page-1)*size); 
	//设置每页的条数 
	stat.setInt(2, size); 
	rs = stat.executeQuery(); 
	while(rs.next()){ 
	String name = rs.getString("name");}

事务
	1.关闭自动提交(开始事务)
	conn.setAutoCommit(false);
	
	2.提交事务
	conn.commit();

	3.回滚
	conn.rollback;

获取自增主键的值

stat.executeUpdate(sql,Statement.RETURN_GENERATED_KEYS);
		//得到返回的自增主键
		rs = stat.getGeneratedKeys();
		while(rs.next()) {
			//得到唯一返回值
			int id = rs.getInt(1);
			System.out.println(id);
		}	

stat = conn.prepareStatement(sql,PreparedStatement.RETURN_GENERATED_KEYS);

元数据	MetaData
	-数据库元数据：存放数据库相关信息
	
生成set和get方法快捷键：

	alt+shift+s r alt+a alt+o 回车

ORM

Servlet

	-CS:Client Server 客户端服务器
	特点：每种平台都需要开发相对的app，开放成本高
		功能升级需要下载最新客户端
		因为部分数据在本地保存速度快，用户体验高
		可以利用客户端设备的各种传感器丰富功能

	-BS:Browser Server 浏览器服务器
	特点：跨平台(都能显示效果会不同)、
		功能升级方便
		所有数据都来自服务器，用户体验稍差

两种架构工作中都很常见，以后都会涉及到，工作时主要开发两种架构中的S(服务器)

服务器

	实际是一台高配置电脑，通常内存8G以上
	cpu8核 硬盘T级别(1T=1024G)

web服务器
	电脑中的任何资源(数据或文件)被远程计算机访问都需要有
	一个与之对应的网络通信程序，当有用户访问时，此程序负责
	建立网络连接，读取资源，并把资源返回给用户(数据传输)，此程序负责
	底层的网络连接，处理HTTP协议，使用此类型的程序，程序员
	只需要把精力方在具体的业务逻辑上即可

常见web服务器

	-webSphere:IBM公司产品，闭源收费
	-Tomcat:Apache产品，开源免费，应用在中小型网站中
	-weblogic:Bea公司产品，闭源收费

使用Tomcat服务器演示共享资源

window：
	找到tomcat的bin目录
	在地址栏中输入cmd 开启终端
	然后执行startup.bat 弹出窗口 显示Server startup 说明成功
linux：
	找到home/tomcat8.5.../bin
	该目录下右键打开终端
	在终端中输入 chmod +x *.sh （作用：开启执行.sh批处理文件的权限）
	在终端中输入./startup.sh 显示 tomcat stated 则说明启动成功

总结：
使用tomcat服务器共享文件 一行代码都不用写，如果自己写webServer（web服务器）代码很多而且容易出错，所以以后工作时一般不会自己写web服务器都使用现成的web服务器

tomcat服务器提供了静态资源访问的能力

查看本机ip

	windows：ipconfig
	linux：ifconfig

静态资源和动态资源

	-静态资源：任何用户，任何时间访问内容都一样，包括图片，html和各种文件
	
	-动态资源：不同用户会根据某些逻辑使用户显示的内容不一样的资源，
			通过各种计算生成的网页

Servlet

	意义：

	web服务器(tomcat)本身只提供了静态资源访问的能力，
	而具体的业务中中存在大量的动态资源需求，Serverlet
	就是拓展web服务器动态资源访问能力的产物，Tomcat相当于
	一个web容器，Servlet属于web容器中的组件
	
	如果由注册请求，在web容器中就有一个相对应的注册Servlet

注册请求的过程
	1用户点击浏览器中的表单提交
	2请求会到web服务器，web服务器会找到相对应的注册Servlet
	3在Servlet中 找到相对应的DAO，通过DAO代码把用户请求传递过来的数据保存到数据库中

把Tomcat绑定到Eclipse

	1/windoow->preferences->server->runTime->add->选择和电脑版本一致的版本->本地tomcat路径->finish
	2/window-》showView-》other-》servers
	3/在窗口中删除原来的内容 点击按钮添加，选择对应版本，从下拉选中找到第1步添加的server 然后finish

创建web工程

	创建maven工程，把jar改成war（意思是创建web工程）
	两件事儿：1. 解决报错问题 在projectExplor中最长的文件上右键选择最长的 		
			2.指定运行环境（web服务器）在工程上右键选择最下面的属性
			-》target runtimes 选择 之前添加的mytomcat

web.xml作用

	-在此配置文件中写请求地址和Servlet对应的关系，
	web服务器根据请求地址找到相对应的Servlet时用到此配置文件

请求和响应对象

	-HttpServletRequest

		请求对象，用于获取请求传递过来的各种信息

	-HttpServletResponse

		响应对象，用于处理响应数据(服务器给客户端发送数据)

在运行eclipse的web程序的时候一定要保证tomcat服务器是关闭的
(防止Tomcat被提前手动开启)
	如何关闭：
		在终端中 先保证路径是在tomcat根目录下面的bin目录下 ./shutdown.sh

如何创建Servlet

	创建一个Java类并继承HttpServlet，在类中重写service方法，
	在方法中书写返回数据相关代码
	在web.xml中配置如下信息 
		<servlet>
			<servlet-name>first</servlet-name> 
			<servlet-class>cn.tedu.FirstServlet</servlet-class> 
		</servlet>
		<servlet-mapping> 
			<servlet-name>first</servlet-name> 
			<url-pattern>/firstservlet</url-pattern> 
		</servlet-mapping>

常见错误码

404 ：
	找不到资源 意思是请求的地址没有对应的静态资源和动态资源

500 :
	服务器内部代码错误，如空指针异常，下标越界，
	0作为被除数等任何运行时错误都会提示500

Servlet执行的过程：

	在浏览器地址栏中输入请求地址回车发出请求，
	请求会先发送到web服务器（tomcat web容器），
	tomcat会先检查请求地址请求的是静态资源还是动态资源，
	如果静态资源直接把请求的资源文件返回给浏览器，如果不是静态资源，
	则会去web.xml中查找有没有和请求地址相对应的servlet，
	有的话则通过反射技术创建Servlet对象，并且把请求相关
	信息封装在Request对象中，把响应相关信息封装在Response中，
	然后Servlet创建完后调用Servlet里面的service方法 
	并且把Request和Response传递到Service中，在service方法中
	写具体的业务逻辑，如果在web.xml中没有找到匹配的servelt，
	此时tomcat会给浏览器返回404错误，代表找不到资源



HTTP协议
	是由w3c组织指定的网络应用层协议，规定了浏览器如何与web服务器
	之间通信，已经规定了通讯时的数据格式

姓名：<input name="name"><br/>
	默认文本输入框，不写type也可以


#　1.什么是Servlet?
	sun公司制订的一种用来扩展web服务器功能的
	组件规范。

## (1)扩展web服务器功能
	web服务器只能够处理静态资源的请求（即需要事先将
	html文件写好，并存放到服务器上面），不能够处理
	动态资源的请求（即需要计算，比如访问数据库，生成
	动态的html内容）。
	可以使用Servlet来扩展web服务器的功能。
	即web服务器收到请求之后，如果是动态资源的请求，
	可以调用Servlet来处理。


## (2)Servlet容器
	Servlet运行，需要部署到Servlet容器上面。
	Servlet容器是符合Servlet规范，提供Servlet运行
	环境的程序。也就是说，我们写Servlet，不再需要关注
	网络相关的问题。

# 2.如何写一个Servlet?
	step1.写一个java类，实现Servlet接口或者继承
		HttpServlet。
	step2.编译。  
	step3.打包。
		就是说，需要创建一个具有如下结构的文件夹：
		appname (应用名)
			WEB-INF
				classes (放.class文件)
				lib (可选，放 .jar文件)
				web.xml (部署描述文件)
	step4.部署
		将step3创建的文件夹拷贝到Servlet容器上面。
		注：
			可以使用jar命令将step3创建的文件夹
			压缩成.war结尾的文件，然后再拷贝。

	step5.启动Servlet容器，访问Servlet。

		http://ip:port/appname/url-pattern
	
	注:
		开发工具(比如eclipse)会帮我们节省开发的
		时间（比如编译，打包，部署等环节我们不用
		关注了）	。

## 第一个例子
	public class HelloServlet extends HttpServlet{

	@Override
	protected void service(HttpServletRequest request,
			HttpServletResponse response) 
					throws ServletException, 
					IOException {
		/*
		 * 设置content-type消息头，告诉浏览器，
		 * 服务器返回的数据类型。
		 */
		response.setContentType("text/html");
		/*
		 * 通过response对象获得输出流。
		 */
		PrintWriter out = 
				response.getWriter();
		/*
		 * 将数据存放到response对象上。
		 * 注:
		 * 	 Servlet容器(比如Tomcat)会从response
		 * 对象上获取数据，然后按照http协议要求，将
		 * 这些数据放到一个响应数据包里面，然后发送给
		 * 浏览器。
		 */
		out.println("<h1>Hello Kitty</h1>");
		/*
		 * 关闭流。
		 * 注：
		 * 	Servlet容器会自动关闭out，所以,
		 * out.close不写也可以。
		 */
		out.close();
	}
	
	}

# 3.Servlet是如何运行的?
	比如，在浏览器地址栏输入http://ip:port/day02/hello：
	step1. 浏览器依据ip,port与web服务器建立连接。
	step2. 浏览器将请求数据打包并发送给web服务器。
	step3. web服务器将请求数据包中的数据解析出来，
		并且将这些数据添加到request对象上，同时，
		还会创建response对象。
	step4. web服务器创建Servlet对象，然后调用
		service方法（会将request和response作为
		参数）。
		注:
			可以在service方法里面，使用request对象	
			获得请求数据包里面的数据（比如请求参数值）,也可以将处理结果写到response对象上。
	step5. web服务器从response对象上获取处理结果，
		然后打包发送给浏览器。
	step6. 浏览器解析数据包，生成相应的页面。

# 4.常见的错误
## (1)404
	含义: 404是一个状态码，表示服务器依据请求路径找
	不到对应的资源。
	原因:
		a.请求路径写错。
		b.没有部署或者部署失败。
## (2)500
	含义:500是一个状态码，表示服务器运行出错。
	原因:
		a.Servlet没有严格按照规范来写。
		比如，没有继承HttpServlet,
		又比如servlet-name不一致，servlet-class
		写错等等。
		b.代码写得不严谨。
		比如，对用户填写的参数值没有做检查就做相应的
		转换。
## (3)405
	含义:405是一个状态码，表示找不到处理方法。	
	原因：
		service方法没有正确override父类的方法。

# 5.http协议(了解)
## (1)什么是http协议?
	网络应用层协议，规定了浏览器与web服务器之间如何
	通信以及数据包的结构。
	a.通信过程
		step1.建立连接。
		step2.发送请求。
		step3.发送响应。
		step4.关闭连接。

	b.优点:
		web服务器可以利用有限的连接为尽可能多的请求
		服务。

## (2)数据包的结构
###	1)请求数据包
	请求行 （请求方式 请求资源路径 协议类型和版本）
	若干消息头
		消息头是一些以": "分隔开的键值对，一般由
		http协议规定，用来传递一些特点的信息。比如
		浏览器可以通过发送"user-agent"消息头，告诉
		web服务器，浏览器的类型和版本。
	实体内容
		只有当请求方式为post时，才会有数据。
###	2)响应数据包
	状态行 (协议类型和版本 状态码 状态描述)
	若干消息头
		web服务器也可以发送一些消息头给浏览器，比如
		可以发送"content-type"消息头，告诉浏览器，
		服务器返回的数据类型。
	实体内容
		程序处理结果，浏览器会解析出来，生成相应的
		页面。

## (3)两种请求方式
### 1)get请求
	a.哪些情况下，浏览器会发送get请求?
	  在地址栏输入某个地址。
	  点击链接。
	  表单默认提交方式。
	b.特点
	  会将请求参数添加到请求资源路径后面（即请求行
	里面），只能提交少量的数据。
		注：请求行大约只能存放2K左右的数据。
	  会将请求参数显示在浏览器地址栏，不安全。
		注：有一些网络设备(比如路由器)，会记录
		请求路径。
### 2)post请求
	a.哪些情况下，浏览器会发送post请求
		将表单的method属性设置为"post"。
	b.特点
		会将请求参数添加到实体内容里面，可以提交
		大量的数据。
		不会将请求参数显示在浏览器地址栏，相对get
		请求要安全一些。
		注: 
			不管是哪种请求方式，都不会对请求参数
			进行加密。所以，对于敏感数据，一定要加密
			处理。

# 6.Servlet输出中文要如何处理?
## (1)为什么会有乱码?
	out默认使用iso-8859-1来编码。
## (2)如何解决?
	response.setContentType("text/html;charset=utf-8");
	注：
	作用1：设置content-type消息头,告诉浏览器，
	服务器返回的数据类型。
	作用2: out在输出时，使用指定的字符集来编码。
	
#
创建servlet项目
	创建maven项目，选择var
	创建主配置文件web.xml
	添加运行环境jar包，配置servlet.api

表单包含有中文参数值，如何处理？

	1/为什么会乱码？

		表单提交时，浏览器会对中文参数值进行编码，
		注：会按照表单所有的页面打开时所使用的字符集进行编码
		比如：浏览器会使用utf-8对中文参数值进行编码，而服务器端
		默认会使用iso-8859-1来解码，所以会产生乱码

	2/如何解决
		
		post请求
		
	这行代码要添加到所有的getparemeter方法的最前面

	request.setCharacterEncoding("utf-8");

		get请求
	
	修改tomcat提供的server.xml文件：
	
	<Connector URIEncoding="utf-8"/>
	
	如果是tomcat8以上版本，可以不加
	只针对get请求有效
		
获取请求参数值
	
	1/String request.getParameter(String parameterName)

	注：
	   a/如果请求参数名不存在，会返回null。
	   b/表单中的文本，密码输入框如果不填写任何数据，会获得""。
			
	2/String[] request.getParameterValues(String paramName)
	
	注：
	   a/当由多个请求参数名相同的时候，使用该方法
	   b/对于多选框，如果一个都不选，会返回null值，
		此时如果进行结果遍历会出现java.lang.NullPointerException
		需要使用：
			
			if(interest!=null) {
			for(String s : interest) {
	
junit	用户开发测试的jar包
	@Test
		可以直接运行无参无返回值方法
	
# 3.servlet访问数据库
## step1.建表	
	create table t_user(
		id int primary key auto_increment,
		uname varchar(50) unique,
		pwd varchar(20),
		phone varchar(20),
		email varchar(20)
	);
## step2.导包。
	在pom.xml文件中，添加如下内容
	<dependencies>
		<dependency>
			<groupId>MySQL</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>5.1.6</version>
		</dependency>
		<dependency>
			<groupId>commons-dbcp</groupId>
			<artifactId>commons-dbcp</artifactId>
			<version>1.4</version>
		</dependency>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.12</version>
		</dependency>
	</dependencies>	
## step3.实体类 (User)
	注：该类的结构与表对应。
![](s2.png)

## step4.DAO类 (UserDAO)
	public class UserDAO {
	 public void save(User user){
		Connection conn = null;
		try {
			conn = DBUtils.getConn();
			String sql = "INSERT INTO t_user "
					+ "VALUES(null,?,?,?,?)";
			PreparedStatement ps = 
					conn.prepareStatement(sql);
			ps.setString(1, user.getUname());
			ps.setString(2, user.getPwd());
			ps.setString(3, user.getPhone());
			ps.setString(4, user.getEmail());
			ps.executeUpdate();
		} catch (SQLException e) {
			/*
			 * step1.记日志(保留现场,便于后面分析)
			 */
			e.printStackTrace();
			/*
			 * step2.看异常能否恢复，如果不能够
			 * 恢复(比如，数据库服务停止了,类似这样的
			 * 异常，我们称之为系统异常)，要提示用户
			 * 稍后重试。如果能够恢复，则立即恢复。
			 */
			throw new RuntimeException(e);
			
		}finally{
			DBUtils.close(conn);
		}
		}
	}	
## step5.在Servlet类中调用DAO提供的方法
	public class AddUserServlet extends HttpServlet{

	@Override
	protected void service(HttpServletRequest request,
			HttpServletResponse response) 
					throws ServletException, 
					IOException {
		request.setCharacterEncoding("utf-8");
		response.setContentType(
				"text/html;charset=utf-8");
		PrintWriter out = response.getWriter();
		
		String uname = 
				request.getParameter("uname");
		String pwd = 
				request.getParameter("pwd");
		String phone = 
				request.getParameter("phone");
		String email = 
				request.getParameter("email");
		System.out.println("uname:" + uname + " pwd:" 
				+ pwd + " phone:" + phone 
				+ " email:" + email);
		
		UserDAO dao = new UserDAO();
		User user = new User();
		user.setUname(uname);
		user.setPwd(pwd);
		user.setPhone(phone);
		user.setEmail(email);
		try{
			dao.save(user);
			out.println("添加成功");
		}catch(Exception e){
			e.printStackTrace();
			out.println("系统繁忙，稍后重试");
		}
	 }
	}


按照指定的字符集进行编码，然后将编码之后生成的字节数组转换成16进制数的形式
String name="小白";

		String name1 = URLEncoder.encode(name,"utf-8");


decode方法：按照指定的字符集进行解码

		String name2 = URLDecoder.decode(name1,"utf-8");

对于异常的处理
	1/要写异常日志(保留现场,便于后面分析)
	2/看异常能否恢复，对于无法恢复的系统异常要提示用户稍后重试


如果DAO中发生异常要外抛给servlet
	catch (Exception e) {
			e.printStackTrace();
			throw new RuntimeException(e);

servlet在连接数据库操作时要try-chtch，并提示用户
	try {
				dao.delete(u);
				pw.println("删除成功");
			} catch (Exception e) {
				e.printStackTrace();
				pw.println("系统繁忙，稍后重试");
			}

<!-- 模拟content-type消息头
注：
浏览器解析到meta时，就好像浏览器收到了一个content-type消息头
浏览器就会按照指定的字符集进行解码 
<meta http-equiv="content-type" content="text/html;charset=utf-8">
-->
<meta charset="UTF-8">

throw new RuntimeException(e);直接抛需要throws

# 1.重定向
## (1)什么是重定向?
	服务器通知浏览器向某个地址发送请求。
	注：
		服务器一般通过发送302状态码和一个Location
		消息头（该消息头的值是一个地址，一般称之为
		重定向地址）给浏览器，浏览器收到之后，会立即
		向重定向地址发请求。	

## (2)如何重定向?
		response.sendRedirect(String url)。
		注：
			url就是重定向地址。
## (3)特点
		a.重定向地址是任意的。
		b.重定向之后，浏览器地址栏的地址会发生变化。
## (4)一个细节（了解）
		重定向之前，servlet容器会先清空response上
		存放的所有数据。

# 2.Servlet的生命周期
## (1)什么是servlet的生命周期?
	servlet容器如何创建servlet对象，如何对该对象
	进行初始化处理，如果调用该对象的方法来处理请求，
	以及如何销毁该对象的整个过程。
	即servlet容器是如何管理servlet的。

## (2)生命周期分成哪几个阶段?
### 1)实例化
	a.什么是实例化?
		servlet容器调用servlet构造器，创建
		servlet对象。
	b.什么时候实例化?
		情形1:servlet容器收到请求之后。
		情形2:servlet容器启动之后，立即创建(需要
		修改web.xml文件的配置)。
<!-- 值是一个大于等于0的整数，值越小，则优先级越高
			即：容器先创建值小的 -->(web.xml文件中)
			<load-on-startup>1</load-on-startup>
		注：容器只会创建一个实例!

###　2)初始化
	a.什么是初始化?
		servlet容器调用servlet对象的init方法。
		注：
			该方法只会调用一次！
	b.init方法：
		b1. GenericServlet已经实现了该方法。
			注:
				将容器传递进来的ServletConfig对象
			保存下来了,并且提供了getServletConfig
			方法用来获得该对象。
		b2. ServletConfig对象用来读取servlet的初
			始化参数。
		b3. 可以override init方法来实现自已的初始化
			处理逻辑。
			注：
				应该override不带参的那个init方法。

### 3)就绪(调用)
	a.什么是就绪?
		servlet容器调用servlet对象的service方法
		来处理请求。
	b.HttpServlet的service方法是如何实现的?
		依据请求类型调用对应的doXXX方法：
		比如，get请求调用doGet方法，post请求
		调用doPost方法。这两个方法需要override。
![](service.png)

### 4)销毁
	a.什么是销毁?
	 servlet容器在删除servlet对象之前，会调用
	该对象的destroy方法。
		注：该方法只会执行一次！
	b.GenericServlet已经实现了destroy方法。
		注：　可以override该方法，来实现自已的初始
		化处理逻辑。

## (3)生命周期相关的接口与类(了解)。
	a.Servlet接口
		init(ServletConfig config)
		service(ServletRequest req,Servlet
				Response res)
		destroy()
	b.GenericServlet抽象类
		实现了Servlet接口中的部分方法(init,destroy)。
	c.HttpServlet抽象类
		继承了GenericServlet，实现了service方法。
	
	
jsp	java server page

隐含对象
	
	out,request,response

指令	<%@	%>

	属性
	
	import
	contentType
	pageEncoding

语法

java代码片段
	<%	%>

指令
	<%@	%>

jsp表达式
	<%=	%>

单双行样式
	<tr class="row<%= i%2+1%>">

使用静态页面写jsp

# 1. jsp是什么? (java server page)
	sun公司制订的一种服务器端动态页面技术规范。
	注:
		虽然使用servlet也可以生成动态页面，但是
	过于繁琐(需要使用大量的out.println语句),并且
	难以维护(修改页面，需要修改java源代码),所以，
	sun公司后来制订了jsp技术规范，用来更方便的生成
	动态页面。
		jsp是一个以.jsp为后缀的文件，主要内容是
	html和少量的java代码，容器(比如tomcat)会将
	jsp文件转换成一个对应的servlet然后执行。

**jsp的本质就是一个servlet!**

# 2.如何写一个jsp文件?

	step1. 写一个以.jsp为后缀的文件。
	step2.　在该文件里面，可以添加如下内容:

## (1)html(css,js)

	直接写就可以了。

## (2)java代码

	1)java代码片断
	<% java代码   %>

	2)jsp表达式
	<%= java表达式 %>

## (3)隐含对象

	1)什么是隐含对象?

		在jsp文件里面可以直接使用的对象，比如
		out,request,response。

	2)为什么可以直接使用这些隐含对象?

		容器在生成jsp对应的servlet时，会自动添加
		获得这些对象的代码。

## (4)指令

	1)什么是指令?

		通过指令，告诉容器，在生成servlet时，做一
		些额外的处理，比如导包。

	2)指令的语法:

		<%@ 指令名 属性=值  %>

	3)page指令

		import属性：指定要导入的包名，比如
			<%@ page import="java.util.*"%>
			<%@ page import="java.util.*,java.text.*"%>
		contentType属性：指定	response.setContentType方法的参数值。
		pageEncoding属性：告诉容器，在读取jsp文件
			的内容时，使用指定的字符集去解码。

# 3.jsp是如何执行的?

## (1)阶段一　容器将jsp文件转换成一个servlet
	规则: 
		html(css,js) -----> service方法里面，使用
						out.write方法输出。
		<%       %>  ------> service方法里面照搬。
		<%=      %>  ------> service方法里面，使用
						out.print方法输出。
		注：（了解）
				write方法会将null转换成""输出，
				而print方法会将null输出为null。

## (2)阶段二 容器调用该servlet处理请求
		注：
			包括实例化、初始化、调用、销毁。

# 练习:员工列表
**具体要求:** 写一个jsp(listEmp.jsp),将所有员工信息以表格的形式显示出来。

## step1.建表	
	create table t_emp(
		id int primary key auto_increment,
		ename varchar(50),
		salary double,
		age int
	);
	insert into t_emp values(null,'Sally',2000,22);
	insert into t_emp values
	(null,'Tom',3000,22);
## step2.创建一个maven工程
**记得生成部署描述文件，并指定服务器。**
## step3.导包
	<dependencies>
		<dependency>
			<groupId>MySQL</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>5.1.6</version>
		</dependency>
		<dependency>
			<groupId>commons-dbcp</groupId>
			<artifactId>commons-dbcp</artifactId>
			<version>1.4</version>
		</dependency>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.12</version>
		</dependency>
	</dependencies>
## step4.添加jdbc.properties文件
![](s1.png)
## step5.添加DBUtils类（用之前的就可以了）
## step6. Emp类（即实体类）
	注：与表的结构一致。
	package entity;

	public class Emp {
	private int id;
	private String ename;
	private double salary;
	private int age;
	
	@Override
	public String toString() {
		return "Emp [id=" + id + ", ename=" + ename + ", salary=" + salary + ", age=" + age + "]";
	}
	
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getEname() {
		return ename;
	}
	public void setEname(String ename) {
		this.ename = ename;
	}
	public double getSalary() {
		return salary;
	}
	public void setSalary(double salary) {
		this.salary = salary;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	}
## step7. EmpDAO类
	package dao;

	import java.sql.Connection;
	import java.sql.PreparedStatement;
	import java.sql.ResultSet;
	import java.sql.SQLException;
	import java.util.ArrayList;
	import java.util.List;
	
	import entity.Emp;
	import util.DBUtils;
	
	public class EmpDAO {
	
	/**
	 * 查询出所有员工信息
	 * 
	 */
	public List<Emp> findAll(){
		List<Emp> emps = 
				new ArrayList<Emp>();
		
		Connection conn = null;
		try {
			conn = DBUtils.getConn();
			String sql = "SELECT * FROM t_emp";
			PreparedStatement ps = 
				conn.prepareStatement(sql);
			ResultSet rs = ps.executeQuery();
			while(rs.next()){
				int id = rs.getInt("id");
				String ename = rs.getString("ename");
				double salary = rs.getDouble("salary");
				int age = rs.getInt("age");
				Emp e = new Emp();
				e.setEname(ename);
				e.setSalary(salary);
				e.setAge(age);
				emps.add(e);
			}
		} catch (SQLException e) {
			e.printStackTrace();
			throw new RuntimeException(e);
		}finally{
			DBUtils.close(conn);
		}
		return emps;
	}
	}
## step8. 将css,img文件夹拷贝到webapp下
## step9. 添加listEmp.jsp
	<%@ page pageEncoding="utf-8" 
	contentType="text/html; charset=utf-8"%>
	<%@ page import="java.util.*,entity.*,dao.*" %>

	<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
	<html>
	<head>
    <title>listUsers</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link rel="stylesheet" type="text/css" 
    href="css/style.css" />
	</head>
	<body>
    <div id="wrap">
      <div id="top_content"> 
        <div id="header">
          <div id="rightheader">
            <p>
              2009/11/20
              <br />
            </p>
          </div>
          <div id="topheader">
            <h1 id="title">
              <a href="#">main</a>
            </h1>
          </div>
          <div id="navigation">
          </div>
        </div>
        <div id="content">
          <p id="whereami">
          </p>
          <h1>
                          员工列表
          </h1>
          <table class="table">
            <tr class="table_header">
              <td>
                ID
              </td>
              <td>
                                  姓名
              </td>
              <td>
                                   薪水
              </td>
              <td>
                                  年龄
              </td>
              <td>
                                  操作
              </td>
            </tr>
            <%
              EmpDAO dao = new EmpDAO();
              List<Emp> emps = 
                  dao.findAll();
              for(int i = 0; i < emps.size(); i ++){
                Emp e = emps.get(i);
                %>
            <tr class="row<%=i % 2 + 1%>">
              <td>
                <%=e.getId()%>
              </td>
              <td>
                <%=e.getEname()%>
              </td>
              <td>
                <%=e.getSalary()%>
              </td>
              <td>
                <%=e.getAge()%>
              </td>
              <td>
                <a href="listUsers.html">删除</a>&nbsp;
              </td>
            </tr>
                <%
              }
            %>
          </table>
          <p>
            <input type="button" 
            class="button" value="添加员工" 
            onclick="location='addUser.html'"/>
          </p>
        </div>
      </div>
      <div id="footer">
        <div id="footer_bg">
        ABC@126.com
        </div>
      </div>
    </div>
  	</body>
	</html>

servlet
	数据访问逻辑
	表示逻辑
	业务逻辑
	
# 1.转发
## (1)什么是转发?
	一个web组件将未完成的处理交给另外一个
	web组件继续做。
	注：
		web组件指的是jsp或者servlet。
		常见的情形是：servlet就数据获取之后，交给
		jsp来呈现这些数据。
## (2)如何转发?
	step1.绑订数据到request对象上。
		request.setAttribute(String name,Object obj);
	step2.获得转发器。
		RequestDispatcher rd = 
			request.getRequestDispatcher(String uri);
		注:
			RequestDispatcher是一个接口。
			可以将转发器理解为web组件通知容器
			去调用另外一个web组件的媒介。
	step3.转发
		rd.forward(request,response);
		注:
			转发的本质是一个web组件通知容器
			去调用另外一个web组件。
![](forward.png)

## (3)特点
	a.转发之后，浏览器地址栏的地址不会变。
	b.转发的目的地有限制（要求是同一个web应用）。

#　2.比较转发与重定向
## (1)能否共享request对象
	转发可以，重定向不行。
	注：
		a.容器收到请求，立即创建request和response,
		一旦响应发送完毕，则立即销毁这两个对象。
		即request和response的生存时间是一次请求与
		晌应期间存在。
		b.转发是一次请求。重定向是二次请求。
## (2)浏览器地址栏的地址有无变化
	转发无变化，重定向有变化。
## (3)目的地有无限制
	转发有限制（同一个web应用），重定向没有任何限制。
## (4)一件事是否做完
	转发是一件事没有做完，让另外一个web组件继续做，而重定向是一件事已经做完，然后做另外一件事。

# 3.路径问题
## (1)什么是路径问题?
	链接、表单提交、重定向和转发如何填写相应的
	路径（或者叫地址）。
## (2)相对路径
	不以"/"开头的路径就是相对路径。比如
	<form action="add">
## (3)绝对路径
	1)什么是绝对路径?
	以"/"开头的路径就是绝对路径
	2)如何写绝对路径?
	链接、表单提交、重定向从应用名开始写，
	而转发从应用名之后开始写。
	注：
		不要将应用名直接写在路径里面，而应该
		使用request.getContextPath()方法来
		获得应用名。

# 练习：登录
	用户填写用户名和密码并提交表单，服务器端
	依据用户名和密码查询数据库。如果有符合条件的
	记录，则登录成功，返回用户列表页面;否则返回
	到登录页面并提示"用户名或密码错误"。

## 提示:
### step1.给UserDAO增加一个查询方法:
	/**
	 * 依据用户名查询，如果找不到，返回null,
	 * 否则返回一个User对象（包含了用户的所有信息）
	 */
	public User find(String uname){
		User user = null;
		Connection conn = null;
		try {
			conn = DBUtils.getConn();
			String sql = "SELECT * FROM t_user "
					+ "WHERE uname=?";
			PreparedStatement ps = 
				conn.prepareStatement(sql);
			ps.setString(1, uname);
			ResultSet rs = ps.executeQuery();
			if(rs.next()){
				int id = rs.getInt("id");
				String pwd = rs.getString("pwd");
				String phone = rs.getString("phone");
				String email = rs.getString("email");
				user = new User();
				user.setId(id);
				user.setUname(uname);
				user.setPwd(pwd);
				user.setPhone(phone);
				user.setEmail(email);
			}
		} catch (SQLException e) {
			e.printStackTrace();
			throw new RuntimeException(e);
		}finally{
			DBUtils.close(conn);
		}
		return user;
	}

### step2.添加login.jsp。
	修改login.html即可。

### step3.添加LoginServlet。
	public class LoginServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void service(
			HttpServletRequest request, 
			HttpServletResponse response) 
					throws ServletException, 
					IOException {
		//处理表单中文参数值
		request.setCharacterEncoding("utf-8");
		//读取用户名和密码
		String uname = 
				request.getParameter("uname");
		String pwd = 
				request.getParameter("pwd");
		//访问数据库，看是否有匹配条件的记录
		UserDAO dao = new UserDAO();
		try{
			User user = dao.find(uname);
			
			if(user != null 
					&& user.getPwd().equals(pwd)){
				/*
				 * 如果有匹配条件的记录，则登录成功,
				 * 返回用户列表页面
				 */
				response.sendRedirect("list");
			}else{
				/*
				 * 如果没有匹配的记录，则登录失败，
				 * 返回到登录页面，并提示用户名或密码
				 * 错误
				 */
				request.setAttribute("login_failed",
						"用户名或密码错误");
				request.getRequestDispatcher("login.jsp")
				.forward(request, response);
			}
		}catch(Exception e){
			e.printStackTrace();
			request.setAttribute("errorMsg",
					"系统繁忙，稍后重试");
			request.getRequestDispatcher(
					"error.jsp").forward(
							request, response);
		}
		
	 }

	}

# 1.状态管理
## (1)什么是状态管理?
	将浏览器与web服务器之间多次交互当做一个整体
	来处理，并且将多次交互所涉及的数据（即状态）
	保存下来。
## (2)如何进行状态管理?
	方式一：将状态保存在客户端（浏览器端）
		　Cookie技术
	方式二:将状态保存在服务器端
		 Session技术
## (3)Cookie技术
### 1)什么是Cookie?
	服务器临时存放在浏览器端的少量数据。
### 2)工作原理
	浏览器访问服务器时，服务器会将少量数据以
	set-cookie消息头的形式发送给浏览器，浏览器
	将这些数据保存下来；
	当浏览器再次访问服务器，会将之前保存的这些数据
	以cookie消息头的形式发送给服务器。
![](cookie.png)

### 3)添加Cookie
	Cookie c = new Cookie(String name,String value);
	注:
		name:cookie的名称。
		value:cookie的值。
	response.addCookie(c);

### 4)读取Cookie
	Cookie[] request.getCookies();
	注：
		a. 一个Cookie对象封装了一个Cookie的
		 信息（包括cookie的名称和值）。
			String cookie.getName()
			String cookie.getValue()
		b.有可能返回null。
### 5）编码问题
	a.什么是编码问题?
		cookie只能保存合法的ascii字符，中文需要转
		换成合法的ascii字符才可以。
	b.如何处理?
		String URLEncoder.encode(String str,
		String charset);
		String URLDecoder.decode(String str,
		String charset);
	c.建议:
		在添加cookie时，对所有的值都统一使用上述
		方法来进行处理。

### 6)生存时间
	默认情况下，浏览器会将cookie保存在内存里面，
	只要浏览器不关，则cookie会一直存在。
	可以调用cookie.setMaxAge方法来设置cookie的
	生存时间:
		setMaxAge(int seconds)
		注:
			a. 单位是秒。  
			b. 值可以是
				>0： 浏览器会将cookie保存在硬盘上，
					当超过指定的时间，浏览器会将
					cookie删除。
			    <0 : 缺省值，即浏览器会将cookie保存
					在内存里面。
				=0 ：删除cookie。
					比如,要删除名称为city的cookie
				Cookie c = new Cookie("city","");
				c.setMaxAge(0);
				response.addCookie(c);
					
### 7)cookie的路径问题
	a.什么是cookie的路径问题?
	 浏览器在向服务器上的某个地址发送请求时，会比较
	该地址是否符合cookie的路径的要求，只有符合条件的
	cookie才会被发送。
	b.cookie的默认路径
		cookie的默认路径等于添加该cookie的
	  web组件的路径。
		比如 /day07/abc/addCookie.jsp添加了
		一个cookie,则该cookie的默认路径就是
		"/day07/abc"。				
	c.匹配规则
		比如，cookie的路径是"/day07/abc"。
		如果访问的是 
			/day07/findCookie1.jsp no
			/day07/abc/findCookie2.jsp  yes
			/day07/abc/sub/findCookie3.jsp  yes
		即:
			请求路径要么等于cookie的路径，要么
		是cookie路径的子路径，则该cookie会被
		发送。

	d.修改cookie的路径:
		cookie.setPath(String path)
				
### 8)cookie的限制
	a.可以被用户禁止。
	b.不安全。
		注：不要将敏感数据以cookie的方式来保存，
		如果一定要保存，则一定要加密。
	c.只能保存少量数据。
		注：大约是4k左右。
	d.cookie的数量也有限制。
		注：大约几百个。
	e.cookie只能保存字符串。

# Session (会话)
## (1)什么是session?
	服务器端为了保存状态而创建的一个特殊的对象。
## (2)工作原理
	浏览器访问服务器时，服务器会创建session对象
	(该对象有一个唯一的id,一般称之为sessionId),
	服务器会将sessionId以cookie的形式发送给浏览器。
	当浏览器再次访问服务器时，会将sessionId发送过来，
	服务器依据sessionId就可以找到之前创建的session对象。
## (3)如何获得session对象?
### 1)方式一
	HttpSession s = 
			request.getSession(boolean flag);
	注:
		a. HttpSession是一个接口。
		b. 当flag为true时:
			查看请求当中是否有sessionId,如果没有，
			则创建一个符合HttpSession接口要求的
			对象。
			如果有sessionId,则依据sessionId查找
			对应的session对象，如果找到了，则返回
			该对象；找不到，则创建一个新的session对象。
		c. 当flag为false时:
			查看请求当中是否有sessionId,如果没有，
			返回null。
			如果有sessionId,则依据sessionId查找
			对应的session对象，如果找到了，则返回
			该对象；找不到，返回null。
![](session.png)
		
### 2)方式二
		HttpSession s = request.getSession();
		等价于 request.getSession(true);

## (4)HttpSession提供的几个方法	
	String getId();
	setAttribute(String name,Object obj);
	Object getAttribute(String name);
	//解除绑订
	removeAttribute(String name);

## 统计访问次数
![](count.png)

## (5)session超时
### 1)什么是session超时?
	服务器会将空闲时间过长的session对象删除掉。
	注：
		a.这样做的目的是为了节省内存。
		b.大部分服务器默认的超时时间为30分钟。
### 2)修改超时限制
	方式一
	修改web.xml中的<session-config>配置。
	<session-config>
        <session-timeout>30</session-timeout>
    </session-config>
	方式二
	setMaxInactiveInterval(int seconds)
	注:
		两次请求之间的间隔长度如何超过了指定的时间，
		则session对象会被销毁。

## (6)删除session
	invalidate()

## (7)比较session与cookie
	安全性：
		session相对安全一些，cookie不安全（将数据保存浏览器端）。
	数据量大小:
		session保存的数据量更大，cookie只能保存
		少量数据。
		注：实际使用中，建议在session对象上绑订尽可　
		能少的数据，因为会占用服务器过多的内存空间。
	数据类型:
		session支持更丰富的数据类型(Object),cookie
		只能保存字符串。
	但是,要注意，session对象要占用服务器的内存空间，
	如果用户量过大，则服务器的内存空间就会占用过多。

# 1.过滤器

## (1)过滤器是什么?
	servlet规范当中定义的一种特殊的组件，用于拦截
	servlet容器的调用过程。
	注：
		容器收到请求之后，会先调用过滤器，再调用
	后面的组件（比如servlet）。
![](filter.png)

## (2)如何写过滤器?
	step1.写一个java类，实现Filter接口。
	step2.在接口方法当中实现拦截处理逻辑。
	step3.配置过滤器。(web.xml)

## (3)过滤器的优先级
	当有多个过滤器都满足拦截要求，容器会依据配置的
	先后顺序来执行。

## (4)初始化参数
	step1.在web.xml文件当中，配置初始化参数
		<init-param>
			<param-name>
			<param-value>
		</init-param>
	step2.读取初始化参数
		String FilterConfig.getInitParameter(
		String name);
## 思考:
	过滤器有什么优点?

## 参考代码:
	public class CommentFilter implements Filter{
	
	/**
	 * 容器启动之后，会立即创建过滤器实例，
	 * 注：
	 * 	只会创建一个
	 */
	public CommentFilter(){
		System.out.println(
				"CommentFilter的构造器");
	}
	
	/**
	 * 容器删除过滤器实例之前，会调用
	 * destroy方法。
	 * 注：
	 * 	该方法只会执行一次。
	 */
	public void destroy() {
		
	}

	/**
	 * 容器在完成初始化方法的调用之后，接下来，会调用
	 * doFilter方法来处理请求。
	 * 注:
	 * 	a.容器会将request对象和response对象作为参数传递
	 * 进来。
	 * 	b.(了解) ServletRequest是HttpServletRequest的
	 * 	父接口，ServletResponse是HttpServletResponse的
	  * 　父接口。
	 *  c.容器会将FilterChain(过滤器链)作为参数传递进来，
	 *  如果调用了该对象的doFilter方法，则容器会继续向后
	 *  调用，否则，中断调用，返回处理结果。
	 */
	public void doFilter(
			ServletRequest arg0, 
			ServletResponse arg1, FilterChain arg2)
			throws IOException, ServletException {
		
		System.out.println(
				"CommentFilter的doFilter方法开始执行...");
		
		//我们经常调用的是子接口中的方法，所以
		//需要做强制转换。
		HttpServletRequest request = 
				(HttpServletRequest)arg0;
		HttpServletResponse response = 
				(HttpServletResponse)arg1;
		
		request.setCharacterEncoding("utf-8");
		response.setContentType(
				"text/html;charset=utf-8");
		
		String content = 
				request.getParameter("content");
		
		if(content.indexOf("狗") != -1){
			/*
			 * 包含了敏感字，则中断调用，返回处理
			 * 结果。
			 */
			response.getWriter().println(
					"包含了违禁词");
		}else{
			/*
			 * 没有敏感字，则继续向后调用。
			 * 注：
			 * 	　即调用后续的过滤器和servlet。
			 */
			arg2.doFilter(request, response);
		}
		
		System.out.println(
				"CommentFilter的doFilter方法执行完毕");
		
	}
	
	
	
	
	
	/**
	 * 容器在创建过滤器实例之后，会立即调用其
	 * 初始化方法（即init方法）。
	 * 注:
	 * 	 a. 该方法只会执行一次。
	 * 	 b. FilterConfig由容器传递过来，用来读取
	 * 		初始化参数。
	 */
	public void init(FilterConfig arg0) 
			throws ServletException {
		System.out.println(
				"CommentFilter的init方法");
	 	}

	}

# 2.监听器
## (1)什么是监听器?
	Servlet规范当中定义的一个特殊的组件，用于监听
	servlet容器产生的事件。
	注:容器产生的事件主要有两大类:
	生命周期相关的事件
		指的是，当容器创建了或者销毁了request,
		session,Servlet上下文时产生的事件。
	绑订数据相关的事件
		指的是，当调用了request,session,Servlet
		上下文时产生的事件。

过滤器优点

	在不修改原有代码的基础上，增加新的功能
	将多个组件相同的处理逻辑集中写在一个类里面(过滤器)，方便代码维护

流程

	1/写一个java类实现响应监听器接口，具体根据监听的事件类型，
		监听session创建和销毁实现HttpSessionListener接口
	2/接口方法中实现监听逻辑

HttpSession session = arg0.getSession();
ServletContext sc = session.getServletContext();
Integer count = (Integer)sc.getAttribute("count");

<!-- 配置监听器 -->
  <listener>
  	<listener-class>web.CountListener</listener-class>
  </listener>
	

## (2)Servlet上下文
	1)什么是Servlet上下文?
		容器启动之后，会为每一个web应用创建唯一的
		一个符合ServletContext接口要求的对象，该
		对象一般称之为Servlet上下文。
	2)特点
		a.唯一性：一个web应用对应一个上下文。
		b.持久性: 只要容器不关闭，并且应用没有被
			卸载，则上下文会一直存在。

	3)如何获得servlet上下文?
		GenericServlet,ServletConfig,
		FilterConfig,HttpSession都提供了
		getServletContext方法来获得
		上下文。
		注：
			如果是servlet,可以使用
			GenericServlet或者ServletConfig
			提供的方法。	
			如果是过滤器，可以使用
			FilterConfig提供的方法。
			如果是监听器，可以使用
			HttpSession提供的方法。

	4)作用
		作用１：绑订数据
			setAttribute(String name,Object obj)
			Object getAttribute(String name)
			removeAttribute(String name)
![](s1.png)

		注：
			request,session,上下文都提供了绑订数据
			相关的方法，区别如下:
			a. 从生存时间的长度去比较，request <
			session < 上下文。在满足使用条件的情况下，优先使用生命周期短的。
			b.　从访问的范围来看，绑订到session对象上
			的数据，只能被该session对应的用户访问到，绑订到上下文上的数据，可以被所有用户
			访问。
![](s2.png)

	  作用２:读取全局的初始化参数。
		  a.什么是全局的初始化参数?
			同一个web应用当中的所有组件都能读取的
			初始化参数（包括servlet,filter）
		  b.如何使用?
			step1.配置全局的初始化参数:
			<context-param>
		  		<param-name>company</param-name>
		  		<param-value>IBM</param-value>
		  	</context-param>
			step2.调用ServletContext提供的方法:
			　	String getInitParameter(String name);
			

servlet线程安全问题

概念

	1/容器只会创建一个servlet实例
	2/容器收到一个请求就会启动一个线程去处理
	如果有多个线程同时访问servlet，就有可能产生线程安全问题，
	这些线程可能都在修改某个属性值

解决

	synchronized对代码块加锁
	注：
	加锁后会影响性能




servlet总结

servlet基础

	什么servlet
	怎么写servlet
	sevlet如何运行
	了解Http
		什么Http
		特点
		数据包结构
		状态码，消息头
	什么是servlet容器

servlet核心

	如何获得请求参数值
	处理表单中文参数值
	处理servlet输出中文
	容器处理请求资源路径
	一个servlet处理多个请求
	转发与重定向
		什么是重定向
		如何重定向
		重定向的特点
		什么是转发
		如何转发
		转发的特点
		转发与重定向的区别

	servlet的生命周期
		什么是servlet的生命周期
		分为哪几个阶段
		容器在什么时候创建servlet实例
		init方法会执行几次
		初始化参数的配置
		doGet\doPost方法的作用
		相关的接口与类

	Servlet上下文
		概念
		特点
		如何获得
		作用
			绑定数据(request/session/上下文)的区别(生命周期和范围)
	线程安全问题
		原因
		解决：加锁
	路径问题
		相对路径
		绝对路径
		如何写绝对路径

状态管理

	概念
	如何状态管理：cookie/session
	cookie
		概念
		原理
		添加
		三个问题/编码/生存事件/路径
		读取
		cookie的限制
	session
		概念
		原理
		获取
		session超时setMaxInactiveInterval
		删除session
		cookie和session比较
		
数据库访问

	dao

过滤器与监听器

	什么是过滤器
	如何写过滤器
	过滤器优先级
	初始化参数
	什么是监听器
	如何写监听器

## 过滤器的优点（了解）
	a.在不修改原有代码的基础上，增加新的功能。
	b.将多个组件相同的处理逻辑集中写在一个类里面
	（即过滤器里面），方便代码的维护。

# 1.监听器
## (1)什么是监听器?
	servlet规范当中定义的一种特殊的组件，用于监听
	servlet容器产生的事件并进行相应的处理。
	注:
	 	事件分两大类
	 a.生命周期相关的事件
		容器创建了或者销毁了request,session,
		servlet上下文时产生的事件。
	 b.绑订数据相关的事件
		request,session,servlet上下文执行了
		setAttribute,removeAttribute方法时产生
		的事件。
## (2)如何写一个监听器?
	step1.写一个java类，实现相应的监听器接口。
	注：
		具体要看监听的事件类型，比如，要监听
		session的创建和销毁，就需要实现HttpSession
		Listener接口。
	step2.在接口方法当中，实现监听处理逻辑。
	step3.配置监听器。(web.xml)

## 统计在线人数
![](count.png)

## 参考代码:
	public class CountListener implements 
	HttpSessionListener{

	/**
	 * session对象创建之后，容器会调用
	 * 此方法。
	 * 	arg0:事件对象。
	 */
	public void sessionCreated(
			HttpSessionEvent arg0) {
		System.out.println("sessionCreated方法");
		/*
		 * 通过Servlet上下文获得当前在线人数，
		 * 如果值为null,则将人数置为１，否则人数加１。
		 */
		HttpSession session = 
					arg0.getSession();
		ServletContext sctx = 
					session.getServletContext();
		Integer count = 
				(Integer)sctx.getAttribute("count");
		if(count == null){
			count = 1;
		}else{
			count ++;
		}
		//将最新的人数绑订到上下文
		sctx.setAttribute("count", count);
		
	}

	/**
	 * session对象销毁之后执行。
	 */
	public void sessionDestroyed(
			HttpSessionEvent arg0) {
		System.out.println("sessionDestroyed方法");
		ServletContext sctx = 
				arg0.getSession().getServletContext();
		Integer count = 
				(Integer)sctx.getAttribute("count");
		count --;
		sctx.setAttribute("count", count);
		
	}
	


# 2.servlet的线程安全问题
## (1)为什么说servlet会有线程安全问题?
	a.容器只会创建一个servlet实例。
	b.容器收到一个请求，就会启动一个线程，由该
	线程来处理请求。
	如果有多个线程同时访问某个servlet，就有可能
	产生线程安全问题，比如，这些线程都在修改某个
	属性值。
	
![](thread.png)

## (2)如何解决?
	可以使用synchronized对有可能产生线程安全问题的
	代码块加锁。
	注：　加锁之后会影响性能。

## (3)参考代码:
	public class SomeServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	private int count = 0;
	
	protected void service(
			HttpServletRequest request, 
			HttpServletResponse response) 
					throws ServletException, 
					IOException {
		
		synchronized(this){
			count ++;
			
			try {
				Thread.sleep(800);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			
			System.out.println(
					Thread.currentThread().getName() 
					+ ": " + count);
		}
		
	}
	
# 3.容器如何处理请求资源路径?
	比如，http://ip:port/day10-3/abc.html
	step1.容器默认会认为访问的是一个servlet,
	会查看web.xml配置信息，看是否有匹配的servlet。
	注：
		匹配规则
	方式一　精确匹配
		比如，对于上述请求，<url-pattern>的值必须是
		"/abc.html"。
	方式二  通配符匹配
		<url-pattern>/*</url-pattern>
		<url-pattern>/demo/*</url-pattern>
		"*"可以匹配零个或者多个任意的字符。
	方式三　后缀匹配
		<url-pattern>*.do</url-pattern>
		匹配所有以".do"结尾的请求。
	step2.查找对应的文件，然后返回。如果找不到，返回
		404。

# 4.如何让一个servlet处理多种请求？
	step1.该servlet在配置的时候，使用后缀匹配。
![](a1.png)

	step2.分析请求资源路径，依据分析的结果进行相应
		的处理。
##　参考代码:
	public class ActionServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	
	protected void service(
			HttpServletRequest request, 
			HttpServletResponse response) 
					throws ServletException, 
					IOException {
		System.out.println(
				"ActionServlet的service方法");
		
		//获得请求资源路径
		String uri = request.getRequestURI();
		System.out.println("uri:" + uri);
		
		//分析请求资源路径，依据分析结果，进行相应的处理
		String path =
				uri.substring(
						uri.lastIndexOf("/"),
						uri.lastIndexOf("."));
		System.out.println("path:" + path);
		
		if("/add".equals(path)){
			System.out.println("处理添加用户的请求...");
		}else if("/list".equals(path)){
			System.out.println("处理用户列表的请求");
		}
	}
 
# 1. jsp基础
## (1)jsp是什么?
	sun公司制订的一种服务器端的动态页面技术规范。
	jsp是一个以.jsp为后缀的文件，主要由html和少量的
	java组成，容器会将jsp转换成一个servlet然后执行。

## (2)如何写一个jsp?
	step1.添加一个以.jsp为后缀的文件。
	step2.可以使用以下元素:
### 1)html(css,javascript)
		直接写。
### 2)java代码
	a. java代码片断
		<%  java代码  %>
	b. jsp表达式
		<%= java表达式 %>
	c. jsp声明    (a.jsp)
		<%! 变量或者方法  %>
### 3)隐含对象
	a.什么是隐含对象?
	　可以直接使用的对象，比如out。
	b.为什么可以直接使用这些隐含对象?
	  容器会自动添加获得这些对象的代码。
	c.有哪些隐含对象? 
	  out,request,response
	  application
	  session (a2.jsp)
	  pageContext (a3.jsp,a4.jsp)
		注:
			容器会为每一个jsp实例(jsp对应的servlet)
			创建唯一的一个符合PageContext接口要求的
			对象（页面上下文）。
			特点:
			唯一性：一个jsp实例对应一个页面上下文。
			持久性:只要jsp实例没有被删除，则页面上下文会一直存在。
			作用:
				作用1:绑订数据(绑订到页面上下文上的
				数据，只有对应的jsp能访问到)。
				作用2:提供了获得其它所有隐含对象的方法。
![](pageContext.png)
				
	  config (a5.jsp)
			注：就是ServletConfig，用于读取初始化参数。
			
      exception (a6.jsp,a7.jsp)
			注：
				用来获得jsp运行时产生的异常信息。
				只有当page指令的isErrorPage属性值
				为true时才能使用。
	  page　　jsp实例本身。
		
### 4)指令
	a.什么是指令?
	  告诉容器，在将jsp文件转换成servlet(.java)时，做一些额外的处理，比如导包。
	b.page指令
	  import属性：导包。
	  contentType属性：设置response.setContentType
				方法的参数值。
	  pageEncoding属性：设置jsp文件的编码。
	　 session属性：缺省值是true,如果值为false,则容器
				不再添加获得session对象的语句（即
				session隐含对象就不能用了）。  
	  errorPage属性:指定一个异常处理页面。
			注：当jsp运行时产生了异常，则容器会调用
			异常处理页面。
	  isErrorPage属性:缺省值是false,如果值为true,
				则可以使用exception隐含对象了。
	c.include指令
	
	   file属性：用来指定被包含的文件。
			<%@ include file="header.jsp"%>
	   注:
		  容器在将jsp文件转换成servlet(.java)时，会
		　将file属性指定的文件的内容插入到该指令所在的
		　位置。
	
	d.taglib指令
		uri	命名空间
		prefix
		注：用于导入jsp标签的。

### 5)注释 (a8.jsp)
	<!-- 注释内容 -->   如果是java代码，会执行。
	<%-- 注释内容 --%>  如果是java代码，不会执行。
	

## (3)jsp是如何运行的?
### step1.容器要将jsp文件转换成一个servlet(.java)
	html ---->  在service方法里，使用out.write输出。
	<%   %>--->	在service方法里，照搬。
	<%=  %>---> 在service方法里，使用out.print输出。
	<%!  %>--->	给servlet添加新的属性和方法。
### step2.容器再调用该servlet。


# 2. jsp标签和el表达式
## (1)什么是jsp标签?
	jsp标签语法类似于html标签，由于替换jsp文件当中的
	java代码。
	注:
		直接在jsp当中写java代码，不利于jsp文件的维护(比如,将带有java代码的jsp文件交给美工去修改就很不方便),所以,sun制订了jsp标签技术规范。
		容器依据jsp标签找到对应的标签类然后执行。

## (2)什么是el表达式?
	　一套简单的运算规则，用于给jsp标签的属性赋值。
	注：现在el表达式也可以脱离jsp标签，直接使用。

## (3)el表达式的使用
### 1)访问bean的属性
	注:
		javabean(了解)
		public class
		public 构造器
		属性
		get/set方法
####　方式一  (e1.jsp)
	 ${user.username} 
		执行过程: 
				容器依次从pageContext,request,
				session,application中查找绑订名为
				"user"的对象(getAttribute)，找到
				之后，会调用该对象的"getUsername"
				方法，然后输出。
		优点:	
				会将null转换成""输出。
				如果找不到对应的对象，并不会发生空指针异常。
		指定查找范围:	
				可以通过pageScope,requestScope,
				sessionScope,applicationScope
				指定查找范围。

#### 方式二  (e1.jsp)
	${user['username']}
		执行过程:  同上。
		特点:
				[]里面可以使用绑订名。
				[]里面可以使用从０开始的下标，用于
				访问数组中的某个元素。

### 2)进行一些简单的运算。 (e2.jsp)
	a. 算术运算: +,-,*,/,%
		注:
			"+"只能求和。
	b. 关系运算: >,>=,<,<=,==,!=
	c. 逻辑运算: &&,||,!
	d. empty: 判断集合是否为空，或者是否为空字符串。
		
### 3)读取请求参数值　(e3.jsp)
	${param.username}
	等价于
		request.getParameter("username");
	${paramValues.city}
	等价于
		request.getParameterValues("city");

## (4)jstl (java standard tag lib)
### 1)jstl是什么?
	apache开发的一套jsp标签，后来捐献给了sun,
	sun将其命名为jstl。
### 2)编程步骤
	step1.导包。
	step2.使用taglib指令导入要使用的标签。
		<%@ taglib uri="" prefix=""%>
		uri属性：用来指定要导入的标签的命名空间。
		注：
			命名空间：为了区分同名的元素而在元素前
			添加的一个限定，通常是一个域名。
		prefix属性：命名空间的别名。	
	
	
MVC(Model View Controller)模型 视图 控制器

概念

	MVC是一种软件架构思想，核心是我们在设计一个软件的时候，
	应该将数据的处理和展现分开，即业务逻辑由模型来处理，
	表示逻辑由视图来处理，用户通过视图将请求发送给控制器，
	由控制器选择对应的模型处理，模型将处理结果交给控制器，
	由控制器选择对应的视图来展现
					
	
### 3)核心标签
	a.if标签  (c1.jsp)
		<c:if test="" var="" scope="">
			标签体
		</c:if>
		注:
			当test属性值为true,容器执行标签体的内容。
			test属性可以使用el表达式来赋值。
			var属性指定绑订名。
			scope属性指定绑订范围("page","request",
				"session","application")。
![](if.png)
	
	b. choose标签 (c2.jsp)

	<c:choose>
		<c:when test="${user.age<18 }">少年</c:when>
		<c:when test="${user.age>80 }">老年</c:when>
		<c:otherwise>中年</c:otherwise>
	</c:choose>
		注:
			when标签可以出现1次或者多次，otherwise
			标签可以出现0次或者1次。
			当test属性值为true时，执行标签体的内容。
	c.forEach  (c3.jsp)
		<c:forEach items="" var="" varStatus="">
		</c:forEach>
		注:
			该标签用于遍历集合或者数组。
			items属性用于指定要遍历的集合或者数组，
				可以使用el表达式赋值。
			var属性用于指定绑订名（绑订范围固定是
				pageContext,每次从集合或者数组中
				取一个元素，然后绑订到pageContext）。
			varStatus属性用于指定绑订名(绑订范围固定是pageContext,
				绑订值是一个特殊的对象，该对象用于获得当前遍历的状态，
				比如getIndex方法用于获得当前正在被
				遍历的元素的下标(从0开始),getCount
				方法用于获得当前正在被遍历的元素的顺序（从1开始）。
		
	d.标签的执行过程
		容器依据命名空间找到标签的描述文件(.tld文件), 然后依据标签名(比如if标签)找到对应的标签类
		(比如找到IfTag类)然后将该标签类实例化，最后
		执行该标签类的方法。

# 2. 自定义标签(扩展)
## (1)编程步骤
	step1.写一个java类，继承SimpleTagSupport类。
	注(了解):
		jsp标签技术分为复杂标签技术(old),简单标签
		技术(new)。
	step2.override doTag方法。
		注：
			在该方法里面，写上处理逻辑。
	step3.配置标签。
		注：
			在.tld文件当中配置标签。
			.tld文件应该放到WEB-INF文件夹下面。

## (2)标签类代码
	public class HelloTag extends SimpleTagSupport{
	
	/*
	 * 标签的属性名与标签类的属性名应该保持一致(
	 * 属性名相同，类型要匹配), 并且有对应的set方法。
	 */
	private String info;
	private int qty;
	
	public HelloTag(){
		System.out.println("HelloTag构造器");
	}
	
	public void setInfo(String info) {
		System.out.println("setInfo方法:" + info);
		this.info = info;
	}

	public void setQty(int qty) {
		System.out.println("setQty方法:" + qty);
		this.qty = qty;
	}
	

	@Override
	public void doTag() throws JspException, IOException {
		System.out.println("doTag方法");
		/*
		 * 通过继承自SimpleTagSupport类提供的方法
		 * 来获得pageContext(该对象提供了获得其它
		 * 所有隐含对象的方法)。 
		 */
		PageContext pctx =
				(PageContext)getJspContext();
		JspWriter out = pctx.getOut();
		
		for(int i = 0; i < qty; i ++){
	          out.println(info + "<br/>");
	    }
		}
	
	}

## (3)标签配置
	<tag>
    <name>hello</name>
    <tag-class>tag.HelloTag</tag-class>
    <!-- 
    	empty：  
    			没有标签体。
    	scriptless： 
    			有标签体，但是，标签体的内容不能够
    			出现任何java代码(<% %>,<%! %>,<%= %>)。
    	JSP:
    			有标签体，标签体的内容可以出现java代码。
    			但是，只有复杂标签技术支持。
     -->
    <body-content>empty</body-content>
    <attribute>
        <name>info</name>
        <!-- false表示可选,true表示必选 -->
        <required>true</required>
        <!-- 
        	true表示可以动态赋值(el表达式赋值)
         -->
        <rtexprvalue>false</rtexprvalue>
    </attribute>
    <attribute>
    	<name>qty</name>
    	<required>true</required>
    	<rtexprvalue>true</rtexprvalue>
    </attribute>
  	</tag>	


# 3.MVC (Model,View,Controller)
## (1)MVC是什么?
	MVC是一种软件架构思想，核心是，我们在设计一个
	软件的时候，应该将数据的处理与数据的展现分开，
	即业务逻辑由模型来处理，表示逻辑由视图来处理。
	用户通过视图将请求发送给控制器，由控制器选择
	对应的模型来处理；模型将处理结果交给控制器，由
	控制器选择对应的视图来展现。
## (2)在web应用当中，应该如何使用MVC?
![](mvc.png)
	


优秀的大型项目强调可测试性

MVC的优点
	
	a.方便测试
		将业务逻辑写在java类中，可以直接测试，
		如果写在servlet中，需要部署整个应用才可以测试	
	
	b.方便代码维护
		模型改变，不影响视图，视图改变，不影响模型
		
	c.方便分工协作

	
MVC框架

"yyyy-MM-dd HH:mm:ss E a"
		



class对象是java反射的入口。

java代码执行过程:

	JVM委托类加载读取.class文件的内容到方法区，
	在方法区当中创建一个对应的class对象(可以将该对象看作是.class文件在内存中的对应物)

class对象：

	Class clazz = Class.forName(className);

实例化：

	Object obj = clazz.newInstance();

查看有哪些方法：

	Method[] methods = clazz.getDeclaredMethods();

获取方法名：

	String methodName = m.getName();

调用方法：

	如果方法带参,做成对象数组传进去

		Object[] params = new Object[] {"balala"};

	有返回值

		returnVal = m.invoke(obj, params);

	不带参的方法，无返回值
	
		returnVal = m.invoke(obj, null);


过滤器是实现
tag是继承

注解
java类编译之后，java注解默认会被抹掉，(即字节码文件里没有该注解)
可以使用@Retention元注解告诉编译期，保留该注解(保留到运行时，即对象里面还有)

元注解

	是用来解释其他注解的注解

如果属性名为value可以简化不写
public String value();

MVC框架

基本思路
	
	MVC中，控制器主要负责两事件，依据请求路径调用对应模型处理
		依据模型返回处理结果调用对应视图来显示数据
		我们可以写一个通用的控制器，该控制器可以通过读取
		配置文件(该配置文件配置有请求路径与模型的对应关系，
		以及处理结果与视图的对应关系)来进行响应的处理
	注：
		在具体实现的时候，也可以将一些配置信息写在java注解里面。

# Spring
## (1)Spring是什么?

	spring是轻量级的开发框架；两大核心IOC和AOP；包含完成特定功能的子框架。

	开源的、用来简化企业级应用开发的应用开发框架。
	注:
		框架：就是高质量的软件半成品，即框架会
			把一些常用的、通用的功能事先写好，开发
			人员利用框架，就可以快速开发。

## (2)Spring的特点
		a.简化开发
			Spring会把一些复杂的api简化，比如，
		直接使用jdbc访问数据库，需要关注如何获取
		连接，关闭连接，处理异常等等细节，而使用
		springjdbc(是Spring中的一个模块,用来封装
		jdbc)来访问数据库，则不再需要考虑以上细节。
		b.解耦
			Spring帮我们管理对象之间的依赖关系，
		这样一来，对象之间的耦合度会大大降低，提高了
		软件的可维护性。
		c.集成其它的框架
			Spring可以集成其它的一些框架，比如可以
			集成mybatis（mybatis是一个用来访问数据库的框架）。集成之后，比直接使用mybatis要
			方便。

## (3)Spring容器	
### 1)Spring容器是什么?

	spring是轻量级的开发框架；两大核心IOC和AOP；包含完成特定功能的子框架。

	Spring框架中的一个核心模块，用来管理对象
	（包括对象的创建、销毁、对象之间的依赖关系的建立等等）	。
### 2)启动Spring容器。
####	step1.导包
			spring-webmvc
####	step2.添加Spring配置文件
		将applicationContext.xml文件添加到
		main/resources下。(文件名可改)
####	step3.添加一个java类(FirstSpring)
		在该类当中添加启动Spring容器的代码。

		String config = 
				"applicationContext.xml";
		/*
		 * ApplicationContext:是一个接口，定义了
		 * 容器所提供的方法。
		 * ClassPathXmlApplicationContext:是一个类，
		 * 实现了ApplicationContext接口。该类会依据
		 * 类路径去查看配置文件，然后启动Spring容器。
		 */
		ApplicationContext ac = 
			new ClassPathXmlApplicationContext(
					config);

jar和var的区别 

	离不开tomcat需要部署

### 3)让容器来创建对象
#### 方式一　无参构造器
		step1.为类添加无参构造器（缺省构造器）
		step2.在配置文件当中进行相应的配置。
		step3.启动spring容器，调用容器的方法来获得
			对象。
		
#### 方式二　静态工厂方法(了解)

	<!-- 
		让容器调用类的静态方法来创建一个实例。
		factory-method属性：用来指定静态方法名。
			
	 -->
	<bean id="cal1" class="java.util.Calendar" 
	factory-method="getInstance"/>

#### 方式三　实例工厂方法(了解)		
	<!-- 
		让容器调用某个对象的实例方法来创建一个实例。
		factory-bean属性：用来指定bean的id。
		factory-method属性：指定实例方法名。
	 -->
	<bean id="time1" factory-bean="cal1" 
	factory-method="getTime"/>

### 4)作用域
	a.默认情况下，容器对于某个bean的配置，只会创建一个实例。	
	b.如果将作用域设置为"prototype"，则每调用一次
		getBean方法，就会创建一个新的实例。

生命周期相关的方法

	init-method属性：指定初始化方法名

	destroy-method属性：指定销毁方法

注：

	1/容器关闭之前，会删除实例，在删除之前会调用该实例的destroy方法

	2/销毁方法只针对作用域为singleton的bean

延迟加载(了解)

	a.默认情况下，容器启动之后，会把作用域为singleton
	的bean实例化。

	b.如果将lazy-init属性值设置为true,则容器启动之后，对于作用域为singleton的bean,不再实例化了。


IOC:（重点）	Inversion Of Controll

	原来创建对象和管理对象的权利由应用程序负责，
	现在把创建对象和管理对象的权利交给Spring容器，
	我们把这种控制权的转移，叫控制反转。


	
DI	Dependency Injection

概念	依赖注入

	容器通过调用set方法或构造器来建立对象之间的依赖关系

	IOC是目标 DI是手段

## (3)set方法注入

	step1.添加set方法

public void setB(IB b) {this.b = b;}

	step2.在配置文件当中进行相应的配置:

	<bean id="a1" class="ioc.A">
		<property name="b" ref="c1"></property>
	</bean>

## (4)构造器注入
	step1.添加相应的带参的构造器。

public Restaurant(Waiter wt) {
		System.out.println("Restaurant的有参构造器");
		this.wt = wt;
	}

	step2.在配置文件当中进行相应的配置:
<!-- 
		constructor-arg元素用来配值构造器注入
		其中，index属性用来指定被注入的参数下标
	 -->
	<bean id="rest1" class="ioc.Restaurant">
		<constructor-arg index="0" ref="wt1"></constructor-arg>
	</bean>

## (5)自动装配(了解)

a.什么是自动装配?

	容器依据某种规则，自动建立对象之间的依赖关系。

	注:

	  	默认情况下，容器不会自动装配。
	　 	容器仍然需要调用set方法或者构造器。

b.如何自动装配?

	设置autowire属性值。

	autowire属性：

		让容器自动装配
		
	byName:

		容器以属性名为bean的id来查找对应的bean，
		找到之后，调用set方法完成注入
		
			注：
				如果找不到，不会注入
			
	byType:

		容器以属性类型作为bean的类型来查找对应的bean，
		找到后调用set方法完成注入
		
			注：
				如果找不到，不会注入
				如果找到多个，会报错
			
		constrctor：类似于byType,找到后调用构造器完成注入
	 -->
	<bean id="car" class="autowire.Car" autowire="byType"></bean>
	
	c.建议：如果要使用自动装配，尽量使用byName。

## (6)注入基本类型的值
	使用value属性注入。

	<property name="name" value="小柔"></property>

## (7)注入集合类型的值。
	Spring支持四种集合类型:List,Set,Map,Properties
### 1)方式一
	<bean id="vb1" class="basic.ValueBean">
		<property name="name" value="宝玉"/>
		<property name="age" value="18"/>
		<property name="interest">
			<list>
				<value>钓鱼</value>
				<value>做饭</value>
				<value>台球</value>
				<value>台球</value>
			</list>
		</property>
		<property name="city">
			<set>
				<value>北京</value>
				<value>东京</value>
				<value>南京</value>
			</set>
		</property>
		<property name="score">
			<map>
				<entry key="english" value="80"/>
				<entry key="math" value="70"/>
			</map>
		</property>
		<property name="db">
			<props>
				<prop key="username">Sally</prop>
				<prop key="pwd">test</prop>
			</props>
		</property>
	</bean>
### 2)方式二
	采用引用的方式注入集合类型的值　
![](s8.png)

<!-- 将集合类型的值配制成一个bean -->
	<util:list id="interestBean">
		<value>吸烟</value>
		<value>喝酒</value>
		<value>烫头</value>
	</util:list>
<property name="interest" ref="interestBean"></property>

## (8)读取properties文件的内容


读取properties文件的内容
location属性：指定要读取的文件的位置
注： 
	classpath:依据类路径去查找
	容器读取properties文件的内容，并把这些内容添加到properties对象里面

	 <util:properties id="config" location="classpath:config.properties">
	</util:properties>

时间格式：
y	年
M	月
d	日
a	上下午
H	时
m	分
s	秒

测试spring表达式
创建工程：

创建maven工程 web

添加web.mxl

添加tomat 运行环境

添加依赖 spring-webmvc，junit

添加配置文件：
开发步骤

1.编写：db.properties

url=jdbc:mysql://localhost:3306/dbName
username=root
password=root
driverClassName=com.mysql.jdbc.Driver
2.编写Demo类

public class Demo {
private String url;
private String username;
private String password;
private String driverClassName;
    setXX/getXX
}
3.编写:配置文件base.xml

<!-- 加载属性文件 -->
<util:properties id="dbConfig" 
    location="classpath:db.properties"/>

<!-- 通过无参的构造方法，创建Demo对象 -->
<bean id="demo" class="cn.tedu.spring.bean.Demo">
    <!-- 使用spring的表达式给属性赋值 -->
    <property name="url" value="#{dbConfig.url}"/>
</bean>

基于注解扫描的方式管理Bean
1.组件扫描：

定义一个包，spring扫描该包和其子包下的组件，如果这个组件上有特定的注解，spring就把这些组件纳入到spring容器。基于注解的方式创建对象等价于bean的配置文件。
2.定义扫描包的格式：

<context:component-scan 
    base-package="cn.tedu.spring"/>
3.创建对象的注解

@Component:可以给所有的类创建对象
@Controller:给控制器层创建对象
@Service：给业务层创建对象
@Repository:给dao层创建对象
练习：定义UserDao类

//@Repository创建持久层对象，
//id值默认为类名的第一个字母小写
@Repository
public class UserDao {

    public void addUser(){
        System.out.println("添加数据成功！");
    }

}
测试：

4.管理bean的生命周期，bean的作用域，延迟加载

@Component("beanLife")
//@Scope("prototype")定义bean的作用域为多例；
//默认是单例（singleton）
@Scope("singleton")
//@Lazy(true)定义bean对象是否延迟加载
@Lazy(true)
public class BeanLife {
//@PostConstruct定义初始化的方法
@PostConstruct
public void init(){
    System.out.println("BeanLife-init");
}
//@PreDestroy定义销毁对象的方法
@PreDestroy
public void destroy(){
    System.out.println("BeanLife-destroy");
}

}
5.依赖注入（DI）

1）@Resource

//实例化service
@Service
public class UserService {
//1.@Resource完成依赖注入，可以省略set/get方法
//2.@Resource默认注入方式为：byName;
//3.如果没有匹配的名称，按照byType进行依赖注入;
//4.@Resource也可以设置获取bean的名称，
//@Resource(name="udao")
//5.推荐使用@Resource
@Resource(name="udao")
private UserDao userDao;

public void handler(){
    userDao.addUser();
}



2）@AutoWired

@Service
public class UserService2 {
//@Autowired完成依赖注入的功能；
//默认的依赖注入方式：byType;
//可以使用byName实现依赖注入,
//要依赖一个@Qualifier("udao")注解，指定名称

@Autowired
@Qualifier("udao")
private UserDao userDao;

public void handler2(){
    userDao.addUser();
}

}
6.@Value注解的使用：给基本数据类型和String类型的成员吧变量赋值的

1)在src/main/resources文件夹下，创建studdent.properties；文件内容如下：
student.properties
name=Admin
age= 20

2）在base.xml配置文件中配置：
<util:properties id="stuConfig" location=".."/>

3）定义Student类
public class Student{
    @Value("#{stuConfig.name}")
    private String name ;

    public String getName(){
        return name;
    }
}

4)在测试类中定义测试方法，测试
【小结】
1.spring容器实例化对象的两种方式：基于配置文件；基于注解

2.组件扫描,在bean.xml配置文件中以下配置

<context:component-scan base-package="xx.xx"/>
3.实例化Bean组件的注解

@Component:通用注解
@Controller:控制器对象的实例化注解
@Service：业务层对象的实例化注解
@Repository:持久层对象的实例化注解
4.依赖注入的注解

@Resource：
    1）定义到属性上边
    2）默认是以byName方式进行注入；
    3）如果没有找到相同的属性名，那么byType实现依赖注入
    4）@Resource(name="udao")可以通过此种方式，通过byName实现依赖注入
5.了解

1）@PostContruct:定义bean的初始化方法
2）@PreDestory:定义bean的销毁方法
3）@Scope：定义bean的生命周期
4）@Lazy：定义bean的延迟加载
5）@Autowired:依赖注入
6) @Qualifier:和@Autowired一起使用，定义bean名字
7）@Value：给基本数据类型和String类型的变量赋值
8）Spring的表达式 #{}

【回顾】
1.实例化对象两种方式：配置文件和注解

2.扫描包：

<context:component-scan base-package="xx.xx"/>
3.实例化对象的注解

@Component
@Controller
@Service
@Repository
4.依赖注入：

@Resource
5.了解注解

@Scope
@Lazy
@PostConstruct
@PreDestroy
@Autowired
@Qualifier
@Value
@spring 表达式 
MVC
1.M-Model:处理业务逻辑（xxService,xxDao）

2.V-View:呈现给客户端的页面（*.jsp）

3.C-Controller:是Model和View之间的桥梁；接收客户端的数据，调用model层方法，由控制器决定响应的视图。

Spring-mvc
1.概述：spring-mvc是spring的一个子框架；实现了MVC的设计架构，方便了开发mvc架构的程序；提供了一套API把web应用的核心功能，精细化到制定模块。简化开发过程，提高开发效率。

2.作用：从view-controller，再从controller-view，简化过程开发。



5大组件
1.DispatcherServlet：核心控制器，也叫前端控制器

2.HandlerMapping:处理映射关系

3.Controller：业务逻辑控制器

4.ModelAndView：控制器的方法返回类型

5.ViewResolver:视图解析器

spring-mvc的工作流程
1.发送请求给前端控制器DispatcherServlet.

2.调用了HandlerMapping,获取url映射名。

3.调用Controller类，调用方法，处理控制器业务。包含接收请求参数，调用业务层方法，把视图和视图需要的数据，封装到ModelAndview,把该对象返回。

4.调用视图解析器，把ModelAndView解析完成，响应视图到客户端。

Hello Spring-MVC 基于配置文件
1.搭建环境

创建web工程
添加web.xml
添加tomcat运行环境
添加依赖jar包（spring-webmvc，junit）
添加配置文件spring-mvc.xml
2.编写web.xml，配置DispatcherServlet.

<servlet>
    <servlet-name>dispatcherServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <!-- DispatcherServlet读取配置文件，完成spring容器的初始化 -->
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:spring-mvc.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
     <servlet-name>dispatcherServlet</servlet-name>
     <url-pattern>*.do</url-pattern>
</servlet-mapping>
测试：定义Bean类User，在构造方法中编写输出语句。

3.编写UserController类

public class HelloController implements Controller{

public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
    // TODO Auto-generated method stub
    return null;
}

}
4.使用HandlerMapping，配置映射

<bean id="handlerMapping" class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
    <property name="mappings">
        <props>
            <prop key="/hello.do">helloController</prop>
        </props>
    </property>
</bean>
5.ModelAndView

public class HelloController implements Controller{

public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
    System.out.println("HelloController:handleRequest");
    ModelAndView mv = new ModelAndView("hello");
    return mv;
}

}
6.配置视图解析器ViewResolver

<bean id="viewResolver"
class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <property name="prefix" value="/WEB-INF/"/>
    <property name="suffix" value=".jsp"></property>
</bean>
测试：http://localhost:8080/spring-mvc-day04-01/hello.do

练习：http://localhost:8080/spring-mvc-day04-01/login.do，显示login.jsp，页面的内容：登录页面。

hello spring-mvc 基于注解的方式（重点）
1.搭建工程

新建web工程
添加web.xml
添加tomcat运行环境
添加依赖jar
添加配置文件spring-mvc.xml
2.在web.xml中配置DispatcherServlet

<servlet>
    <servlet-name>dispatcherServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>

    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:spring-mvc.xml</param-value>
    </init-param>

    <load-on-startup>1</load-on-startup>

  </servlet>
  <servlet-mapping>
    <servlet-name>dispatcherServlet</servlet-name>
    <url-pattern>*.do</url-pattern>
  </servlet-mapping>
3.编写Controller

//1.不用实现Controller接口
//2.方法的定义：方法的返回类型可以为String
//             方法名可以按需求自定义
//             参数列表可以为空
@Controller
public class HelloController {

    public String showHello(){
        return null;
    }
}
4.配置映射

@Controller
public class HelloController {
    //映射路径，此注解配置到哪个方法上边，那么请求该
    //URL是，就执行哪个方法
    @RequestMapping("/hello.do")
    public String showHello(){
        return null;
    }
}
5.ModelAndView

@Controller
public class HelloController {
    //映射路径，此注解配置到哪个方法上边，那么请求该
    //URL是，就执行哪个方法
    @RequestMapping("/hello.do")
    public String showHello(){
        //spring-mvc会把字符串封装成ModelAndView对象
        return "hello";
    }
}
6.配置视图解析器

<bean id="viewResolver" 
class="org.springframework.web.servlet.view.InternalResourceViewResolver">

    <property name="prefix" value="/WEB-INF/"/>
    <property name="suffix" value=".jsp"/>
</bean>
测试：http://localhost:8080/spring-mvc-day04-02/hello.do

@RequestMapping
//1.@RequestMapping可以定义到类上边；表示请求URL时的二级路径
//例如：http://localhost:8080/spring-mvc-day04-02/demo/test.do
//2.@RequestMapping可以定义到方法上，表示url的映射名
@Controller
@RequestMapping("/demo")
public class DemoController {
@RequestMapping("/test.do")
public String test(){
    return "hello";
}

}
注意：如果想改变页面的文件存放的位置有两种方式；第一种在spring-mvc.xml文件中拼接prefix的值<property name="prefix" value="/WEB-INF/web/"/>；第二种在控制器方法的返回值，拼接return "web/test";

补充

<mvc:annotation-driven/>;功能更加强大
【小结】
1.Spring-mvc：spring 的子框架；实现了mvc设计架构；强大的api封装web的主要功能。

2.作用：从view到controller，从controller到view的过程

3.5大组件

DispatcherServlet:前端控制器
HandlerMapping：封装了url
Controller：业务逻辑控制器
ModelAndView:封装了视图和Model数据
ViewResolver：视图解析器
4.基于注解的spring-mvc web应用

在web.xml中配置DispatcherServlet;实际初始化spring容器。
@Controller
public class UserController{
    @RequstMapping("/login.do")
    public String login(){
        //....
        return "hello";
    }
    @RequstMapping("/getUser.do")
    public String getUser(){

    }
}

在spring-mvc.xml中，配置视图解析器
4.@RequestMapping

使用方式有两种：一种配置到方法上：表示映射名；第二种配置方式，配置到类上边，表示二级路径，在url上映射路径的前边；
5.<mvc:annotation-driver/>


#[回顾]

1.页面-->控制器

1）request（不建议使用）

2）属性  @RequestParam("pwd") String password

3) 封装成Bean对象

2.控制器-->页面

1）request,session(不建议使用)

2) ModelAndView(request)

3) ModelMap(request)（建议使用）

3.转发和重定向

1）默认转发:拼字符串

2）return "redirect:XX.do/XX.jsp"

3) return "forward:XX.do/XX.jsp"

# 乱码处理：

1.页面:

	<%@ page contentType="text/html; charset=utf-8" pageEncoding="utf-8"%>

2.控制器：
	
	1）post：使用spring提供CharacterEncodingFilter类设置utf-8;在web.xml中配置
	
	 <!-- 处理post请求的乱码的过滤器 -->
	  <filter>
	  	<filter-name>encodingFilter</filter-name>
	  	<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
	  	<init-param>
	  		<param-name>encoding</param-name>
	  		<param-value>UTF-8</param-value>
	  	</init-param>
	  </filter>
	  <filter-mapping>
	  	<filter-name>encodingFilter</filter-name>
	  	<url-pattern>/*</url-pattern>
	  </filter-mapping>

	2）get请求乱码处理方式：在tomcat的conf文件夹中server.xml中配置URIEncoding="UTF-8"

	 <Connector URIEncoding="utf-8" connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443"/>

3.数据库：安装时选择编码utf8;	在数据库连接时,设置以下属性

	url=jdbc:mysql://localhost:3306/test_db?useUnicode=true&characterEncoding=utf8

	表create table xxName()default charset=utf8

# 异常处理

1.基于配置文件的方式处理异常

	在spring-mvc.xml中配置异常处理器对象

	<bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
		<property name="exceptionMappings">
			<props>
				<!-- 映射异常类型和页面的关系 -->
				<prop key="java.lang.Exception">error</prop>
			</props>
		</property>
	</bean>

	在WEB-INF文件夹下，新建一个error.jsp	

2.基于注解
	
	//@ControllerAdvice处理整个应用的所有的控制器异常
	@ControllerAdvice
	public class SpringMVCException {
		//@ExceptionHandler表示处理所有的异常类型
		@ExceptionHandler
		public String handleException(
				Exception e,HttpServletRequest request){
			
			request.setAttribute("errorMsg",e.getMessage());
			return "error";
		}
	
	}

	<body style="font-size:30px;">
	页面错误，请联系管理员！<br>
	系统异常信息：${errorMsg}
	</body>

# 拦截器

1.拦截器的定义

	//实现了HandlerInterceptor接口的类，叫拦截器类
    public class LoginIntercepter implements HandlerInterceptor{
	//在请求控制器方法之前执行，如果返回false，那么不能执行到控制器方法
	//返回true，请求继续执行，会到达控制器方法。
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
			throws Exception {
		System.out.println("preHandle");
		return false;
	}
	//执行完控制器方法之后，响应视图之前
	public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
			ModelAndView modelAndView) throws Exception {
		System.out.println("postHandle");
		
	}
	//响应页面之后执行
	public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
			throws Exception {
		System.out.println("afterCompletion");
		
	}

    }

2.配置拦截器

	<!-- 配置拦截器 -->
	<mvc:interceptors>
		<mvc:interceptor>
			<!-- 配置拦截的资源 拦截所有资源使用 (/**)-->
			<mvc:mapping path="/user/*"/>
			<!-- 不拦截的资源 -->
			<mvc:exclude-mapping path="/user/showLogin.do"/>
			<mvc:exclude-mapping path="/user/login.do"/>
			<mvc:exclude-mapping path="/user/exit.do"/>
			<!-- 实例化拦截器对象 -->
			<bean class="cn.tedu.springmvc.intercepter.LoginIntercepter"/>
		</mvc:interceptor>
	</mvc:interceptors>

3.案例：登录拦截器

	在拦截器的preHandle方法中处理拦截的代码

	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
			throws Exception {
		System.out.println("preHandle");
		//获取session的user对象
		Object obj = 
				request.getSession().getAttribute("user");
		if(obj==null){
			//login.jsp
			//如果user对象为null，那么转发到login.jsp
			request.getRequestDispatcher("/WEB-INF/login.jsp").forward(request, response);
			return false;
		}
		
		return true;
	}


# 用户管理模块-登录模块

## 1.数据库设计
## 2.创建工程环境
## 3.持久层

1.编写配置文件

2.配置数据库的连接池

3.新建User类

4.在cn.tedu.springmvc.dao包中，新建UserDao接口，接口中定义方法

	public interface UserDao{
		User selectUserByNameAndPwd(String username,String password);
	}

5.在cn.tedu.springmvc.dao包中，新建UserDaoImpl类，实现UserDao接口
	
	@Repository
	public class UserDaoImpl implements UserDao{
		@Resource
		private DataSource dataSource;
		public User selectUserByNameAndPwd(String username,String password){
			Connection conn = dataSource.getConnection();

		}
	}


测试：

## 4.业务层

1.在cn.tedu.springmvc.service包，新建UserService接口，在接口中定义方法

	public inteface UserService{
		User getUserByNameAndPwd(String username,String password);
	}

2.1.在cn.tedu.springmvc.service包，新建UserServiceImpl实现类，实现接口中的方法
	
	@Service
	public class UserServiceImpl implements UserService{
		@Resource
		private UserDao userDao;
		public User getUserByNameAndPwd(String username,String password){
			//返回持久层的方法返回值
			return userDao.selectUserByNameAndPwd(username,password);
		}
	}

3.复制spring-mvc.xml,改名spring-service.xml;
在spring-service.xml中配置组件扫描`<context:component-scan 
		base-package="cn.tedu.springmvc.service"/>`

测试：注意：初始化spring容器时，读`spring-service.xml`和`spring-dao.xml`配置文件

##5.控制器

1.显示视图login.jsp

在cn.tedu.springmvc.controller包中，新建UserController类，在类定义方法showLogin

	@Controller
	@RequestMapping("/user")
	public class UserController{
		@RequestMapping("/showLogin.do")
		public String showLogin(){
			return "login";
		}
	}

在WEB-INF文件夹中定义login.jsp

测试：

2.在控制器类中定义login，由此方法处理登录请求
	
	@Resource
	private UserService userService;
	
	@RequestMapping("/login.do")
	public String login(String name,String pwd,ModelMap map){

		1.调用业务层方法,getUserByNameAndPwd(name,pwd);方法会返回User对象

		2.user==null,响应页面login.jsp,在login.jsp页面显示信息:用户名或密码错误

		3.user!=null,响应页面index.jsp，在页面上显示：登录成功。

	}

在login.jsp的form的action="${pageContext.request.contextPath}/user/login.do"



【回顾】
1.乱码

1) 页面 @page

2）post：在web.xml中 CharacterEncodingFilter get：在服务器端的server.xml中配置 URIEncoding="UTF-8"

3) 数据库

安装选择utf8;jdbc:mysql://localhost:3306/test_db?useUnicode=true&characterEncoding=utf8;
create table t_user()defaut charset=utf8
2.异常

1) 配置文件 ：SimpleMappingExceptinResolver

2）注解: @ExceptionHandler @ControllerAdvice

3.拦截器

1)拦截器的定义：HandlerIntercetptor

2）配置

Mybatis ibatis
1.持久层的框架，支持普通sql，存储过程（项目）

2.封装了jdbc的底层api-——————新的api（框架）SqlSession

3.提供xml和注解编写sql

使用框架
1.新建工程

创建web项目
添加web.xml
添加tomcat运行环境
添加依赖：mybatis mysql junit
2.配置mybatis框架

1）新建实体类User

public class User implements Serializable{

private static final long serialVersionUID = -6189649540294400759L;
private Integer id;
private String username;
private String password;
private String address;
private String phone;
    //....
}
2) 提供配置文件，和链接数据库相关的信息

<environments default="environment">
        <environment id="environment">
            <transactionManager type="JDBC" />
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver" />
                <property name="url"
                    value="jdbc:mysql://localhost:3306/test_db" />
                <property name="username" value="root" />
                <property name="password" value="root" />
            </dataSource>
        </environment>
    </environments>
    <!-- 配置映射文件 -->
    <mappers>
        <mapper resource="mappers/UserMapper.xml" />

    </mappers>
3）提供映射文件，配置sql语句

<!-- namespace定义命名空间的名字 ，
    不能和其他的namespace名称相同
-->
<mapper namespace="userDao">

    <!-- public void insertUser(User user) -->
    <!-- insert节点定义insert语句
         id表示给节点起名字，名字唯一
         parameterType表示传入的参数
     -->
    <insert id="addUser" 
        parameterType="cn.tedu.mybatis.bean.User">

        insert into t_user (
            username,password,address,phone
        ) values(
            #{username},#{password},#{address},#{phone}
        )

    </insert>

    <!-- public void updateUser(User user)  -->
    <update id="updateUser" 
    parameterType="cn.tedu.mybatis.bean.User">
        update 
            t_user
        set
            username=#{username},password=#{password},
            address=#{address},phone=#{phone}
        where
            id=#{id}

    </update>

    <!-- 
        void deleteUser(Integer id) 
        8种基本数据类型和String类型的变量作为方法的参数，
        可以省略parameterType；
        如果不省略那么:parameterType="java.lang.Integer"
    -->
    <delete id="delUser" >
        delete 
            from t_user
        where
            id=#{id}
    </delete>

    <!-- 
        User selectById(Integer id) 
        resultType表示记录封装的对象的实体类类型
    -->
    <select id="getUser" 
    resultType="cn.tedu.mybatis.bean.User">
        select *
        from 
            t_user
        where
            id=#{id}
    </select>

    <!-- List<User> selectAll() -->
    <select id="getAll" 
        resultType="cn.tedu.mybatis.bean.User">
        select *
        from t_user 
    </select>

</mapper>
3.使用mybatis框架api实现插入的操作
  
			
1）定义dao层接口UserDao，定义UserDaoImpl

public interface UserDao {
void insertUser(User user);
//根据ID修改username,password,address,phone
void updateUser(User user);
void deleteUser(Integer id);
User selectById(Integer id);
List<User> selectAll();
}
2) 接口的实现类

public class UserDaoImpl implements UserDao{

public void insertUser(User user) {
    //2.SqlSession对象
    SqlSession session =
            SqlSessionUtil.getSession();

    //3.session提供的方法
    //第一个参数：namespace+id
    session.insert("userDao.addUser", user);
    //提交事务
    session.commit();
    //关闭session
    session.close();
}

public void updateUser(User user) {

        //2.SqlSession对象
        SqlSession session = SqlSessionUtil.getSession();

        session.update("userDao.updateUser", user);
        session.commit();
        session.close();

}

public void deleteUser(Integer id) {
    SqlSession session = 
            SqlSessionUtil.getSession();
    session.delete("userDao.delUser", id);
    session.commit();
    session.close();

}

public User selectById(Integer id) {
    SqlSession session = 
            SqlSessionUtil.getSession();
    User user = session.selectOne("userDao.getUser", id);
    session.close();
    return  user;
}

public List<User> selectAll() {
    SqlSession session =
            SqlSessionUtil.getSession();
    List<User> list =
            session.selectList("userDao.getAll");
    return list;
}
}
测试：

使用mybatis-基于Mapper映射器（重点）
1.创建工程：（1-4）参考上一个工程

2.建表 t_address

create table t_address(
    id int auto_increment primary key,
    province varchar(50),
    city varchar(50),
    area varchar(50),
    user_address varchar(100)
)default charset=utf8
3.新建实体类：Address

public class Address implements Serializable{
private static final long serialVersionUID = 4813812594068258454L;
private Integer id;
private String province;
private String city;
private String area;
private String userAddress;
    //....
}
4.配置mybatis框架：（SqlConfig.xml,XXMapper.xml）

5.编写接口AddressDao

public interface AddressDao {
//添加地址信息
Integer insertAddress(Address address);
//修改地址信息
Integer updateAddress(Address address);
//删除地址信息
Integer deleteAddress(Integer id);
//根据id查询地址信息
Address selectById(Integer id);
//查询所有的地址信息
List<Address> selectAll();

}
6.通过映射文件配置crud的操作

<!-- mapper节点的namespace值必须和接口名相同 -->
<mapper namespace="cn.tedu.mybatis.dao.AddressDao">
<!-- 
添加地址信息
Integer insertAddress(Address address);
 -->
 <insert id="insertAddress" 
    parameterType="cn.tedu.mybatis.bean.Address">

    insert into t_address(
        province,city,area,user_address
    )values(
        #{province},#{city},#{area},#{userAddress}
    )

 </insert>
 <!-- 
    修改地址信息
    Integer updateAddress(Address address);
  -->
 <update id="updateAddress" 
 parameterType="cn.tedu.mybatis.bean.Address">
    update t_address
    set
        province=#{province},city=#{city},
        area=#{area},user_address=#{userAddress}
    where
        id=#{id}
 </update>

 <!-- 
 删除地址信息
Integer deleteAddress(Integer id);
  -->
<delete id="deleteAddress" >
    delete from t_address
    where id=#{id}

</delete>

<!-- 
根据id查询地址信息
Address selectById(Integer id);
如果字段名和实体类的属性名不相同，
那么给列起别名，别名和实体类的属性名相同
 -->
<select id="selectById" 
resultType="cn.tedu.mybatis.bean.Address">
    select 
         id,province,city,area,
         user_address userAddress       
    from 
        t_address
    where
        id=#{id}
</select>
<!-- 
查询所有的地址信息
List<Address> selectAll();
 -->

<select id="selectAll" resultMap="addressMap">
    select * from t_address;

</select>

 <!-- 映射了表的列和类的属性之间的关系 -->
 <resultMap type="cn.tedu.mybatis.bean.Address" 
    id="addressMap">
    <id column="id" property="id"/>
    <result column="province" property="province"/>
    <result column="city" property="city"/>
    <result column="area" property="area"/>
    <result column="user_address" property="userAddress"/>
 </resultMap>


</mapper>
测试类：

public class TestMapper {
@Test
public void testSelectAll(){
    SqlSession session = 
            SqlSessionUtil.getSession();
    AddressDao addressDao = 
            session.getMapper(AddressDao.class);
    System.out.println(
            addressDao.selectAll());

}
@Test
public void testSelectById(){
    SqlSession session = 
            SqlSessionUtil.getSession();
    AddressDao addressDao = 
            session.getMapper(AddressDao.class);
    System.out.println(
            addressDao.selectById(1));
}
@Test
public void testDelete(){
    SqlSession session = 
            SqlSessionUtil.getSession();
    AddressDao addressDao = 
            session.getMapper(AddressDao.class);
    System.out.println(
            addressDao.deleteAddress(2));
    session.commit();
    session.close();
}
@Test
public void testUpdate(){
    SqlSession session = 
            SqlSessionUtil.getSession();
    AddressDao addressDao = 
            session.getMapper(AddressDao.class);
    Address address = new Address();
    address.setId(2);
    address.setProvince("北京2");
    address.setCity("市辖区2");
    address.setArea("海淀区2");
    address.setUserAddress("中鼎大厦7层2");
    addressDao.updateAddress(address);
    session.commit();
    session.close();
}
@Test
public void testInsert(){
    SqlSession session = 
            SqlSessionUtil.getSession();
    AddressDao addressDao = 
            session.getMapper(AddressDao.class);
    Address address = new Address();
    address.setProvince("北京");
    address.setCity("市辖区");
    address.setArea("海淀区");
    address.setUserAddress("中鼎大厦7层");
    System.out.println(
            addressDao.insertAddress(address));
    session.commit();
    session.close();

}
}

【小结】
1.Mybatis的使用

2.XXMapper.xml

1) mapper节点中namespace属性的值必须和接口名相同（接口的完整路径 ）

2）insert update delete select 四个节点中id属性，值必须和接口中的方法名形同

3）当查询操作时，表字段名和类的属性名不相同；由两种解决方案：第一种，给列起别名；第二种,配置resultMap

3.SqlSession getMapper();

AbstractApplicationContext  ac =  
	new ClassPathXmlApplicationContext("spring-dao.xml");

ac代表的是spring框架

bean中基本类型使用包装类是为了防止数据库返回的是null


【回顾】
1.mybatis框架：持久层，支持sql和存储过程，封装jdbc；xml编写sql语句

2.映射文件：

1）mapper namespace="xx.xx.接口名称"

2) <insert>,<update>,<delete>,<select>

3) 以上4个节点中，id="方法名"

4）以上4个节点中，parameterType="xx.xx.实体类名"表示传入的参数；如果基本数据类型或者字符串类型，可以省略。否则要填写实体类的名字

5）<insert><update><delete> 没有resultType；

6）<select>中的resultType属性：记录封装的实体类类型

3.字段名和属性名不相同时，在查询操作时，有两种方案：第一种给字段起别名；第二种使用

<resultMap id="userMap" type="xx.xx.User">
    <id column="" property=""/>
    <result column="" property="">  

</resultMap>

<select id="" resultMap="userMap"></select>
ssm整合
1.新建工程
1.创建web项目

2.添加web.xml

3.添加tomcat运行环境

4.设置包结构

1）cn.tedu.ssm.bean
2) cn.tedu.ssm.controller
3) cn.tedu.ssm.service
4) cn.tedu.ssm.mapper
5.配置依赖jar

spring-webmvc
junit
mybatis
mybatis-spring
mysql
commons-dbcp
spring-jdbc
jstl
6.关于配置文件

1）spring-mvc.xml
2) spring-service.xml
3) spring-dao.xml

<!-- 配置属性文件 -->
<util:properties id="db" 
        location="classpath:db.properties"/>

<!-- 配置数据库的连接池 -->
<bean id="dataSource" 
    class="org.apache.commons.dbcp.BasicDataSource">
    <property name="url"
             value="#{db.url}"/>
    <property name="username" 
            value="#{db.username}"/>
    <property name="password" 
            value="#{db.password}"/>
    <property name="driverClassName" 
            value="#{db.driverClassName}"/>
</bean>
<!-- 以下两个bean，完成spring和mybatis的整合 -->
<!-- 配置 MapperScannerConfigurer，配置接口的扫描包-->
<bean 
class="org.mybatis.spring.mapper.MapperScannerConfigurer">
    <property name="basePackage" 
        value="cn.tedu.ssm.mapper"/>
</bean>
<!-- 实例化 SqlSessionFactory-->
<bean id="sqlSessionFactory" 
class="org.mybatis.spring.SqlSessionFactoryBean">
    <property name="dataSource" ref="dataSource"/>
    <property name="mapperLocations"
        value="classpath:mappers/*.xml"/>
</bean> 

4) db.properties
5) mappers/xxMapper.xml
7.在web.xml中配置DispatcherServlet,CharaterEncodingFilter

2.创建表
create table t_dept(
    id int auto_increment primary key,
    dept_name varchar(30),
    dept_address varchar(50)
)default charset=utf8
3.部门管理-添加部门信息
1.持久层

1.创建Dept类

public class Dept implements Serializable{
private static final long serialVersionUID = 8915715666324670320L;
private Integer id;
private String deptName;
private String deptAddress;
    //无参，全参构造方法
    //set/get方法
    //重写hashCode和equals，toString方法
    //实现序列化接口
    //添加序列化的id
}
2.创建接口DeptMapper

public interface DeptMapper{
    void insertDept(Dept dept);
}
3.在DeptMapper.xml中，定义<insert>节点，完成insert语句

<insert id="insertDept"parameterType="cn.tedu.ssm.bean.Dept">

    insert into t_dept(
        dept_name,dept_address
    )values(
        #{deptName},#{deptAddress}
    )   

</insert>
测试：

2.业务层

1.创建DeptService,定义方法

public interface DeptService{
    void addDept(Dept dept);
}
2.创建接口的实现类，实现方法：调用持久层的方法

测试：

3.控制层

1.url定义

/showAdd.do     --显示add.jsp页面
请求参数：无
响应方式：转发

@Controller
@RequestMapping("/dept")
public class DeptController{
    @RequestMapping("/showAdd.do")
    public String showAdd(){
        return "add";
    }

}
在web下创建add.jsp

测试： http://localhost:8080/project/dept/showAdd.do

2.url添加按钮

/add.do
请求参数：name,address
响应方式：转发        index.jsp

@Resource
private DeptService deptService;

@RequestMapping("/add.do")
public String add(String name,String address){
    //1.调用业务层方法
    deptService.addDept(dept);
    //2.return "index";
}
在add.jsp页面

在web中，新建index.jsp页面

4.部门管理-显示所有部门
1.持久层

1.在DeptMapper接口中定义方法

List<Dept> selectAll();
2.在DeptMapper.xml中，编写select

<select id="" resultType="cn...Dept">
    select 
        id,dept_name deptName,
        dept_address deptAddress
    from 
        t_dept

</select>
测试：

2.业务层

1.在DeptService中定义方法

List<Dept> getAllDept();
2.在DeptServiceImpl类中，实现方法：调用持久层方法，返回list

测试：

3.控制器层

/getAllDept.do
请求参数：无
响应方式：请求转发         ---showDept.jsp
@RequestMapping("/getAllDept.do")
public String getAllDept(ModelMap map){
    //1.调用业务层方法，返回list
    //2.把list设置到map中
    //3.return "showDept";
}
在web中，新建showDept.jsp

测试：

4.页面

<c:forEach items="${list}" var="dept">
<tr>
  <td>${dept.id}</td>
  <td>${dept.deptName}</td>
  <td>${dept.deptAddress}</td>
</tr>
</c:forEach>
5.部门管理-删除
1.持久层

1.在DeptMapper接口中定义方法

void deleteDept(Integer id);
2.在DeptMapper.xml中，定义delete节点，编写delete语句

<delete id="">
    delete from 
        t_dept
    where
        id=#{id}
</delete>
测试：

2.业务层

1.在DeptService中定义方法

void delDept(Integer id);
2.在实现类中实现方法：调用持久层的方法

测试：

3.控制器

/deleteDept.do
请求参数：id
响应方式：重定向            ---getAllDept.do

@ReqeustMapping("/deleteDept.do")
public String deleteDept(Integer id){
    //1.调用业务层方法:delDept(id)
    //2.return "redirect:getAllDept.do"
}
4.页面

在showDept.jsp页面上，给删除添加链接：

 <a herf="${}/dept/deleteDept.do?id=${dept.id}">删除</a>  


[回顾]
1.ssm整合

<bean 
class="org.mybatis.spring.mapper.MapperScannerConfigurer">
    <property name="basePackage" 
        value="cn.tedu.ssm.mapper"/>
</bean>
<!-- 实例化 SqlSessionFactory-->
<bean id="sqlSessionFactory" 
class="org.mybatis.spring.SqlSessionFactoryBean">
    <property name="dataSource" ref="dataSource"/>
    <property name="mapperLocations"
        value="classpath:mappers/*.xml"/>
</bean> 
2.开发流程

分析：从页面-数据库
编写代码：从数据库-页面
部门管理-修改
1.显示修改数据（显示修改页面）
1.1 持久层

1.在DeptMapper接口，定义方法

Dept selectDeptById(Integer id);
2.在DeptMapper.xml中，编写select语句

<select id="" resultType="xx..xx.Dept">
    select
        id,dept_name deptName,
        dept_address deptAddress
    from t_dept
    where
        id=#{id}
</select>
测试：

1.2 业务层

1.在DeptService接口中，定义方法

Dept getDeptById(Integer id);
2.在DeptServiceImpl类中，实现方法：调用持久层方法

测试：

1.3 控制器层

@RequestMapping("/showUpdate.do")
public String showUpdate(Integer id,ModelMap map){
    Dept dept = deptService.getDeptById(id);
    map.addAttribute("dept",dept);
    return "update";
}
1.4 页面

1.在showDept.jsp页面添加链接

<a href="${pageContext.request.contextPath}/dept/showUpdate.do?id=${dept.id}">修改</a>
2.在web中定义update.jsp

<form action="" method="post">
  <input type="hidden" name="id" value="${dept.id}"/>
    名称:<input type="text" name="name" value="${dept.deptName}"/><br>
  地址:<input type="text" name="address"  value="${dept.deptAddress}"/><br>
  <input type="submit" value="修改"/><br>
</form>
2.修改
2.1 持久层

1.DeptMapper接口，定义方法

void updateDept(Dept dept);
2.在DeptMapper.xml，定义update节点，完成update

<update id="" parameterType="..Dept">
    update 
        t_dept
    set
        dept_name = #{deptName},
        dept_address = #{deptAddress}
    where
        id=#{id}
</update>
测试：

2.2 业务层

2.3 控制器

@ReqeustMapping("/update.do")
public String update(Integer id,String name,String address){
    //1.调用业务层方法
    //2.return "redirect:getAllDept.do";
}
2.4 页面

在update.jsp页面
<form action="${}/dept/update.do"..>
ssm项目介绍
1.用户管理

1.1.注册

1.2.登录

1.3.修改个人信息（基本信息，密码）

2.地址管理

2.1 添加收货地址

2.2 修改收货地址

2.3 删除收货地址

2.4 显示收货地址

3.商品模块

3.1 商品分类

3.2 展示商品

3.3 商品详情

4.购物车

4.1.添加购物车

4.2.购物车管理

项目开发流程
1.需求分析

2.概要设计

3.详细设计

4.编码

5.测试

6.交付

7.售后（后期维护）

ajax
1.ajax定义
1.ajax不是新技术，由javascript,xml,XMLHttpRequest组成的，完成异步请求的技术。

2.同步请求和异步请求

同步请求：发送请求时，当前页面不可以使用；服务器响应页面到客户端，才可以使用；

异步请求：发送请求时，当前页面还以使用，发送异步请求的数据什么时候返回，那么把数据显示到页面上。

特点：局部刷新页面数据

2.原理
客户端发送请求给ajax（XMLHttpRequest）,在由xhr发送给服务器端，服务器端处理请求，给xhr响应一段文本，xhr接收文本，由Javascript把文本显示到页面上。

3.xhr对象的创建及xhr提供函数和属性
1.创建xhr对象

function getXhr(){
    var xhr;
    if(window.XMLHttpRequest){
        xhr = new XMLHttpRequest();
    }else{
        xhr = new ActiveXObject("Microsoft.XMLHttp");
    }
    return xhr;
}
2.open():打开连接

xhr.open("get/post","xx.do",true);
3.send():发送请求

xhr.send();
4.onreadystatechange:从发送请求到响应请求，过程中状态变化

xhr.onreadystatechange=function(){
    if(xhr.readyState==4&&xhr.status==200){
        var value = xhr.responseText;
    }
}
5.readyState:获取从发送请求到响应请求过程中状态发生变化的值

0：请求未初始化；
1：初始化完成，发送请求；
2：接收响应
3：解析数据
4：解析数据完成（成功接收服务器端的数据）
5.status:响应状态码：200 ok 404 405 500

6.responseText:接收服务器端响应的数据

4.使用-异步验证用户名是否存在
步骤：

1.创建工程

1）创建web项目
2）添加web.xml
3) tomcat运行环境
4）添加依赖jar spring-webmvc  junit
5) spring-mvc.xml
6) web.xml
2.文本框失去焦点

1)在register.jsp页面上，给name文本框定义onblue=checkNameFun();

姓名：<input type="text" 
  name="name" 
  id="name"
  onblur="checkNameFun();"/><br>

2)处理异步请求的函数checkNameFun()

<script type="text/javascript">
//创建xhr的函数
function getXhr(){
    var xhr;
    //判断浏览器是否支持XMLHttpRequest对象
    if(window.XMLHttpRequest){
        //如果支持，那么创建对象
        xhr = new XMLHttpRequest();
    }else{
        //兼容低版本的浏览器 IE5 IE6 
        xhr = new ActiveXObject("Microsoft.XMLHttp");
    }
    return xhr;
}

function checkNameFun(){

    //1.获取xhr(定义函数getXhr())
    var xhr = getXhr();
    //2.处理事件
    xhr.onreadystatechange=function(){
        //获取状态为第五种状态，并且状态为200
        if(xhr.readyState==4&&xhr.status==200){
            //接收服务器响应的字符串
            var value = xhr.responseText;
            alert(value);
        }

    };
    //3.打开连接
    //获取name文本框的值
    var nameValue = document.getElementById("name").value;
    xhr.open("get","${pageContext.request.contextPath}/user/register.do?name="+nameValue,true);
    //4.发送请求
    xhr.send();
}
</script>
3.在UserController种定义方法

@RequestMapping("/register.do")
//@ResponseBody表示异步请求响应的字符串内容
@ResponseBody
public String register(String name){
    if("admin".equals(name)){
        //定义0为错误信息的状态码：
        //在页面上显示：用户名不可以使用
        return "用户名不可以使用";
    }else{
        //定义1为正确信息的状态码：
        //在页面上显示：用户名可以使用
        return "用户名可以使用";
    }
}
练习：二级菜单联动
1.页面

省：
<select onchange="getCityFun(this.value)">
  <option>请选择。。。</option>
  <option value="1">河北省</option>
  <option value="2">辽宁省</option>
</select>
城市：
<select id="city">
  <option>请选择。。。</option>

</select>



//定义二级联动菜单的函数
function getCityFun(province){
    //1.获取xhr对象
    var xhr = getXhr();
    //2.处理事件
    xhr.onreadystatechange=function(){
        if(xhr.readyState==4&&xhr.status==200){
            var value=xhr.responseText;
            alert(value);
            var cities = value.split(";");
            //11,石家庄
            //12,秦皇岛
            var cityNode = document.getElementById("city");
            cityNode.innerHTML="<option>请选择。。。</option>";
            for(i=0;i<cities.length;i++){
                var city = cities[i];
                var cityValue = city.split(",");
                //cityValue[0]=11 cityValue[1]=石家庄
                //创建option节点
                //构造方法的两个参数：第一个文本内容，第二个表示Value中值
                var op = new Option(cityValue[1],cityValue[0]);

                cityNode.appendChild(op);
            }

        }
    };
    //3.打开连接
    xhr.open("post","${pageContext.request.contextPath}/user/getCity.do",true);
    //setRequestHeader放到open后，send前
    xhr.setRequestHeader("content-type","application/x-www-form-urlencoded");
    //4.发送请求
    xhr.send("province="+province);
}
2.控制器

@RequestMapping("/getCity.do")
@ResponseBody
public String getCity(String province){
    if("1".equals(province)){
        return "11,石家庄;12,秦皇岛";
    }else{
        return "21,沈阳市;22,大连市";
    }
}

【回顾】
1.Ajax：javascript,xml,XMLHttpRequest组合在一起，叫ajax；发送请求实现异步提交。

2.异步请求：发送请求，从服务器响应回来的不是一个完整的页面，而是一小部分数据

3.执行过程：发送请求，交给xhr，由xhr发送请求给服务器，处理请求，处理结果由xhr接收，由javascript设置到页面。

4.使用ajax

4.1）创建xhr的对象：new XMLHttpRequest();

4.2) xhr.open("get/post","url",true);

4.3) xhr.send();

4.4) xhr.onreadystatechange=function(){}

4.5) xhr.readyState==4&&xhr.status==200

4.6) xhr.responseText;

Json
1.Json定义
1.客户端和服务器端进行数据交互的一种轻量级解决方案

2.语法格式：k-v var json ={"name":"admin","age":20,"address":"北京"};

alert(json.name);
3.好处：易于编写，易于阅读，易于访问

2.Json客户端
1.一个k-v的json对象

function fun1(){
    var json={"state":1};
    alert(json.state);
}
2.多个k-v的json对象

function fun2(){
    var json = {
        "state":1,
        "message":"成功"
    };
    alet(json.state+","+json.message);
}
3.多个k-v的json对象()

function fun3(){
    var json={
        "state":1,
        "message":"成功",
        "data":{
            "name":"admin",
            "age":29,
            "address":"beijing"
        }
    }
}

alert(json.data.name)
4.json数组

var json=["小明","小白","小微"];

for(i=0;i<json.length;i++){
    alert(json[i]);
}

var json=[
    {"code":11,"name":"石家庄"},
    {"code":12,"name":"秦皇岛"},
    {"code":13,"name":"廊坊"}
];

for(i=0;i<json.length;i++){
    alert(json[i].code+","+json[i].name);
}
5.json对象

function fun5(){
    var json = {
        "state":1,
        "message":"成功",
        "data":[
            {"code":11,"name":"石家庄"},
            {"code":12,"name":"秦皇岛"},
            {"code":13,"name":"廊坊"}
        ]
    };
    //测试：访问data数据
}
3.服务器端对象转换成Json字符串
需要依赖三个jar包

<dependency>
  <groupId>com.fasterxml.jackson.core</groupId>
  <artifactId>jackson-databind</artifactId>
  <version>2.8.3</version>
</dependency>
<dependency>
  <groupId>com.fasterxml.jackson.core</groupId>
  <artifactId>jackson-core</artifactId>
  <version>2.8.3</version>
</dependency>
<dependency>
  <groupId>com.fasterxml.jackson.core</groupId>
  <artifactId>jackson-annotations</artifactId>
  <version>2.8.3</version>
</dependency>
控制器的三个方法

//显示状态码和信息
@RequestMapping("/test1.do")
@ResponseBody
public ResponseResult<Void> test1(){
    ResponseResult<Void> rr = 
            new ResponseResult<Void>(1,"成功");
    return rr;
}

//响应user对象
@RequestMapping("/test2.do")
@ResponseBody
public ResponseResult<User> test2(){
    ResponseResult<User> rr = 
            new ResponseResult<User>(1,"成功");
    User user = new User();
    user.setEmail("admin@tedu.cn");
    user.setName("admin");
    user.setPhone("13800138000");
    rr.setData(user);
    return rr;
}

//响应List<User>
@RequestMapping("/test3.do")
@ResponseBody
public ResponseResult<List<User>> test3(){
    ResponseResult<List<User>> rr=
            new ResponseResult<List<User>>(1,"成功");
    List<User> list = new ArrayList<User>();

    list.add(
    new User("admin","13800138000","admin@tedu.cn"));
    list.add(
    new User("小李","13800138000","xiaoli@tedu.cn"));
    rr.setData(list);
    return rr;
}
//规范异步请求的返回类型
练习-异步请求User对象
开发步骤

1.编写update.jsp页面 显示数据
姓名：

电话：

邮箱：

2.在UserController中定义方法:showUpdate()，显示update.jsp //显示update.jsp页面 @RequestMapping("/showUpdate.do") public String showUpdate(){ return "update"; }

3.在UserController中定义方法getUser()，处理超级链接的异步请求

//处理异步请求
@RequestMapping("/getUser.do")
@ResponseBody
public ResponseResult<User> getUser(){
    //1.创建rr对象，设置状态码和信息
    ResponseResult<User> rr=
            new ResponseResult<User>(1,"成功");
    //2.封装一个User对象，把user对象设置到rr对象中
    User user = new User();
    user.setEmail("admin@tedu.cn");
    user.setName("admin");
    user.setPhone("13800138000");
    rr.setData(user);
    //3.返回rr
    return rr;
}
4.在update.jsp页面，显示数据

function getUser(){

    //1.获取xhr对象
    var xhr = getXhr();
    //2.设置处理函数
    xhr.onreadystatechange=function(){
        if(xhr.readyState==4&&xhr.status==200){
            var resValue = xhr.responseText;
            //JSON.parse()把json格式的字符串转换成json对象
            var json = JSON.parse(resValue);
            if(json.state == 1){
                document.getElementById("name").value
                    =json.data.name;
                document.getElementById("phone").value
                    =json.data.phone;
                document.getElementById("email").value
                    =json.data.email;
            }
        }
    }
    //3.打开链接
    xhr.open("get","${pageContext.request.contextPath}/user/getUser.do",true);
    //4.发送请求
    xhr.send();
}
练习-二级联动菜单
1.新建实体类：Province,City

2.在UserController中定义方法，返回省的List集合

@
@
public ResponseResult<List<Province>> getProvince(){
    //1.创建rr对象，设置状态码和信息

    //2.定义list，list中设置2个province对象
    //把list设置到rr对象中

    //3.return rr;
}
3.在update.jsp页面发送异步请求，显示列表数据

function getProvince(){
    //1.获取xhr对象
    var xhr = getXhr();
    //2.设置处理函数
    xhr.onreadystatechange=function(){
        if(xhr.readyState==4&&xhr.status==200){
            var resValue = xhr.responseText;
            //转换成json对象
            var json = JSON.parse(resValue);
            //获取province节点
            var provinceNode = 
                document.getElementById("province");
            if(json.state==1){
                for(i=0;i<json.data.length;i++){
                    //创建option节点
                    var op = 
                        new Option(json.data[i].name,json.data[i].code);
                    //向province节点中添加option节点
                    provinceNode.appendChild(op);
                }
            }

        }
    };
    //3.打开链接
    xhr.open("get","${pageContext.request.contextPath}/user/getProvince.do",true);
    //4.发送请求
    xhr.send();
}
getProvince();
4.显示城市信息

1)控制器
@
@
public ResponseResult<List<City>> getCity(String code){
    //1.rr对象
    //2.根据code，封装city对象，并添加到list，在把集合设置到rr对象中

    //3.return rr;
}

2）页面：
<select id="province" onchange="getCity(thid.value)">

function getCity(code){
    //1.获取xhr
    //2.处理函数
    //3.打开连接
    //4.发送请求
}
4.jquery实现异步提交
function fun1(code){
    $.ajax({
        url:"${}/user/getCity",
        data:"code="+code,
        type:"post",
        dataType:"json",
        success:function(obj){

        }
    });
}

this和super

this表示当前类的对象 	super表示父类的对象
this.test();		super.test();
this();			super();



动态sql

当服务器响应客户端json对象时会调用该对象的get方法，否则406

持久层mapper.xml的赋值需要#{}

data:$("#form-register").serialize() ajax中data赋值表单所有数据

js配置文件中不要使用${}

location.href=
location=

<jsp:include
<%@ include

el表达式可以在读取属性的时候还可以进行比较${user!=null}

session.invalidate();





*****************************************************
less than 小于
greater than 大于

CROSS JOIN 
	笛卡尔积
	
SQL FULL JOIN 
只要其中某个表存在匹配，FULL JOIN 关键字就会返回行。

TOP 子句
TOP 子句用于规定要返回的记录的数目。

subSelect子查询

inExpression in的表达式

SQL UNION 操作符
UNION 操作符用于合并两个或多个 SELECT 语句的结果集。

请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。

SQL UNION 语法
SELECT column_name(s) FROM table_name1
UNION
SELECT column_name(s) FROM table_name2
注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。

SQL UNION ALL 语法
SELECT column_name(s) FROM table_name1
UNION ALL
SELECT column_name(s) FROM table_name2
另外，UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名

SQL INSERT INTO SELECT 语句
INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。目标表中任何已存在的行都不会受影响。

SQL INSERT INTO SELECT 语法
我们可以从一个表中复制所有的列插入到另一个已存在的表中：

INSERT INTO table2
SELECT * FROM table1;
或者我们可以只复制希望的列插入到另一个已存在的表中：

INSERT INTO table2
(column_name(s))
SELECT column_name(s)
FROM table1;

insert = insertInto(CUSTOM).columns(CUSTOM.NAME, CUSTOM.AGE)
				.selectBody(select(TSCORE.NAME, TSCORE.SCORE).from(TSCORE))
				
参数说明

1.insertInto是Insert的静态方法，返回值为Insert。

2.CUSTOM为静态表对象

修改语句的对象是Update，包路径为org.tinygroup.tinysqldsl.Update。示例如下：

Update update;
update = update(CUSTOM).set(CUSTOM.NAME.value("abc"),CUSTOM.AGE.value(3)).where(CUSTOM.NAME.eq("悠然"));
//语句显示为：UPDATE custom SET custom.name = ?, custom.age = ? WHERE custom.name = ?
update = update(CUSTOM).set(CUSTOM.NAME.value("abc"),CUSTOM.AGE.value(3)).where(CUSTOM.NAME.in("yr1","yr2"));
//语句显示为：UPDATE custom SET custom.name = ?, custom.age = ? WHERE custom.name IN (?, ?)
参数说明

1.update是Update的静态方法，返回值为Update。

2.CUSTOM为静态表对象。

POJO（Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans

RequestMapping注解有六个属性，下面我们把她分成三类进行说明。

【1、 value， method；】

value：指定请求的实际地址，指定的地址可以是URI Template 模式；

method： 指定请求的method类型， GET、POST、PUT、DELETE等；

【2、consumes，produces；】

consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;

produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；

【3、 params，headers；】

params： 指定request中必须包含某些参数值时，才让该方法处理。

headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。

判断数据不为空且不为null

	if (gxcs != null && !"".equals(gxcs)) {
	
判断字符串去除空字符之后不为空
	
	if (StringUtils.isTrimNotEmpty(pageNumber)) {

获取RequestPayload这种前端返回的数据
	String gxcs = CommonUtils.getRequestPayload(data, "customGxcs");

public static boolean isTrimNotEmpty(String param) {
        return !(null == param || param.length() == 0 || param.trim().length() == 0);
    }


1=1 and (  or mys_c005.mys_c005_xsly2 = ' + lst.get(i) + ' 

<!-- 配置获取连接等待超时的时间 单位毫秒-->
        <property name="maxWait" value="60000"/>

<!-- 加载配置属性文件 ignore-unresolvable="true"忽略掉无法解决的问题-->
    <context:property-placeholder 
		location="classpath:jdbc.properties" 
		ignore-unresolvable="true"/>

<!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 -->
        <property name="timeBetweenEvictionRunsMillis" value="60000"/>

        <!-- 配置一个连接在池中最小生存的时间，单位是毫秒 -->
        <property name="minEvictableIdleTimeMillis" value="300000"/>
		
在Spring中的xml中使用<context:property-placeholderlocation>标签导入配置文件时，想要导入多个properties配置文件，如下：

<context:property-placeholderlocation="classpath:db.properties " />

<context:property-placeholderlocation="classpath:zxg.properties " />



结果发现不行，第二个配置文件始终读取不到，
后来发现<context:property-placeholder>标签在Spring配置文件中只能存在一份！！！
Spring容器是采用反射扫描的发现机制，通过标签的命名空间实例化实例，
当Spring探测到容器中有一个
org.springframework.beans.factory.config.PropertyPlaceholderCVonfigurer的Bean
就会停止对剩余PropertyPlaceholderConfigurer的扫描，即只能存在一个实例。
那如果有多个配置文件怎么办呢？那就多个文件之间以“,”分隔，如下：
<context:property-placeholderlocation="classpath:db.properties,classpath:monitor.properties" />
值得注意的是：多个配置文件将依次加载，如果后一个文件中有和前面某一个文件中属性名是相同的，最终取的值是后加载的值。
		
一、写本博文的原因

年初刚加入到现在的项目时，在使用注解时我用的@Resource。后来，同事：你怎么使用@Resource注解？我：使用它有错吗？同事：没错，但是现在都使用@Autowired。我：我研究一下。

在大学，学习J2EE实训时一直使用的是@Resource注解，后来我就养成习惯了。现在对这两个注解做一下解释：

@Resource默认按照名称方式进行bean匹配，@Autowired默认按照类型方式进行bean匹配
@Resource(import javax.annotation.Resource;)是J2EE的注解，@Autowired( import org.springframework.beans.factory.annotation.Autowired;)是Spring的注解
Spring属于第三方的，J2EE是Java自己的东西。使用@Resource可以减少代码和Spring之间的耦合。



二、@Resource注入

现在有一个接口Human和两个实现类ManImpl、WomanImpl，在service层的一个bean中要引用了接口Human，这种情况处理如下：

接口Human

package testwebapp.com.wangzuojia.service;
 
public interface Human {
	
	public void speak();
	
	public void walk();
}

实现类ManImpl
package testwebapp.com.wangzuojia.service.impl;
 
import org.springframework.stereotype.Service;
 
import testwebapp.com.wangzuojia.service.Human;
 
@Service
public class ManImpl implements Human {
 
	public void speak() {
		System.out.println(" man speaking!");
 
	}
 
	public void walk() {
		System.out.println(" man walking!");
 
	}
 
}


实现类WomanImpl

package testwebapp.com.wangzuojia.service.impl;
 
import org.springframework.stereotype.Service;
 
import testwebapp.com.wangzuojia.service.Human;
 
@Service
public class WomanImpl implements Human {
 
	public void speak() {
		System.out.println(" woman speaking!");
 
	}
 
	public void walk() {
		System.out.println(" woman walking!");
 
	}
 
}


主调类SequenceServiceImpl

package testwebapp.com.wangzuojia.service.impl;
 
import java.util.Map;
 
import javax.annotation.Resource;
 
import org.springframework.stereotype.Service;
 
import testwebapp.com.wangzuojia.dao.SequenceMapper;
import testwebapp.com.wangzuojia.service.Human;
import testwebapp.com.wangzuojia.service.SequenceService;
 
@Service
public class SequenceServiceImpl implements SequenceService {
 
	@Resource
	private SequenceMapper sequenceMapper;
	public void generateId(Map<String, String> map) {
		sequenceMapper.generateId(map);
		
	}
	//起服务此处会报错
	@Resource
	private Human human;
 
}

这时候启动tomcat会包如下错误：


报错的地方给我们提示了:but found 2: manImpl,womanImpl      意思是Human有两个实现类。解决方案如下：

package testwebapp.com.wangzuojia.service.impl;
 
import java.util.Map;
 
import javax.annotation.Resource;
 
import org.springframework.stereotype.Service;
 
import testwebapp.com.wangzuojia.dao.SequenceMapper;
import testwebapp.com.wangzuojia.service.Human;
import testwebapp.com.wangzuojia.service.SequenceService;
 
@Service
public class SequenceServiceImpl implements SequenceService {
 
	@Resource
	private SequenceMapper sequenceMapper;
	public void generateId(Map<String, String> map) {
		sequenceMapper.generateId(map);
		
	}
	
	@Resource(name = "manImpl")//注意是manImpl不是ManImpl，因为使用@Service，容器为我们创建bean时默认类名首字母小写
	private Human human;
 
}

这样启动服务就不会报错了。如果是使用的@Autowired注解，要配上@Qualifier("manImpl")，代码如下：

package testwebapp.com.wangzuojia.service.impl;
 
import java.util.Map;
 
import javax.annotation.Resource;
 
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;
 
import testwebapp.com.wangzuojia.dao.SequenceMapper;
import testwebapp.com.wangzuojia.service.Human;
import testwebapp.com.wangzuojia.service.SequenceService;
 
@Service
public class SequenceServiceImpl implements SequenceService {
 
	@Resource
	private SequenceMapper sequenceMapper;
	public void generateId(Map<String, String> map) {
		sequenceMapper.generateId(map);
		
	}
	
	@Autowired
	@Qualifier("manImpl")
	private Human human;
 
}

BeanUtils提供对Java反射和自省API的包装。其主要目的是利用反射机制对JavaBean的属性进行处理。
我们知道，一个JavaBean通常包含了大量的属性，很多情况下，对JavaBean的处理导致大量get/set代码堆积，
增加了代码长度和阅读代码的难度。

 注意：属性复制，不同jar中的方法，用法不一样。
1、package org.springframework.beans;中的
     BeanUtils.copyProperties(A,B);
     是A中的值付给B
  
FinCpDocDO  finCpDoc = finCpDocService.selectByDocNo(orderNo);
FinCpDocDto finCpDto = new FinCpDocDto();
if (finCpDoc == null){
   throw new ServiceException("查无该订单" + "orderNo:" + orderNo);
}
try{
   BeanUtils.copyProperties(finCpDoc, finCpDto);
2、package org.apache.commons.beanutils;（常用）
      BeanUtils.copyProperties(A,B);
      是B中的值付给A
for(OboFeeDO feeDO : oboFeeList){
    if(feeDO.getPayTime()!=null){
        ErpOboFeeDto feeDto = new ErpOboFeeDto();
        BeanUtils.copyProperties(feeDto, feeDO);
        oboFeList.add(feeDto);
    }
}

dsl生成代码中Dao实现目前都是继承TinyDslDaoSupport类的，它提供了增删改查的基本功能，分页等接口，还使用了DslTemplate操作数据库。

dslSession在使用的时候都需要先组装select/insert/update/delete对象，然后使用execute等方法执行数据库操作，返回结果集。

实际上，这部分逻辑可以封装成模板，开发者只需要关心组装那部分逻辑，而不需要直接操作dslsession。

获取dsl执行对象.获取插入数据的主键值
getDslTemplate().insertAndReturnKey

return TinyDSLUtil.addOrderByElements(select, orderArgs);
	对查询出来的结果集进行指定字段(orderArgs)的排序
	
public List<MysB003> query(MysB003 mysB003, final OrderBy... orderArgs) {

final OrderBy... orderArgs 定义为final
OrderBy... orderArgs	可以接受多个参数
	
集合工具包判断集合是否为空
	CollectionUtil.isNotEmpty(mysB003List)
	
selectFrom(MYS_B001_TABLE).where(MYS_B001_TABLE.MYS_B001_ID.eq(t));
	
localhost
127.0.0.1是回送地址，指本地机。 
127.0.0.1是用来检测网络的自己的IP.就是说任何一台电脑来说,不管是否连接到INTERNET上,127.0.0.1对于自己来说都是自己.就是说,每台电脑都是由4位的256进制数组成的. 
而192.168.1.102现在是本机，但本机也可以设置成其他ip地址，但127.0.0.1一定是指本机。
	
@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。
@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。
	
public List<MysA001Response> INF00003(MysA001Request mysA001Request, PageRequest pageRequest) {
        OrderBy[] orderBys = OrderByUtil.assembleOrderByArray(pageRequest.getOrderNameList(), pageRequest.getOrderAscList());
        List<MysA001> mysA001List = mysINF00Manager.sysCommonTypeList(
                wrap(mysA001Request, MysA001.class), orderBys);
        return CommonUtils.wrap(mysA001List, MysA001Response.class);
    }	
	
Java replaceFirst() 方法
Java String类Java String类

replaceFirst() 方法使用给定的参数 replacement 替换字符串第一个匹配给定的正则表达式的子字符串。

语法
public String replaceFirst(String regex,
                           String replacement)
参数
regex -- 匹配此字符串的正则表达式。

replacement -- 用来替换第一个匹配项的字符串。

返回值
成功则返回替换的字符串，失败则返回原始字符串。

实例
public class Test {
    public static void main(String args[]) {
        String Str = new String("hello runoob，I am from runoob。");

        System.out.print("返回值 :" );
        System.out.println(Str.replaceFirst("runoob", "google" ));
        System.out.print("返回值 :" );
        System.out.println(Str.replaceFirst("(.*)runoob(.*)", "google" ));
    }
}
以上程序执行结果为：

返回值 :hello google，I am from runoob。
返回值 :google
	
public Pager<MysC005C006> getINF01001(MysC005C006 mysC005C006, Integer start, Integer limit, List lst, final OrderBy... orderArgs) {
        String conditions = "1=1";
        if (lst != null && lst.size() > 0) {
            conditions = conditions + " and (";
            for (int i = 0; i < lst.size(); i++) {
                conditions = conditions + "  or mys_c005.mys_c005_xsly2 = '" + lst.get(i) + "' ";
            }
            mysC005C006.setMysC005Xsly2(null);
            //替换conditions中第一个or
            conditions = conditions.replaceFirst("or", "") + " ) ";
            conditions = conditions + " and mys_c006.mys_c006_xszyfpsj is not null and mys_c006.mys_c006_xszyjssj is null and mys_c006.mys_c006_xszydjsj is null and mys_c006.mys_c006_xszyyyddsj is null  ";
        }
        mysC005C006.setMysScbj("0");
        Pager<MysC005C006> pager = mysC005C006Dao.queryPagerINF01001(start, limit, mysC005C006, FragmentExpressionSql.fragmentCondition(conditions), orderArgs);
        return pager;
    }

java解析json数组

String s = "[{usersid:322,LevelID:'',permission:'1,2'},{usersid:324,LevelID:5,permission:'2,5,9'}]";

public static void main(String [] args){

JSONArray json = JSONArray.fromObject(s);//先将对象转成json数组

for(int i = 0, i < json.size();i++){

JSONObject job = json.getJSONObject(i);

        Integer usersid = job.getInt("usersid");//getInt这样是直接得到int型

Object obje = job.get("LevelID");
Integer LevelID; 

if (obje == null || "".equals(obje)) {
LevelID = null; 
} else {
LevelID = (Integer)obje;
}

注：因为LevelID前台传值可有可无，所以我们一定要去解析，当传空的时候，就需要先用object去接然后判断转换。

        String permission = job.getString("permission");//这样是得到string型

String [] n = permissiom.spilt(",");

for(int j = 0,j < n.length; j++){ //循环拿值

Integer in = Integer.parseInt(n[j]);

}

}

}	
	
@Scope("prototype")
spring 默认scope 是单例模式
这样只会创建一个Action对象
每次访问都是同一个Action对象，数据不安全
struts2 是要求 每次次访问 都对应不同的Action
 scope="prototype" 可以保证 当有请求的时候 都创建一个Action对象
	
#{} 和 ${} 在预编译中的处理是不一样的。#{} 在预处理时，会把参数部分用一个占位符 ? 代替，变成如下的 sql 语句：
select * from user where name = ?;
　　而 ${} 则只是简单的字符串替换，在动态解析阶段，该 sql 语句会被解析成
select * from user where name = 'zhangsan';
　　以上，#{} 的参数替换是发生在 DBMS 中，而 ${} 则发生在动态解析过程中。
　　那么，在使用过程中我们应该使用哪种方式呢？
　　答案是，优先使用 #{}。因为 ${} 会导致 sql 注入的问题。

每一个jsp开头都有个
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-trasitional.dtd">
（通常是这样）但要支持h5要改成这样
<!DOCTYPE html>

定义和用法
removeAttr() 方法从被选元素中移除属性。

语法
$(selector).removeAttr(attribute)

实际上一个上传表单只需要满足如下两点。
l  enctype属性的属性值设为multipart/form-data。
l  input的type属性的属性值设为file。

从Request对象中可以获取各种路径信息，以下例子：  
假设请求的页面是index.jsp,项目是WebDemo，则在index.jsp中获取有关request对象的各种路径信息如下  
String path = request.getContextPath();  
String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";  
String remoteAddress=request.getRemoteAddr();  
String servletPath=request.getServletPath();  
String realPath=request.getRealPath("/");  
String remoteUser=request.getRemoteUser();  
String requestURI=request.getRequestURI();  
out.println("path:"+path+"<br>");  
out.println("basePath:"+basePath+"<br>");  
out.println("remoteAddr:"+remoteAddress+"<br>");  
out.println("servletPath:"+servletPath+"<br>");  
out.println("realPath:"+realPath+"<br>");  
out.println("remoteUser:"+remoteUser+"<br>");  
out.println("requestURI:"+requestURI+"<br>");  
结果：  
path:/WebDemo  
basePath:http://localhost:8683/WebDemo/  
remoteAddr:127.0.0.1  
servletPath:/index.jsp  
realPath:D:\apache-tomcat-6.0.13\webapps\WebDemo\  
remoteUser:null  
requestURI:/WebDemo/index.jsp  
从上不难看出request各个对应方法所代表的含义 
复制代码
参考servlet中的接口：

request.getScheme();
返回的协议名称,默认是http

request.getServerName()
返回的是你浏览器中显示的主机名，你自己试一下就知道了

getServerPort()
获取服务器端口号

 例如：

<servlet-mapping>
<servlet-name>TestServlet</servlet-name>
<url-pattern>/servlet/test/*</url-pattern>
</servlet-mapping>

dwr为工程名
http://localhost:8080/dwr/servlet/test/joejoe1991/a.html?name=test
getPathInfo() 返回的仍然是：
"/joejoe1991/a.html" ，而并不包括后面的"?name=test";

 

 

在servlet里用this.getServletContect().getRealPath()

在struts里用this.getServlet().getServletContext().getRealPath()

在Action里用ServletActionContext.getRequest().getRealPath();

 

以上三个获得都是当前运行文件在服务器上的绝对路径




从request获取各种路径总结 
request.getRealPath("url"); // 虚拟目录映射为实际目录 


request.getRealPath("./");    // 网页所在的目录 

request.getRealPath("../"); // 网页所在目录的上一层目录 

request.getContextPath();    // 应用的web目录的名称 


如http://localhost:7001/bookStore/ 
/bookStore/ => [contextPath] (request.getContextPath()) 

获取Web项目的全路径 
String strDirPath = request.getSession().getServletContext().getRealPath("/"); 

以工程名为TEST为例： 

(1)得到包含工程名的当前页面全路径：request.getRequestURI() 
结果：/TEST/test.jsp 


(2)得到工程名：request.getContextPath() 
结果：/TEST 


(3)得到当前页面所在目录下全名称：request.getServletPath() 
结果：如果页面在jsp目录下 /TEST/jsp/test.jsp 


(4)得到页面所在服务器的全路径：application.getRealPath("页面.jsp") 
结果：D:\resin\webapps\TEST\test.jsp 


(5)得到页面所在服务器的绝对路径：absPath=new java.io.File(application.getRealPath(request.getRequestURI())).getParent(); 
结果：D:\resin\webapps\TEST 

2.在类中取得路径： 

(1)类的绝对路径：Class.class.getClass().getResource("/").getPath() 
结果：/D:/TEST/WebRoot/WEB-INF/classes/pack/ 


(2)得到工程的路径：System.getProperty("user.dir") 
结果：D:\TEST 

3.在Servlet中取得路径： 

(1)得到工程目录：request.getSession().getServletContext().getRealPath("") 参数可具体到包名。 
结果：E:\Tomcat\webapps\TEST 


(2)得到IE地址栏地址：request.getRequestURL() 
结果：http://localhost:8080/TEST/test 


(3)得到相对地址：request.getRequestURI() 
结果：/TEST/test

SpringMVC与Struts2区别与比较总结



一、框架机制

1、Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。
2、Filter在容器启动之后即初始化；服务停止以后坠毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。


二、拦截机制

1、Struts2

a、Struts2框架是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype（否则会出现线程并发问题），然后通过setter，getter吧request数据注入到属性。
b、Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。
c、Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了
 
2、SpringMVC
a、SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又何一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。
b、在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，有应为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。


三、性能方面
SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。而Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，所以，SpringMVC开发效率和性能高于Struts2。


四、拦截机制
Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。


五、配置方面
spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高（当然Struts2也可以通过不同的目录结构和相关配置做到SpringMVC一样的效果，但是需要xml配置的地方不少）。
SpringMVC可以认为已经100%零配置。


六、设计思想
Struts2更加符合OOP的编程思想， SpringMVC就比较谨慎，在servlet上扩展。


七、集成方面
SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。



Ｈｉｂｅｒｎａｔｅ框架基本开发实现 ↓↓↓↓↓↓↓↓↓↓↓-------------------------------------------



基本开发实现；
    1.导包
  antlr-2.7.7.jar    〓 ---> Hierbante辅助包
  dom4j-1.6.1.jar    〓 ---> dom4J技术对xml文件解析包
  hibernate-commons-annotations-4.0.5.Final.jar 〓 ---> Hibernate注解核心包 
  hibernate-core-4.3.8.Final.jar           〓 ---> Hibernate框架核心包
  hibernate-jpa-2.1-api-1.0.0.Final.jar 〓 ---> JPA框架支持包，融合了JPA框架
  jandex-1.1.0.Final.jar
〓 ---> Hibernate辅助包
  javassist-3.18.1-GA.jar
      〓 ---> 字节码辅助包
  jboss-logging-3.1.3.GA.jar
     〓 ---> 日志包
  jboss-logging-annotations-1.2.0.Beta1.jar   〓 ---> 注解日志包
  jboss-transaction-api_1.2_spec-1.0.0.Final.jar  〓 ---> 事务支持包
  
  <!-- 
auto-import 默认是true，
如果在项目中出现同名的类，
那么则需要设置为false。
     
     ◆那么则在代码中使用这个映射类的时候，
      需要使用类的全路径。

package 是简化在需要创建的类路径，
那么在写的时候则不需要写类的全路径了

-->
<hibernate-mapping auto-import="false" package="包路径">


  JAVA中字符串比较equals()和equalsIgnoreCase()的区别
  
1、使用equals( )方法比较两个字符串是否相等。它具有如下的一般形式：

boolean equals(Object str)

这里str是一个用来与调用字符串（String）对象做比较的字符串（String）对象。
如果两个字符串具有相同的字符和长度，它返回true，否则返回false。这种比较是区分大小写的。

2、为了执行忽略大小写的比较，可以调用equalsIgnoreCase( )方法。
当比较两个字符串时，它会认为A-Z和a-z是一样的。其一般形式如下：

boolean equalsIgnoreCase(String str)
  
现在我有一个长度不固定的数组  要求写一个可以随机生成数组下标的程序
  
 colors[(int) (Math.random() * colors.length)];
  
  String类型有一个方法：contains（）,该方法是判断字符串中是否有子字符串。如果有则返回true，如果没有则返回false。
  
  for的语法，for(初始化; 条件判断; 循环后处理)
每个部分都可以省略，但是;要保留
如，无限循环
for(;;) {

    System.out.println("loop");

}

迭代器核心代码
		@Override
		public boolean hasNext() {
			if (index < names.length) {
				return true;
			}
			return false;
		}

		@Override
		public Object next() {
			if (this.hasNext()) {
				return names[index++];
			}
			return null;
		}
  
  设计模式的六大原则
总原则：开闭原则（Open Close Principle）
开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。

1、单一职责原则
不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。

 

2、里氏替换原则（Liskov Substitution Principle）
里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科

历史替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。

 

3、依赖倒转原则（Dependence Inversion Principle）
这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。

 

4、接口隔离原则（Interface Segregation Principle）
这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。

 

5、迪米特法则（最少知道原则）（Demeter Principle）
就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。

最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。

 

6、合成复用原则（Composite Reuse Principle）
原则是尽量首先使用合成/聚合的方式，而不是使用继承。
  
  
  在JDBC连接Mysql数据库的过程中出现了如下的警告信息:

 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.

是Mysql数据库的SSL连接问题，提示警告不建议使用没有带服务器身份验证的SSL连接，是在MYSQL5.5.45+, 5.6.26+ and 5.7.6+版本中才有的这个问题。解决办法在警告中已经说明了：

1.在数据库连接的url中添加useSSL=false;
2.url中添加useSSL=true，并且提供服务器的验证证书。
如果只是做一个测试的话，没必要搞证书那么麻烦啦，在连接后添加一个useSSL=false即可，例如：

jdbc:mysql://localhost:3306/test?useSSL=false
在使用Java进行JDBC连接的时候，可以在Properties对象中设置useSSL的值为false，但是和写在链接中是一样的。比如


Properties properties = new Properties();
properties.setProperty("user", "root");
properties.setProperty("password", "milos23);
properties.setProperty("useSSL", "false");
properties.setProperty("autoReconnect", "true");
try (Connection conn = DriverManager.getConnection(connectionUrl, properties)) {
	...
} catch (SQLException e) {
	...
}
其实这个是不用写出来的，但是一个同事懒啊，都不知道看警告信息，直接来问我，写给懒的人看的，哈哈
  
  
  跨站请求伪造（CSRF）
概念
CSRF，全称为Cross-Site Request Forgery，跨站请求伪造，是一种网络攻击方式，它可以在用户毫不知情的情况下，以用户的名义伪造请求发送给被攻击站点，从而在未授权的情况下进行权限保护内的操作。

具体来讲，可以这样理解CSRF。攻击者借用用户的名义，向某一服务器发送恶意请求，对服务器来讲，这一请求是完全合法的，但攻击者确完成了一个恶意操作，比如以用户的名义发送邮件，盗取账号，购买商品等等。

原理
CSRF攻击原理比较简单，例如Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。

用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A； 
　　
在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；并且，此后从用户浏览器发送请求给网站A时都会默认带上用户的Cookie信息； 
　　
用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B； 
　　
网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A； 
　　 
浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。
简单来说，CSRF必须经过两个步骤：

1、用户访问可信任站点A，并产生了相关的cookie;

2、用户在访问A站点时没有退出，同时访问了危险站点B。 
疑问：为什么网站A不能退出呢？
  
  CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。

它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。
  
  CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。

整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。

因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。
  
  简介

在Web领域基于Token的身份验证随处可见。在大多数使用Web API的互联网公司中，tokens 是多用户下处理认证的最佳方式。

以下几点特性会让你在程序中使用基于Token的身份验证

1.无状态、可扩展

 2.支持移动设备

 3.跨程序调用

 4.安全

 

那些使用基于Token的身份验证的大佬们

大部分你见到过的API和Web应用都使用tokens。例如Facebook, Twitter, Google+, GitHub等。

 

Token的起源

在介绍基于Token的身份验证的原理与优势之前，不妨先看看之前的认证都是怎么做的。

　　基于服务器的验证

　  我们都是知道HTTP协议是无状态的，这种无状态意味着程序需要验证每一次请求，从而辨别客户端的身份。

在这之前，程序都是通过在服务端存储的登录信息来辨别请求的。这种方式一般都是通过存储Session来完成。

下图展示了基于服务器验证的原理

tokens-traditional

随着Web，应用程序，已经移动端的兴起，这种验证的方式逐渐暴露出了问题。尤其是在可扩展性方面。

 

基于服务器验证方式暴露的一些问题

1.Seesion：每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。当越来越多的用户发请求时，内存的开销也会不断增加。

2.可扩展性：在服务端的内存中使用Seesion存储登录信息，伴随而来的是可扩展性问题。

3.CORS(跨域资源共享)：当我们需要让数据跨多台移动设备上使用时，跨域资源的共享会是一个让人头疼的问题。在使用Ajax抓取另一个域的资源，就可以会出现禁止请求的情况。

4.CSRF(跨站请求伪造)：用户在访问银行网站时，他们很容易受到跨站请求伪造的攻击，并且能够被利用其访问其他的网站。

在这些问题中，可扩展行是最突出的。因此我们有必要去寻求一种更有行之有效的方法。

 

基于Token的验证原理

基于Token的身份验证是无状态的，我们不将用户信息存在服务器或Session中。

这种概念解决了在服务端存储信息时的许多问题

　　NoSession意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录。

基于Token的身份验证的过程如下:

1.用户通过用户名和密码发送请求。

2.程序验证。

3.程序返回一个签名的token 给客户端。

4.客户端储存token,并且每次用于每次发送请求。

5.服务端验证token并返回数据。

 每一次请求都需要token。token应该在HTTP的头部发送从而保证了Http请求无状态。我们同样通过设置服务器属性Access-Control-Allow-Origin:* ，让服务器能接受到来自所有域的请求。需要主要的是，在ACAO头部标明(designating)*时，不得带有像HTTP认证，客户端SSL证书和cookies的证书。

 

下面的图片解释了过程:

tokens-new

 

当我们在程序中认证了信息并取得token之后，我们便能通过这个Token做许多的事情。

我们甚至能基于创建一个基于权限的token传给第三方应用程序，这些第三方程序能够获取到我们的数据（当然只有在我们允许的特定的token）

 

Tokens的优势

无状态、可扩展

在客户端存储的Tokens是无状态的，并且能够被扩展。基于这种无状态和不存储Session信息，负载负载均衡器能够将用户信息从一个服务传到其他服务器上。

如果我们将已验证的用户的信息保存在Session中，则每次请求都需要用户向已验证的服务器发送验证信息(称为Session亲和性)。用户量大时，可能会造成

 一些拥堵。

但是不要着急。使用tokens之后这些问题都迎刃而解，因为tokens自己hold住了用户的验证信息。

安全性

请求中发送token而不再是发送cookie能够防止CSRF(跨站请求伪造)。即使在客户端使用cookie存储token，cookie也仅仅是一个存储机制而不是用于认证。不将信息存储在Session中，让我们少了对session操作。 

token是有时效的，一段时间之后用户需要重新验证。我们也不一定需要等到token自动失效，token有撤回的操作，通过token revocataion可以使一个特定的token或是一组有相同认证的token无效。

可扩展性（）

Tokens能够创建与其它程序共享权限的程序。例如，能将一个随便的社交帐号和自己的大号(Fackbook或是Twitter)联系起来。当通过服务登录Twitter(我们将这个过程Buffer)时，我们可以将这些Buffer附到Twitter的数据流上(we are allowing Buffer to post to our Twitter stream)。

使用tokens时，可以提供可选的权限给第三方应用程序。当用户想让另一个应用程序访问它们的数据，我们可以通过建立自己的API，得出特殊权限的tokens。

多平台跨域

我们提前先来谈论一下CORS(跨域资源共享)，对应用程序和服务进行扩展的时候，需要介入各种各种的设备和应用程序。

Having our API just serve data, we can also make the design choice to serve assets from a CDN. This eliminates the issues that CORS brings up after we set a quick header configuration for our application.

只要用户有一个通过了验证的token，数据和资源就能够在任何域上被请求到。

          Access-Control-Allow-Origin: *       
基于标准

创建token的时候，你可以设定一些选项。我们在后续的文章中会进行更加详尽的描述，但是标准的用法会在JSON Web Tokens体现。

最近的程序和文档是供给JSON Web Tokens的。它支持众多的语言。这意味在未来的使用中你可以真正的转换你的认证机制。
  
  SSL介绍

SSL（Secure Socket Layer：安全套接字层）利用数据加密、身份验证和消息完整性验证机制，为基于TCP等可靠连接的应用层协议提供安全性保证。

SSL协议提供的功能主要有：

           1、 数据传输的机密性：利用对称密钥算法对传输的数据进行加密。
           2.、身份验证机制：基于证书利用数字签名方法对服务器和客户端进行身份验证，其中客户端的身份验证是可选的。
           3、 消息完整性验证：消息传输过程中使用MAC算法来检验消息的完整性。

如果用户的传输不是通过SSL的方式，那么其在网络中数据都是以明文进行传输的，而这给别有用心的人带来了可乘之机。所以，现在很多大型网站都开启了SSL功能。同样地，在我们数据库方面，如果客户端连接服务器获取数据不是使用SSL连接，那么在传输过程中，数据就有可能被窃取。
  
  首先必须明确的是：要想操作一张图片，首先必须将其从磁盘加载到内存中，然后才能对图片做进一步的处理。

BufferedImage是Image的一个子类，Image和BufferedImage的主要作用就是将一副图片加载到内存中。BufferedImage生成的图片在内存里有一个图像缓冲区，利用这个缓冲区我们可以很方便的操作这个图片，通常用来做图片修改操作如大小变换、图片变灰、设置图片透明或不透明等。Java将一副图片加载到内存中的方法是：

BufferedImage bufferedImage = ImageIO.read(new FileInputStream(filePath)); 
  
  response.setHeader("Cache-Control","no-cache");
  This is used to prevent the browser from caching your dynamic content generated by a JSP or Servlet. 
  这用于防止浏览器缓存JSP或Servlet生成的动态内容。 
  You set this attribute in the HTTP header of the response object which would tell the browser not to cache this content.  
  您可以在响应对象的HTTP头中设置此属性，它将告诉浏览器不要缓存此内容。
  So everytime you request the page again, the browser would make a new request, instead of showing you a cached page. 
  因此，每次再次请求页面时，浏览器都会发出一个新的请求，而不是显示一个缓存页面。
  .使用服务器端控制AJAX页面缓存：
response.setHeader( "Pragma", "no-cache" );
response.addHeader( "Cache-Control", "must-revalidate" );
response.addHeader( "Cache-Control", "no-cache" );
response.addHeader( "Cache-Control", "no-store" );
response.setDateHeader("Expires", 0);
单纯的使用 xmlhttp.setRequestHeader("Cache-Control","no-cache")无效。

3.Cache-Control头域
　　Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下：
　　Public指示响应可被任何缓存区缓存。
　　Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。
　　no-cache指示请求或响应消息不能缓存
　　no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。
　　max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。
　　min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。
　　max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。

response.setDateHeader("Expires", 0); 

expires是response的一个属性 
它可以设置页面在浏览器的缓存里保存的时间 
超过设定的时间后就过期 
过期后再次浏览该页面就需要重新请求服务器发送页面数据 
如果在规定的时间内再次访问次页面 
就不需从服务器传送 直接从缓存中读取
  
  response.setContentType(MIME)的作用是使客户端浏览器，区分不同种类的数据，并根据不同的MIME调用浏览器内不同的程序嵌入模块来处理相应的数据,本文详细介绍，需要了解的朋友可以参考下

response.setContentType(MIME)的作用是使客户端浏览器，区分不同种类的数据，并根据不同的MIME调用浏览器内不同的程序嵌入模块来处理相应的数据。

例如web浏览器就是通过MIME类型来判断文件是GIF图片。通过MIME类型来处理json字符串。 
Tomcat的安装目录\conf\web.xml 中就定义了大量MIME类型 ，可以参考。 
response.setContentType("text/html; charset=utf-8"); html 
.setContentType("text/plain; charset=utf-8"); 文本 
text/javascript json数据 
application/xml xml数据 

这个方法设置发送到客户端的响应的内容类型，此时响应还没有提交。给出的内容类型可以包括字符编码说明，例如：text/html;charset=UTF-8.如果该方法在getWriter()方法被调用之前调用，那么响应的字符编码将仅从给出的内容类型中设置。该方法如果在getWriter()方法被调用之后或者在被提交之后调用，将不会设置响应的字符编码，在使用http协议的情况中，该方法设置 Content-type实体报头。 
一般在Servlet中，习惯性的会首先设置请求以及响应的内容类型以及编码方式：
response.setContentType("text/html;charset=UTF-8"); 
request.setCharacterEncoding("UTF-8"); 
response.setContentType()的String参数及对应类型 
<option value="image/bmp">BMP</option> 
<option value="image/gif">GIF</option> 
<option value="image/jpeg">JPEG</option> 
<option value="image/tiff">TIFF</option> 
<option value="image/x-dcx">DCX</option> 
<option value="image/x-pcx">PCX</option> 
<option value="text/html">HTML</option> 
<option value="text/plain">TXT</option> 
<option value="text/xml">XML</option> 
<option value="application/afp">AFP</option> 
<option value="application/pdf">PDF</option> 
<option value="application/rtf">RTF</option> 
<option value="application/msword">MSWORD</option> 
<option value="application/vnd.ms-excel">MSEXCEL</option> 
<option value="application/vnd.ms-powerpoint">MSPOWERPOINT</option> 
<option value="application/wordperfect5.1">WORDPERFECT</option> 
<option value="application/vnd.lotus-wordpro">WORDPRO</option> 
<option value="application/vnd.visio">VISIO</option> 
<option value="application/vnd.framemaker">FRAMEMAKER</option> 
<option value="application/vnd.lotus-1-2-3">LOTUS123</option> 
response.setContentType()的参数说明
<meta http-equiv="Content-Type" content="text/html; charset=GBK"> 
response.setContentType() ; 
* = application/octet-stream 
.001 = application/x-001 
.301 = application/x-301 
.323 = text/h323 
.906 = application/x-906 
.907 = drawing/907 
.a11 = application/x-a11 
.acp = audio/x-mei-aac 
.ai = application/postscript 
.aif = audio/aiff 
.aifc = audio/aiff 
.aiff = audio/aiff 
.anv = application/x-anv 
.asa = text/asa 
.asf = video/x-ms-asf 
.asp = text/asp 
.asx = video/x-ms-asf 
.au = audio/basic 
.avi = video/avi 
.awf = application/vnd.adobe.workflow 
.biz = text/xml 
.bmp = application/x-bmp 
.bot = application/x-bot 
.c4t = application/x-c4t 
.c90 = application/x-c90 
.cal = application/x-cals 
.cat = application/vnd.ms-pki.seccat 
.cdf = application/x-netcdf 
.cdr = application/x-cdr 
.cel = application/x-cel 
.cer = application/x-x509-ca-cert 
.cg4 = application/x-g4 
.cgm = application/x-cgm 
.cit = application/x-cit 
.class = java/* 
.cml = text/xml :客户端浏览器按XML格式进行解析文档 
.cmp = application/x-cmp 
.cmx = application/x-cmx 
.cot = application/x-cot 
.crl = application/pkix-crl 
.crt = application/x-x509-ca-cert 
.csi = application/x-csi 
.css = text/css :客户端浏览器按CSS格式进行解析文档 
.cut = application/x-cut 
.dbf = application/x-dbf 
.dbm = application/x-dbm 
.dbx = application/x-dbx 
.dcd = text/xml :客户端浏览器按XML格式进行解析文档 
.dcx = application/x-dcx 
.der = application/x-x509-ca-cert 
.dgn = application/x-dgn 
.dib = application/x-dib 
.dll = application/x-msdownload 
.doc = application/msword 
.dot = application/msword 
.drw = application/x-drw 
.dtd = text/xml :客户端浏览器按XML格式进行解析文档 
.dwf = Model/vnd.dwf 
.dwf = application/x-dwf 
.dwg = application/x-dwg 
.dxb = application/x-dxb 
.dxf = application/x-dxf 
.edn = application/vnd.adobe.edn 
.emf = application/x-emf 
.eml = message/rfc822 
.ent = text/xml :客户端浏览器按XML格式进行解析文档 
.epi = application/x-epi 
.eps = application/x-ps 
.eps = application/postscript 
.etd = application/x-ebx 
.exe = application/x-msdownload 
.fax = image/fax 
.fdf = application/vnd.fdf 
.fif = application/fractals 
.fo = text/xml :客户端浏览器按XML格式进行解析文档 
.frm = application/x-frm 
.g4 = application/x-g4 
.gbr = application/x-gbr 
.gcd = application/x-gcd 
.gif = image/gif 
.gl2 = application/x-gl2 
.gp4 = application/x-gp4 
.hgl = application/x-hgl 
.hmr = application/x-hmr 
.hpg = application/x-hpgl 
.hpl = application/x-hpl 
.hqx = application/mac-binhex40 
.hrf = application/x-hrf 
.hta = application/hta 
.htc = text/x-component 
.htm = text/html :客户端浏览器按超文本格式进行解析文档 
.html = text/html :客户端浏览器按超文本格式进行解析文档 
.htt = text/webviewhtml 
.htx = text/html :客户端浏览器按超文本格式进行解析文档 
.icb = application/x-icb 
.ico = image/x-icon 
.ico = application/x-ico 
.iff = application/x-iff 
.ig4 = application/x-g4 
.igs = application/x-igs 
.iii = application/x-iphone 
.img = application/x-img 
.ins = application/x-internet-signup 
.isp = application/x-internet-signup 
.IVF = video/x-ivf 
.java = java/* 
.jfif = image/jpeg 
.jpe = image/jpeg 
.jpe = application/x-jpe 
.jpeg = image/jpeg 
.jpg = image/jpeg 
.jpg = application/x-jpg 
.js = application/x-javascript 
.jsp = text/html :客户端浏览器按超文本格式进行解析文档 
.la1 = audio/x-liquid-file 
.lar = application/x-laplayer-reg 
.latex = application/x-latex 
.lavs = audio/x-liquid-secure 
.lbm = application/x-lbm 
.lmsff = audio/x-la-lms 
.ls = application/x-javascript 
.ltr = application/x-ltr 
.m1v = video/x-mpeg 
.m2v = video/x-mpeg 
.m3u = audio/mpegurl 
.m4e = video/mpeg4 
.mac = application/x-mac 
.man = application/x-troff-man 
.math = text/xml 
.mdb = application/msaccess 
.mdb = application/x-mdb 
.mfp = application/x-shockwave-flash 
.mht = message/rfc822 
.mhtml = message/rfc822 
.mi = application/x-mi 
.mid = audio/mid 
.midi = audio/mid 
.mil = application/x-mil 
.mml = text/xml 
.mnd = audio/x-musicnet-download 
.mns = audio/x-musicnet-stream 
.mocha = application/x-javascript 
.movie = video/x-sgi-movie 
.mp1 = audio/mp1 
.mp2 = audio/mp2 
.mp2v = video/mpeg 
.mp3 = audio/mp3 
.mp4 = video/mpeg4 
.mpa = video/x-mpg 
.mpd = application/vnd.ms-project 
.mpe = video/x-mpeg 
.mpeg = video/mpg 
.mpg = video/mpg 
.mpga = audio/rn-mpeg 
.mpp = application/vnd.ms-project 
.mps = video/x-mpeg 
.mpt = application/vnd.ms-project 
.mpv = video/mpg 
.mpv2 = video/mpeg 
.mpw = application/vnd.ms-project 
.mpx = application/vnd.ms-project 
.mtx = text/xml 
.mxp = application/x-mmxp 
.net = image/pnetvue 
.nrf = application/x-nrf 
.nws = message/rfc822 
.odc = text/x-ms-odc 
.out = application/x-out 
.p10 = application/pkcs10 
.p12 = application/x-pkcs12 
.p7b = application/x-pkcs7-certificates 
.p7c = application/pkcs7-mime 
.p7m = application/pkcs7-mime 
.p7r = application/x-pkcs7-certreqresp 
.p7s = application/pkcs7-signature 
.pc5 = application/x-pc5 
.pci = application/x-pci 
.pcl = application/x-pcl 
.pcx = application/x-pcx 
.pdf = application/pdf :客户端浏览器按PDF格式进行解析文档 
.pdf = application/pdf 
.pdx = application/vnd.adobe.pdx 
.pfx = application/x-pkcs12 
.pgl = application/x-pgl 
.pic = application/x-pic 
.pko = application/vnd.ms-pki.pko 
.pl = application/x-perl 
.plg = text/html 
.pls = audio/scpls 
.plt = application/x-plt 
.png = image/png 
.png = application/x-png 
.pot = application/vnd.ms-powerpoint 
.ppa = application/vnd.ms-powerpoint 
.ppm = application/x-ppm 
.pps = application/vnd.ms-powerpoint 
.ppt = application/vnd.ms-powerpoint 
.ppt = application/x-ppt 
.pr = application/x-pr 
.prf = application/pics-rules 
.prn = application/x-prn 
.prt = application/x-prt 
.ps = application/x-ps 
.ps = application/postscript 
.ptn = application/x-ptn 
.pwz = application/vnd.ms-powerpoint 
.r3t = text/vnd.rn-realtext3d 
.ra = audio/vnd.rn-realaudio 
.ram = audio/x-pn-realaudio 
.ras = application/x-ras 
.rat = application/rat-file 
.rdf = text/xml 
.rec = application/vnd.rn-recording 
.red = application/x-red 
.rgb = application/x-rgb 
.rjs = application/vnd.rn-realsystem-rjs 
.rjt = application/vnd.rn-realsystem-rjt 
.rlc = application/x-rlc 
.rle = application/x-rle 
.rm = application/vnd.rn-realmedia 
.rmf = application/vnd.adobe.rmf 
.rmi = audio/mid 
.rmj = application/vnd.rn-realsystem-rmj 
.rmm = audio/x-pn-realaudio 
.rmp = application/vnd.rn-rn_music_package 
.rms = application/vnd.rn-realmedia-secure 
.rmvb = application/vnd.rn-realmedia-vbr 
.rmx = application/vnd.rn-realsystem-rmx 
.rnx = application/vnd.rn-realplayer 
.rp = image/vnd.rn-realpix 
.rpm = audio/x-pn-realaudio-plugin 
.rsml = application/vnd.rn-rsml 
.rt = text/vnd.rn-realtext 
.rtf = application/msword 
.rtf = application/x-rtf 
.rv = video/vnd.rn-realvideo 
.sam = application/x-sam 
.sat = application/x-sat 
.sdp = application/sdp 
.sdw = application/x-sdw 
.sit = application/x-stuffit 
.slb = application/x-slb 
.sld = application/x-sld 
.slk = drawing/x-slk 
.smi = application/smil 
.smil = application/smil 
.smk = application/x-smk 
.snd = audio/basic 
.sol = text/plain 
.sor = text/plain 
.spc = application/x-pkcs7-certificates 
.spl = application/futuresplash 
.spp = text/xml 
.ssm = application/streamingmedia 
.sst = application/vnd.ms-pki.certstore 
.stl = application/vnd.ms-pki.stl 
.stm = text/html 
.sty = application/x-sty 
.svg = text/xml 
.swf = application/x-shockwave-flash :客户端浏览器按 Flash 格式进行解析文档 
.tdf = application/x-tdf 
.tg4 = application/x-tg4 
.tga = application/x-tga 
.tif = image/tiff 
.tif = application/x-tif 
.tiff = image/tiff 
.tld = text/xml 
.top = drawing/x-top 
.torrent = application/x-bittorrent 
.tsd = text/xml 
.txt = text/plain :客户端浏览器按 纯文本 格式进行解析文档 
.uin = application/x-icq 
.uls = text/iuls 
.vcf = text/x-vcard 
.vda = application/x-vda 
.vdx = application/vnd.visio 
.vml = text/xml 
.vpg = application/x-vpeg005 
.vsd = application/vnd.visio 
.vsd = application/x-vsd 
.vss = application/vnd.visio 
.vst = application/vnd.visio 
.vst = application/x-vst 
.vsw = application/vnd.visio 
.vsx = application/vnd.visio 
.vtx = application/vnd.visio 
.vxml = text/xml 
.wav = audio/wav 
.wax = audio/x-ms-wax 
.wb1 = application/x-wb1 
.wb2 = application/x-wb2 
.wb3 = application/x-wb3 
.wbmp = image/vnd.wap.wbmp 
.wiz = application/msword 
.wk3 = application/x-wk3 
.wk4 = application/x-wk4 
.wkq = application/x-wkq 
.wks = application/x-wks 
.wm = video/x-ms-wm 
.wma = audio/x-ms-wma 
.wmd = application/x-ms-wmd 
.wmf = application/x-wmf 
.wml = text/vnd.wap.wml 
.wmv = video/x-ms-wmv 
.wmx = video/x-ms-wmx 
.wmz = application/x-ms-wmz 
.wp6 = application/x-wp6 
.wpd = application/x-wpd 
.wpg = application/x-wpg 
.wpl = application/vnd.ms-wpl 
.wq1 = application/x-wq1 
.wr1 = application/x-wr1 
.wri = application/x-wri 
.wrk = application/x-wrk 
.ws = application/x-ws 
.ws2 = application/x-ws 
.wsc = text/scriptlet 
.wsdl = text/xml 
.wvx = video/x-ms-wvx 
.xdp = application/vnd.adobe.xdp 
.xdr = text/xml 
.xfd = application/vnd.adobe.xfd 
.xfdf = application/vnd.adobe.xfdf 
.xhtml = text/html 
.xls = application/vnd.ms-excel 
.xls = application/x-xls 
.xlw = application/x-xlw 
.xml = text/xml 
.xpl = audio/scpls 
.xq = text/xml 
.xql = text/xml 
.xquery = text/xml 
.xsd = text/xml 
.xsl = text/xml 
.xslt = text/xml 
.xwd = application/x-xwd 
.x_b = application/x-x_b 
.x_t = application/x-x_t 

  从Spring3.0，@Configuration用于定义配置类，可替换xml配置文件，
  被注解的类内部包含有一个或多个被@Bean注解的方法，
  这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，
  并用于构建bean定义，初始化Spring容器。
  
  注意：@Configuration注解的配置类有如下要求：

@Configuration不可以是final类型；
@Configuration不可以是匿名类；
嵌套的configuration必须是静态类。
一、用@Configuration加载spring
1.1、@Configuration配置spring并启动spring容器
1.2、@Configuration启动容器+@Bean注册Bean
1.3、@Configuration启动容器+@Component注册Bean
1.4、使用 AnnotationConfigApplicationContext 注册 AppContext 类的两种方法
1.5、配置Web应用程序(web.xml中配置AnnotationConfigApplicationContext)

二、组合多个配置类
2.1、在@configuration中引入spring的xml配置文件
2.2、在@configuration中引入其它注解配置
2.3、@configuration嵌套（嵌套的Configuration必须是静态类）
三、@EnableXXX注解
四、@Profile逻辑组配置
五、使用外部变量
  
  @Configuation加载Spring方法
1.1、@Configuration配置spring并启动spring容器
@Configuration标注在类上，相当于把该类作为spring的xml配置文件中的<beans>，作用为：配置spring容器(应用上下文)

复制代码
package com.dxz.demo.configuration;

import org.springframework.context.annotation.Configuration;

@Configuration
public class TestConfiguration {
    public TestConfiguration() {
        System.out.println("TestConfiguration容器启动初始化。。。");
    }
}
复制代码
相当于：

复制代码
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context" xmlns:jdbc="http://www.springframework.org/schema/jdbc"  
    xmlns:jee="http://www.springframework.org/schema/jee" xmlns:tx="http://www.springframework.org/schema/tx"
    xmlns:util="http://www.springframework.org/schema/util" xmlns:task="http://www.springframework.org/schema/task" xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd
        http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.0.xsd
        http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd
        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd
        http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd" default-lazy-init="false">


</beans>
复制代码
主方法进行测试：

复制代码
package com.dxz.demo.configuration;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class TestMain {
    public static void main(String[] args) {

        // @Configuration注解的spring容器加载方式，用AnnotationConfigApplicationContext替换ClassPathXmlApplicationContext
        ApplicationContext context = new AnnotationConfigApplicationContext(TestConfiguration.class);

        // 如果加载spring-context.xml文件：
        // ApplicationContext context = new
        // ClassPathXmlApplicationContext("spring-context.xml");
    }
}
复制代码
  
   @Configuation等价于<Beans></Beans>

 @Bean等价于<Bean></Bean>

 @ComponentScan等价于<context:component-scan base-package="com.dxz.demo"/>
  
  在@configuration中引入spring的xml配置文件
复制代码
package com.dxz.demo.configuration2;

import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.ImportResource;

@Configuration
@ImportResource("classpath:applicationContext-configuration.xml")
public class WebConfig {
}
  
 Kaptcha介绍
简单介绍：

kaptcha 是一个扩展自 simplecaptcha 的验证码库，在 Java 编程中 是一个非常实用的验证码生成工具。我们可以利用这个工具生成各种样式的验证码，因为它是可配置的，我们可以根据需求定制。 
工作原理：

kaptcha 的工作原理是调用 com.google.code.kaptcha.servlet.KaptchaServlet ，生成一个验证码图片，响应到客户端，同时将生成的真是的验证码字符串放到 HttpSession 中。 
使用kaptcha可以方便的配置：

验证码的字体
验证码字体的大小
验证码字体的字体颜色
验证码内容的范围(数字，字母，中文汉字！)
验证码图片的大小，边框，边框粗细，边框颜色
验证码的干扰线(可以自己继承com.google.code.kaptcha.NoiseProducer写一个自定义的干扰线)
验证码的样式(鱼眼样式、3D、普通模糊……当然也可以继承com.google.code.kaptcha.GimpyEngine自定义样式) 
  
  定义和用法
cursor 属性规定要显示的光标的类型（形状）。

该属性定义了鼠标指针放在一个元素边界范围内时所用的光标形状（不过 CSS2.1 没有定义由哪个边界确定这个范围）。

默认值：	auto
继承性：	yes
版本：	CSS2
JavaScript 语法：	object.style.cursor="crosshair"
可能的值
值	描述
url	
需使用的自定义光标的 URL。

注释：请在此列表的末端始终定义一种普通的光标，以防没有由 URL 定义的可用光标。

default	默认光标（通常是一个箭头）
auto	默认。浏览器设置的光标。
crosshair	光标呈现为十字线。
pointer	光标呈现为指示链接的指针（一只手）
move	此光标指示某对象可被移动。
e-resize	此光标指示矩形框的边缘可被向右（东）移动。
ne-resize	此光标指示矩形框的边缘可被向上及向右移动（北/东）。
nw-resize	此光标指示矩形框的边缘可被向上及向左移动（北/西）。
n-resize	此光标指示矩形框的边缘可被向上（北）移动。
se-resize	此光标指示矩形框的边缘可被向下及向右移动（南/东）。
sw-resize	此光标指示矩形框的边缘可被向下及向左移动（南/西）。
s-resize	此光标指示矩形框的边缘可被向下移动（南）。
w-resize	此光标指示矩形框的边缘可被向左移动（西）。
text	此光标指示文本。
wait	此光标指示程序正忙（通常是一只表或沙漏）。
help	此光标指示可用的帮助（通常是一个问号或一个气球）。
  
  kaptcha参数设置如下所示：

kaptcha可配置选项
kaptcha.border 是否有边框默认为true 我们可以自己设置yes，no

kaptcha.border.color 边框颜色默认为Color.BLACK

kaptcha.border.thickness 边框粗细度默认为1

kaptcha.producer.impl 验证码生成器默认为DefaultKaptcha

kaptcha.textproducer.impl 验证码文本生成器默DefaultTextCreator

kaptcha.textproducer.char.string 验证码文本字符内容范围默认为abcde2345678gfynmnpwx

kaptcha.textproducer.char.length 验证码文本字符长度默认为5

kaptcha.textproducer.font.names 验证码文本字体样式默认为new Font("Arial", 1, fontSize), new Font("Courier", 1, fontSize)

kaptcha.textproducer.font.size 验证码文本字符大小默认为40

kaptcha.textproducer.font.color 验证码文本字符颜色默认为Color.BLACK

kaptcha.textproducer.char.space 验证码文本字符间距默认为2

kaptcha.noise.impl 验证码噪点生成对象默认为DefaultNoise

kaptcha.noise.color 验证码噪点颜色默认为Color.BLACK

kaptcha.obscurificator.impl 验证码样式引擎默认为WaterRipple

kaptcha.word.impl 验证码文本字符渲染默认为DefaultWordRenderer

kaptcha.background.impl 验证码背景生成器默认为DefaultBackground

kaptcha.background.clear.from 验证码背景颜色渐进默认为Color.LIGHT_GRAY

kaptcha.background.clear.to 验证码背景颜色渐进默认为Color.WHITE

kaptcha.image.width 验证码图片宽度默认为200

kaptcha.image.height 验证码图片高度默认为50
  
标签img 读取数据流中的图片 达到点击更换图片的效果
1响应头设置禁止缓存
	response.setHeader("Cache-Control","no-store, no-cache");
2更换src地址
	<img id="kaptcha" alt="验证码" src="/getKaptcha"
         onclick = "this.src='/getKaptcha?d='+new Date()*1" />
至少实现一个,实现两个也可以
  
  Spring Boot 之Spring Boot Starter依赖包及作用

spring-boot-starter 
这是Spring Boot的核心启动器，包含了自动配置、日志和YAML。

spring-boot-starter-amqp 
通过spring-rabbit来支持AMQP协议（Advanced Message Queuing Protocol. 。

spring-boot-starter-aop 
支持面向方面的编程即AOP，包括spring-aop和AspectJ。

spring-boot-starter-artemis 
通过Apache Artemis支持JMS的API（Java Message Service API. 。

spring-boot-starter-batch 
支持Spring Batch，包括HSQLDB数据库。

spring-boot-starter-cache 
支持Spring的Cache抽象。

spring-boot-starter-cloud-connectors 
支持Spring Cloud Connectors，简化了在像Cloud Foundry或Heroku这样的云平台上连接服务。

spring-boot-starter-data-elasticsearch 
支持ElasticSearch搜索和分析引擎，包括spring-data-elasticsearch。

spring-boot-starter-data-gemfire 
支持GemFire分布式数据存储，包括spring-data-gemfire。

spring-boot-starter-data-jpa 
支持JPA（Java Persistence API. ，包括spring-data-jpa、spring-orm、Hibernate。

spring-boot-starter-data-mongodb 
支持MongoDB数据，包括spring-data-mongodb。

spring-boot-starter-data-rest 
通过spring-data-rest-webmvc，支持通过REST暴露Spring Data数据仓库。

spring-boot-starter-data-solr 
支持Apache Solr搜索平台，包括spring-data-solr。

spring-boot-starter-freemarker 
支持FreeMarker模板引擎。

spring-boot-starter-groovy-templates 
支持Groovy模板引擎。

spring-boot-starter-hateoas 
通过spring-hateoas支持基于HATEOAS的RESTful Web服务。

spring-boot-starter-hornetq 
通过HornetQ支持JMS。

spring-boot-starter-integration 
支持通用的spring-integration模块。

spring-boot-starter-jdbc 
支持JDBC数据库。

spring-boot-starter-jersey 
支持Jersey RESTful Web服务框架。

spring-boot-starter-jta-atomikos 
通过Atomikos支持JTA分布式事务处理。

spring-boot-starter-jta-bitronix 
通过Bitronix支持JTA分布式事务处理。

spring-boot-starter-mail 
支持javax.mail模块。

spring-boot-starter-mobile 
支持spring-mobile。

spring-boot-starter-mustache 
支持Mustache模板引擎。

spring-boot-starter-redis 
支持Redis键值存储数据库，包括spring-redis。

spring-boot-starter-security 
支持spring-security。

spring-boot-starter-social-facebook 
支持spring-social-facebook

spring-boot-starter-social-linkedin 
支持pring-social-linkedin

spring-boot-starter-social-twitter 
支持pring-social-twitter

spring-boot-starter-test 
支持常规的测试依赖，包括JUnit、Hamcrest、Mockito以及spring-test模块。

spring-boot-starter-thymeleaf 
支持Thymeleaf模板引擎，包括与Spring的集成。

spring-boot-starter-velocity 
支持Velocity模板引擎。

spring-boot-starter-web 
S支持全栈式Web开发，包括Tomcat和spring-webmvc。

spring-boot-starter-websocket 
支持WebSocket开发。

spring-boot-starter-ws 
支持Spring Web Services。 
Spring Boot应用启动器面向生产环境的还有2种，具体如下：

spring-boot-starter-actuator 
增加了面向产品上线相关的功能，比如测量和监控。

spring-boot-starter-remote-shell 
增加了远程ssh shell的支持。 
最后，Spring Boot应用启动器还有一些替换技术的启动器，具体如下：

spring-boot-starter-jetty 
引入了Jetty HTTP引擎（用于替换Tomcat. 。

spring-boot-starter-log4j 
支持Log4J日志框架。

spring-boot-starter-logging 
引入了Spring Boot默认的日志框架Logback。

spring-boot-starter-tomcat 
引入了Spring Boot默认的HTTP引擎Tomcat。

spring-boot-starter-undertow 
引入了Undertow HTTP引擎（用于替换Tomcat. 。
  
  
  spring boot中可以设置默认首页，当输入域名是可以自动跳转到默认指定的网页

@Configuration
public class DefaultView extends WebMvcConfigurerAdapter{

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/").setViewName("forward:/index");
        registry.setOrder(Ordered.HIGHEST_PRECEDENCE);
        super.addViewControllers(registry);
    } 
}
  
  springboot 修改视图路径或者后缀需要使用到视图引擎
  HTML
  <dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-thymeleaf</artifactId>
	</dependency>
  
  @ConfigurationProperties(prefix = "student")：表示获取前缀为 sutdent 的配置信息
  
   Date date = new Date();        //创建日期对象

   //获得日期/时间格式器，该格式器具有默认语言环境的默认格式化风格

    DateFormat df = DateFormat.getDateTimeInstance ();

    String formatDate = df.format(date);     //格式化日期

	DateFormat.getDateTimeInstance().format(new Date())	
  
  
  springboot中返回页面需要使用模版
  
	  HTML 
	  
		pom 
		
		  <dependency>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-starter-thymeleaf</artifactId>
				</dependency>
		
		yml
		
			spring:
				thymeleaf:
				  prefix: classpath:/jsp/
				  suffix: .html
				  cache: false
	  
		HTML中使用后台数据
		
			<html xmlns="http://www.w3.org/1999/xhtml"
		  xmlns:th="http://www.thymeleaf.org">
		  
		  <a href="#" th:text="${now}">Title ...</a>
	  
	mockmvc

基于RESTful风格的SpringMVC的测试，我们可以测试完整的Spring MVC流程，
	即从URL请求到控制器处理，再到视图渲染都可以测试。
  
  springmvc之单元测试（MockMvc）-独立测试
  @Test
	public void getHello() throws Exception {
		/*spring mvc测试框架提供了两种方式，独立安装和集成Web环境测试（此种方式并不会集成真正的web环境，而是通过相应的Mock API进行模拟测试，无须启动服务器）
		1、mockMvc.perform执行一个请求；
		2、MockMvcRequestBuilders.get("/user/1")构造一个请求
		3、ResultActions.andExpect添加执行完成后的断言
		4、ResultActions.andDo添加一个结果处理器，表示要对结果做点什么事情，比如此处使用MockMvcResultHandlers.print()输出整个响应结果信息。
		5、ResultActions.andReturn表示执行完成后返回相应的结果。*/
		mvc.perform(MockMvcRequestBuilders.get("/hello")
				.accept(MediaType.APPLICATION_JSON))
				.andExpect(MockMvcResultMatchers.status().isOk())
				.andDo(MockMvcResultHandlers.print())
				.andReturn();
	}
  
  MockMvcBuilder是用来构造MockMvc的构造器，其主要有两个实现：StandaloneMockMvcBuilder和DefaultMockMvcBuilder，StandaloneMockMvcBuilder继承了DefaultMockMvcBuilder。直接使用静态工厂MockMvcBuilders创建即可：

MockMvcBuilders.webAppContextSetup(WebApplicationContext context)：指定WebApplicationContext，将会从该上下文获取相应的控制器并得到相应的MockMvc；

MockMvcBuilders.standaloneSetup(Object... controllers)：通过参数指定一组控制器，这样就不需要从上下文获取了；

其中DefaultMockMvcBuilder还提供了如下API：

addFilters(Filter... filters)/addFilter(Filter filter, String... urlPatterns)：添加javax.servlet.Filter过滤器

defaultRequest(RequestBuilder requestBuilder)：默认的RequestBuilder，每次执行时会合并到自定义的RequestBuilder中，即提供公共请求数据的；

alwaysExpect(ResultMatcher resultMatcher)：定义全局的结果验证器，即每次执行请求时都进行验证的规则；

alwaysDo(ResultHandler resultHandler)：定义全局结果处理器，即每次请求时都进行结果处理；

dispatchOptions：DispatcherServlet是否分发OPTIONS请求方法到控制器；

 

StandaloneMockMvcBuilder继承了DefaultMockMvcBuilder，又提供了如下API：

setMessageConverters(HttpMessageConverter<?>...messageConverters)：设置HTTP消息转换器；

setValidator(Validator validator)：设置验证器；

setConversionService(FormattingConversionService conversionService)：设置转换服务；

addInterceptors(HandlerInterceptor... interceptors)/addMappedInterceptors(String[] pathPatterns, HandlerInterceptor... interceptors)：添加spring mvc拦截器；

setContentNegotiationManager(ContentNegotiationManager contentNegotiationManager)：设置内容协商管理器；

setAsyncRequestTimeout(long timeout)：设置异步超时时间；

setCustomArgumentResolvers(HandlerMethodArgumentResolver... argumentResolvers)：设置自定义控制器方法参数解析器；

setCustomReturnValueHandlers(HandlerMethodReturnValueHandler... handlers)：设置自定义控制器方法返回值处理器；

setHandlerExceptionResolvers(List<HandlerExceptionResolver> exceptionResolvers)/setHandlerExceptionResolvers(HandlerExceptionResolver... exceptionResolvers)：设置异常解析器；

setViewResolvers(ViewResolver...resolvers)：设置视图解析器；

setSingleView(View view)：设置单个视图，即视图解析时总是解析到这一个（仅适用于只有一个视图的情况）；

setLocaleResolver(LocaleResolver localeResolver)：设置Local解析器；

setFlashMapManager(FlashMapManager flashMapManager)：设置FlashMapManager，如存储重定向数据；

setUseSuffixPatternMatch(boolean useSuffixPatternMatch)：设置是否是后缀模式匹配，如“/user”是否匹配"/user.*"，默认真即匹配；

setUseTrailingSlashPatternMatch(boolean useTrailingSlashPatternMatch)：设置是否自动后缀路径模式匹配，如“/user”是否匹配“/user/”，默认真即匹配；

addPlaceHolderValue(String name, String value) ：添加request mapping中的占位符替代；

因为StandaloneMockMvcBuilder不会加载Spring MVC配置文件，因此就不会注册我们需要的一些组件，因此就提供了如上API用于注册我们需要的相应组件。

　　

　　perform：执行一个RequestBuilder请求，会自动执行SpringMVC的流程并映射到相应的控制器执行处理；

　　andExpect：添加ResultMatcher验证规则，验证控制器执行完成后结果是否正确；

　　andDo：添加ResultHandler结果处理器，比如调试时打印结果到控制台；

　　andReturn：最后返回相应的MvcResult；然后进行自定义验证/进行下一步的异步处理；

 

MockMvcRequestBuilders主要API：

MockHttpServletRequestBuilder get(String urlTemplate, Object... urlVariables)：根据uri模板和uri变量值得到一个GET请求方式的MockHttpServletRequestBuilder；如get("/user/{id}", 1L)；

MockHttpServletRequestBuilder post(String urlTemplate, Object... urlVariables)：同get类似，但是是POST方法；

MockHttpServletRequestBuilder put(String urlTemplate, Object... urlVariables)：同get类似，但是是PUT方法；

MockHttpServletRequestBuilder delete(String urlTemplate, Object... urlVariables) ：同get类似，但是是DELETE方法；

MockHttpServletRequestBuilder options(String urlTemplate, Object... urlVariables)：同get类似，但是是OPTIONS方法；

 

ResultActions
调用MockMvc.perform(RequestBuilder requestBuilder)后将得到ResultActions，通过ResultActions完成如下三件事：

ResultActions andExpect(ResultMatcher matcher) ：添加验证断言来判断执行请求后的结果是否是预期的；

ResultActions andDo(ResultHandler handler) ：添加结果处理器，用于对验证成功后执行的动作，如输出下请求/结果信息用于调试；

MvcResult andReturn() ：返回验证成功后的MvcResult；用于自定义验证/下一步的异步处理；(主要是拿到结果进一步做自定义断言)

 

String requestBody = "{\"id\":1, \"name\":\"zhang\"}";  
mockMvc.perform(post("/user")  
            .contentType(MediaType.APPLICATION_JSON).content(requestBody)  
            .accept(MediaType.APPLICATION_JSON)) //执行请求  
        .andExpect(content().contentType(MediaType.APPLICATION_JSON)) //验证响应contentType  
        .andExpect(jsonPath("$.id").value(1)); //使用Json path验证JSON 请参考http://goessner.net/articles/JsonPath/  
  
String errorBody = "{id:1, name:zhang}";  
MvcResult result = mockMvc.perform(post("/user")  
        .contentType(MediaType.APPLICATION_JSON).content(errorBody)  
        .accept(MediaType.APPLICATION_JSON)) //执行请求  
        .andExpect(status().isBadRequest()) //400错误请求  
        .andReturn(); 
 

import org.junit.Before;
import org.junit.runner.RunWith;
import org.junit.Test;
import org.springframework.boot.SpringBootConfiguration;
import org.springframework.boot.test.SpringApplicationConfiguration;
import org.springframework.http.MediaType;
import org.springframework.mock.web.MockSessionCookieConfig;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.RequestBuilder;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
import org.springframework.test.web.servlet.result.MockMvcResultHandlers;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.sselab.controller.HelloController;
import org.sselab.controller.TestController;

import java.nio.charset.Charset;

import static org.hamcrest.Matchers.equalTo;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

/**
 * Created by pinker on 2016/10/26.
 */
@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = MockSessionCookieConfig.class)
@WebAppConfiguration
public class TestJunit {
    private MockMvc mvc;

    @Before
    public void setUp() throws Exception {
        mvc = MockMvcBuilders.standaloneSetup(new HelloController(), new TestController()).build();
    }

    @Test
    public void testHelloController() throws Exception {
        mvc.perform(MockMvcRequestBuilders.get("/hello").accept(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(content().string(equalTo("Hello")));
    }

    @Test
    public void testController() throws Exception {
        //get查一下列表应该为空。
        RequestBuilder request = null;
        request = get("/user");
        mvc.perform(request)
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isOk())
                .andExpect(content().string(equalTo("[]")));
        //插入一个数据
        request = post("/user").param("id", "2").param("name", "HS").param("age", "24");
        mvc.perform(request)
                .andDo(MockMvcResultHandlers.print())
                .andExpect(content().string(equalTo("success")));
        //检查刚才插入的数据
        request = get("/user");
        mvc.perform(request)
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isOk())
                .andExpect(content().string(equalTo("[{\"id\":2,\"name\":\"HS\",\"age\":24}]")));
        //测试put方法
        request = put("/user/2")
                .param("name", "HGod")
                .param("age", "24");
        mvc.perform(request)
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isOk())
                .andExpect(content().string(equalTo("success!")));
        //测试获得一个用户的get方法
        request=get("/user/2");
        mvc.perform(request)
                .andDo(MockMvcResultHandlers.print())
                .andExpect(content().string(equalTo("{\"id\":2,\"name\":\"HGod\",\"age\":24}")));
        //测试删除用户
        request=delete("/user/2");
        mvc.perform(request)
                .andDo(MockMvcResultHandlers.print())
                .andExpect(content().string(equalTo("success")))
                .andReturn();
    }
}
  
  开发环境的调试

热启动在正常开发项目中已经很常见了吧，虽然平时开发web项目过程中，
改动项目启重启总是报错；但springBoot对调试支持很好，修改之后可以实时生效，需要添加以下的配置：
  <!-- 热启动 -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<optional>true</optional>
		</dependency>
  
  <!-- 热启动 -->
	<build>
		<plugins>
			<plugin>
				<!-- 热启动 -->
				<configuration>
	                <fork>true</fork>
	            </configuration>
				
			</plugin>
		</plugins>
	</build>  
  
  我们常常在项目中会使用filters用于录调用日志、排除有XSS威胁的字符、执行权限验证等等。
  Spring Boot自动添加了OrderedCharacterEncodingFilter和HiddenHttpMethodFilter，并且我们可以自定义Filter。
  OrderedCharacterEncodingFilter命令字符编码过滤器
  
Hidden Http Method Filter隐藏的Http方法过滤
  
  
   浏览器form表单只支持GET与POST请求，而DELETE、PUT等method并不支持，spring3.0添加了一个过滤器，
   可以将这些请求转换为标准的http方法，使得支持GET、POST、PUT与DELETE请求，该过滤器为HiddenHttpMethodFilter。

        HiddenHttpMethodFilter的父类是OncePerRequestFilter，它继承了父类的doFilterInternal方法，
		工作原理是将jsp页面的form表单的method属性值在doFilterInternal方法中转化为标准的Http方法，
		即GET,、POST、 HEAD、OPTIONS、PUT、DELETE、TRACE，然后到Controller中找到对应的方法。
		例如，在使用注解时我们可能会在Controller中用于@RequestMapping(value = "list", method = RequestMethod.PUT)，
		所以如果你的表单中使用的是<form method="put">，那么这个表单会被提交到标了Method="PUT"的方法中。

        需要注意的是，由于doFilterInternal方法只对method为post的表单进行过滤，所以在页面中必须如下设置：


<form action="..." method="post">
        <input type="hidden" name="_method" value="put" />
        ......
</form>

        而不是使用：

<form action="..." method="put">
        ......
</form>

        同时，HiddenHttpMethodFilter必须作用于dispatcher前，所以在web.xml中配置HiddenHttpMethodFilter时，需参照如下代码：

        <filter>  
                <filter-name>HiddenHttpMethodFilter</filter-name>  
                <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>  
        </filter>  
        <filter-mapping>  
                <filter-name>HiddenHttpMethodFilter</filter-name>  
                <servlet-name>spring</servlet-name>  
        </filter-mapping>
        <servlet>
		<servlet-name>spring</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>classpath:dispatcher.xml</param-value>
		</init-param>
	</servlet>
        <servlet-mapping>
		<servlet-name>spring</servlet-name>
		<url-pattern>*.html</url-pattern>
	</servlet-mapping>

        同样的，作为Filter，可以在web.xml中配置HiddenHttpMethodFilter的参数，
		可配置的参数为methodParam，值必须为GET,、POST、 HEAD、OPTIONS、PUT、DELETE、TRACE中的一个。
  
  现在假设我们的应用程序运行在一台负载均衡代理服务器后方，因此需要将代理服务器发来的请求包含的IP地址转换成真正的用户IP。
  Tomcat 8 提供了对应的过滤器：RemoteIpFilter。通过将RemoteFilter这个过滤器加入过滤器调用链即可使用它。
  
  1.一般filter都是一个链,web.xml 里面配置了几个就有几个。一个一个的连在一起 
request -> filter1 -> filter2 ->filter3 -> …. -> request resource.

2.chain.doFilter将请求转发给过滤器链下一个filter , 如果没有filter那就是你请求的资源
  
 /*
		 * Spring 提供了FilterRegistrationBean类，
		 * 此类提供setOrder方法，可以为filter设置排序值，
		 * 让spring在注册web filter之前排序后再依次注册。
		 */ 
  
  
 在正常的Spring MVC 框架中使用Filter时需要在XML文件中配置

<filter>
    <filter-name>xxxFilter</filter-name>
    <filter-class>xx.xx.xx.xx.xxxFilter</filter-class>
</filter>
<filter-mapping>
    <filter-name>xxxFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>

但是在Spring boot 中抛弃了XML配置，所以要在启动主函数中添加
@Bean
public FilterRegistrationBean filterRegistrationBean() {
   FilterRegistrationBean registrationBean = new FilterRegistrationBean();
   WeChatFilter weChatFilter = new WeChatFilter();
   registrationBean.setFilter(weChatFilter);
   List<String> urlPatterns = new ArrayList<String>();
   urlPatterns.add("/validate/*");
   registrationBean.setUrlPatterns(urlPatterns);
   return registrationBean;
} 
  
public FilterRegistrationBean testFilterRegistration(){
		FilterRegistrationBean registration = new FilterRegistrationBean();
		registration.setFilter(new MyFilter());
		registration.addUrlPatterns("/*");
		registration.addInitParameter("paramName", "paramValue");
		registration.setName("MyFilter");
		/*
		 * Spring 提供了FilterRegistrationBean类，
		 * 此类提供setOrder方法，可以为filter设置排序值，
		 * 让spring在注册web filter之前排序后再依次注册。
		 */
        registration.setOrder(1);
		return registration;
	}  
  
  springboot测试
 @RunWith(SpringRunner.class)
@SpringBootTest
public class DemoApplicationTests {
	private MockMvc mvc;
	
	@Before
	public void setUp(){
		/*
		 * standalone Setup独立设置
		 * build建造
		 */
		mvc = MockMvcBuilders.standaloneSetup(
				new HelloController()).build();
	}

	@Test
	public void getHello() throws Exception {
		/*spring mvc测试框架提供了两种方式，独立安装和集成Web环境测试（此种方式并不会集成真正的web环境，而是通过相应的Mock API进行模拟测试，无须启动服务器）
		1、mockMvc.perform执行一个请求；
		2、MockMvcRequestBuilders.get("/user/1")构造一个请求
		3、ResultActions.andExpect添加执行完成后的断言
		4、ResultActions.andDo添加一个结果处理器，表示要对结果做点什么事情，比如此处使用MockMvcResultHandlers.print()输出整个响应结果信息。
		5、ResultActions.andReturn表示执行完成后返回相应的结果。*/
		mvc.perform(MockMvcRequestBuilders.get("/hello")
				.accept(MediaType.APPLICATION_JSON))
				.andExpect(MockMvcResultMatchers.status().isOk())
				.andDo(MockMvcResultHandlers.print())
				.andReturn();
	} 
  
  
  自定义Filter
我们常常在项目中会使用filters用于录调用日志、排除有XSS威胁的字符、执行权限验证等等。Spring Boot自动添加了OrderedCharacterEncodingFilter和HiddenHttpMethodFilter，并且我们可以自定义Filter。

两个步骤：

实现Filter接口，实现Filter方法
添加@Configuration 注解，将自定义Filter加入过滤链
好吧，直接上代码

@Configuration
public class WebConfiguration {
    @Bean
    public RemoteIpFilter remoteIpFilter() {
        return new RemoteIpFilter();
    }
    
    @Bean
    public FilterRegistrationBean testFilterRegistration() {

        FilterRegistrationBean registration = new FilterRegistrationBean();
        registration.setFilter(new MyFilter());
        registration.addUrlPatterns("/*");
        registration.addInitParameter("paramName", "paramValue");
        registration.setName("MyFilter");
        registration.setOrder(1);
        return registration;
    }
    
    public class MyFilter implements Filter {
		@Override
		public void destroy() {
			// TODO Auto-generated method stub
		}

		@Override
		public void doFilter(ServletRequest srequest, ServletResponse sresponse, FilterChain filterChain)
				throws IOException, ServletException {
			// TODO Auto-generated method stub
			HttpServletRequest request = (HttpServletRequest) srequest;
			System.out.println("this is MyFilter,url :"+request.getRequestURI());
			filterChain.doFilter(srequest, sresponse);
		}

		@Override
		public void init(FilterConfig arg0) throws ServletException {
			// TODO Auto-generated method stub
		}
    }
}
  
  这个hibernate.hbm2ddl.auto参数的作用主要用于：自动创建|更新|验证数据库表结构。如果不是此方面的需求建议set value="none"。
create：
   每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。
create-drop ：
    每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。
update：
    最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。
validate ：
    每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。
  
spring.datasource.url=jdbc:mysql://localhost:3306/test
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.jdbc.Driver

spring.jpa.properties.hibernate.hbm2ddl.auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect
spring.jpa.show-sql= true
其实这个hibernate.hbm2ddl.auto参数的作用主要用于：自动创建|更新|验证数据库表结构,有四个值：

create： 每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，
			哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。
			
create-drop ：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。

update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），
			以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。
			要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等 应用第一次运行起来后才会。
			
validate ：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。

dialect 主要是指定生成表名的存储引擎为InneoDB

show-sql 是否打印出自动生产的SQL，方便调试的时候查看

  
dao只要继承JpaRepository类就可以，几乎可以不用写方法，就是可以根据方法名来自动的生产SQL，
比如findByUserName 会自动生产一个以 userName 为参数的查询方法，
比如 findAlll 自动会查询表里面的所有数据，比如自动分页等等。。  
  
  
 WebJars——web端静态资源的jar包 
  1、WebJars介绍

Web前端使用了越来越多的JS或CSS，如jQuery，Backbone.js和Bootstrap。一般情况下，我们是将这些Web资源拷贝到Java Web项目的webapp相应目录下进行管理。这种通过人工方式管理可能会产生版本误差，拷贝版本错误，漏拷等现象，导致前端页面无法正确展示，版本不一致，文件混乱等，导致出现一些莫名其妙的错误等。

WebJars是将web前端资源（js，css等）打成jar包文件，然后借助Maven工具，以jar包形式对web前端资源进行统一依赖管理，保证这些Web资源版本唯一性。WebJars的jar包部署在Maven中央仓库上。

WebJars官网：http://www.webjars.org/

2、WebJars使用

2.1 pom.xml
<dependencies>
    <dependency>
            <groupId>org.webjars</groupId>
            <artifactId>jquery</artifactId>
            <version>2.2.4</version>
        </dependency>
        <dependency>
            <groupId>org.webjars</groupId>
            <artifactId>bootstrap</artifactId>
            <version>3.3.6</version>
        </dependency>
</dependencies>
2.2 引用

2.2.1 静态页面
<link rel='stylesheet' href='webjars/bootstrap/3.3.6/css/bootstrap.min.css'>

<script type='text/javascript' src='webjars/bootstrap/3.3.6/js/bootstrap.min.js'></script>

<script type='text/javascript' src='webjars/jquery/2.2.4/jquery.min.js'></script>

2.2.2 jsp页面

<link rel='stylesheet'  href="<%=request.getContextPath() %>/webjars/bootstrap/3.3.6/css/bootstrap.min.css"/>

<script type="text/javascript" src="<%=request.getContextPath() %>/webjars/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<script type="text/javascript" src="<%=request.getContextPath() %>/webjars/jquery/2.2.4/jquery.min.js"></script>
  
  
springboot整合redis
<!-- redis缓存 -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>  
 经认证，在spring boot的版本号为1.5.0的时候 添加spring-boot-starter-reids就找不到jar包了,
 也就是这个jar包直接被废弃了。所以千万要注意的是：
 如果你的spring boot的版本号在1.5.0以后的，添加redis的jar包就必须是spring-boot-starter-data-redis
  
  /* CachingConfigurerSupport缓存配置支持
 * 通过继承CachingConfigurerSupport，将Spring-Cache的缓存换为Redis 
 */
public class RedisConfig extends CachingConfigurerSupport{

  @EnableCaching springboot缓存
  

 /*
	 * @SuppressWarings注解
	 * 作用：用于抑制编译器产生警告信息。
	 * rawtypes是说传参时也要传递带泛型的参数
	 */
	@SuppressWarnings("rawtypes") 
  
  spring 封装了 RedisTemplate 对象来进行对redis的各种操作，它支持所有的 redis 原生的 api。
  Type Parameters:
K

the Redis key type against which the template works (usually a String)
模板中的Redis key的类型（通常为String）如：RedisTemplate<String, Object>
注意：如果没特殊情况，切勿定义成RedisTemplate<Object, Object>，否则根据里氏替换原则，使用的时候会造成类型错误 。
V
the Redis value type against which the template works
模板中的Redis value的类型
  两者的关系是StringRedisTemplate继承RedisTemplate。

两者的数据是不共通的；也就是说StringRedisTemplate只能管理StringRedisTemplate里面的数据，RedisTemplate只能管理RedisTemplate中的数据。

SDR默认采用的序列化策略有两种，一种是String的序列化策略，一种是JDK的序列化策略。

StringRedisTemplate默认采用的是String的序列化策略，保存的key和value都是采用此策略序列化保存的。

RedisTemplate默认采用的是JDK的序列化策略，保存的key和value都是采用此策略序列化保存的。
  
 springboot 2.0配置redis 
  spring:
  redis:
    host: 127.0.0.1
    port: 6379
    database: 0
    timeout: 60s  # 数据库连接超时时间，2.0 中该参数的类型为Duration，这里在配置的时候需要指明单位
    # 连接池配置，2.0中直接使用jedis或者lettuce配置连接池
    jedis:
      pool:
        # 最大空闲连接数
        max-idle: 500
        # 最小空闲连接数
        min-idle: 50
        # 等待可用连接的最大时间，负数为不限制
        max-wait:  -1s
        # 最大活跃连接数，负数为不限制
        max-active: -1
  
  # REDIS
# Redis数据库索引（默认为0）
spring.redis.database=0  
# Redis服务器地址 （默认为127.0.0.1）
spring.redis.host=127.0.0.1
# Redis服务器连接端口 （默认为6379）
spring.redis.port=6379  
# Redis服务器连接密码（默认为空）
spring.redis.password=  
# 连接超时时间（毫秒）
spring.redis.timeout=2000
  
 springboot2.0整合redis案例
2018年03月13日 10:39:11
阅读数：9506
首先创建一个springboot项目。

添加pom配置：

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
pom配置文件内容为：

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
 
	<groupId>com.pangjh</groupId>
	<artifactId>springboot-redis</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>jar</packaging>
 
	<name>springboot-redis</name>
	<description>redis缓存</description>
 
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.0.0.RELEASE</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
 
	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
		<java.version>1.8</java.version>
	</properties>
 
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
 
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
	</dependencies>
 
    <build>
	    <plugins>
	        <plugin>
	            <groupId>org.springframework.boot</groupId>  
	            <artifactId>spring-boot-maven-plugin</artifactId>
	        </plugin>
	   </plugins>
	</build>
 
 
</project>
创建redis配置文件RedisConfig.java：



内容为：

package com.pangjh.conf;
 
import java.util.concurrent.CountDownLatch;
 
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CachingConfigurerSupport;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.listener.PatternTopic;
import org.springframework.data.redis.listener.RedisMessageListenerContainer;
import org.springframework.data.redis.listener.adapter.MessageListenerAdapter;
 
 
/**
 * redis配置
 * @author pangjianhui
 *
 */
@Configuration
@EnableCaching
public class RedisConfig extends CachingConfigurerSupport {
	
	@Bean
	RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory,
			MessageListenerAdapter listenerAdapter) {
 
		RedisMessageListenerContainer container = new RedisMessageListenerContainer();
		container.setConnectionFactory(connectionFactory);
		container.addMessageListener(listenerAdapter, new PatternTopic("chat"));
 
		return container;
	}
 
	@Bean
	MessageListenerAdapter listenerAdapter(Receiver receiver) {
		return new MessageListenerAdapter(receiver, "receiveMessage");
	}
 
	@Bean
	Receiver receiver(CountDownLatch latch) {
		return new Receiver(latch);
	}
 
	@Bean
	CountDownLatch latch() {
		return new CountDownLatch(1);
	}
 
	@Bean
	StringRedisTemplate template(RedisConnectionFactory connectionFactory) {
		return new StringRedisTemplate(connectionFactory);
	}
	
	public class Receiver { 
		
 
		private CountDownLatch latch;
		
		@Autowired
		public Receiver(CountDownLatch latch) {
		    this.latch = latch;
		}
		
		public void receiveMessage(String message) {
		    latch.countDown();
		}
	}
	
	
}
redis配置：

# REDIS
# Redis数据库索引（默认为0）
spring.redis.database=0  
# Redis服务器地址 （默认为127.0.0.1）
spring.redis.host=127.0.0.1
# Redis服务器连接端口 （默认为6379）
spring.redis.port=6379  
# Redis服务器连接密码（默认为空）
spring.redis.password=  
# 连接超时时间（毫秒）
spring.redis.timeout=2000
以上操作基本完成了springboot2.0与redis的整合，下面我们测试使用：

通过代码方式使用redis
    编写controller：

package com.pangjh.controller;
 
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
 
 
@RestController
public class PangjhController {
	
	@Autowired
	private StringRedisTemplate template;
    
    @RequestMapping("/setValue")
    public String setValue(){
    	if(!template.hasKey("shabao")){
    		template.opsForValue().append("shabao", "我是傻宝");
    		return "使用redis缓存保存数据成功";
    	}else{
    		template.delete("shabao");
    		return "key已存在";
    	}
    }
    
    @RequestMapping("/getValue")
    public String getValue(){
    	
    	if(!template.hasKey("shabao")){
    		return "key不存在，请先保存数据";
    	}else{
    		String shabao = template.opsForValue().get("shabao");//根据key获取缓存中的val 
    		return "获取到缓存中的数据：shabao="+shabao;
    	}
    }
 
}
启动项目（注意这里启动项目需要确保redis服务的开启状态）

请求：http://localhost:8080/setValue 
  
 在RedisTemplate中，已经提供了一个工厂方法:opsForValue()。这个方法会返回一个默认的操作类 
 通过继承CachingConfigurerSupport，将Spring-Cache的缓存换为Redis  
  
java.util.concurrent.CountDownLatch类详解及例子
2013年08月13日 19:58:19
阅读数：4174
从名字可以看出，CountDownLatch是一个倒数计数的锁，
当倒数到0时触发事件，也就是开锁，其他人就可以进入了。
在一些应用场合中，需要等待某个条件达到要求后才能做后面的事情；同时当线程都完成后也会触发事件，以便进行后面的操作。


CountDownLatch最重要的方法是countDown()和await()，前者主要是倒数一次，后者是等待倒数到0，如果没有到达0，就只有阻塞等待了。

 

CountDownLatch类是一个同步计数器,构造时传入int参数,该参数就是计数器的初始值，
每调用一次countDown()方法，计数器减1,计数器大于0 时，await()方法会阻塞程序继续执行。
CountDownLatch可以看作是一个倒计数的锁存器，当计数减至0时触发特定的事件。利用这种特性，
可以让主线程等待子线程的结束。下面以一个模拟运动员比赛的例子加以说明。

 CountDownLatch的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。
 假如我们这个想要继续往下执行的任务调用一个CountDownLatch对象的await()方法，
 其他的任务执行完自己的任务后调用同一个CountDownLatch对象上的countDown()方法，
 这个调用await()方法的任务将一直阻塞等待，直到这个CountDownLatch对象的计数值减到0为止。

下面的例子简单的说明了CountDownLatch的使用方法，模拟了100米赛跑，10名选手已经准备就绪，
只等裁判一声令下。当所有人都到达终点时，比赛结束。



package com.eyesmore.concurrent;   
  
import java.util.concurrent.CountDownLatch;   
import java.util.concurrent.ExecutorService;   
import java.util.concurrent.Executors;   
  
public class CountDownLatchDemo {   
  
    private static final int PLAY_AMOUNT = 10;   
       
    public static void main(String[] args) {   
  
        /*
          * 比赛开始：只要裁判说开始，那么所有跑步选手就可以开始跑了
          * */  
         CountDownLatch begin = new CountDownLatch(1);   
           
        /*
          * 每个队员跑到末尾时，则报告一个到达，所有人员都到达时，则比赛结束
          * */  
         CountDownLatch end = new CountDownLatch(PLAY_AMOUNT);   
         Player[] plays = new Player[PLAY_AMOUNT];   
        for(int i = 0;i<PLAY_AMOUNT;i++) {   
             plays[i] = new Player(i+1,begin,end);   
         }   
         ExecutorService exe = Executors.newFixedThreadPool(PLAY_AMOUNT);   
        for(Player p : plays) {//各就各位   
             exe.execute(p);   
         }   
         System.out.println("比赛开始");   
         begin.countDown();//宣布开始   
        try {   
             end.await();//等待结束   
         } catch (InterruptedException e) {   
             e.printStackTrace();   
         } finally {   
             System.out.println("比赛结束");   
         }   
           
        //注意：此时main线程已经要结束了，但是exe线程如果不关闭是不会结束的   
         exe.shutdown();   
     }   
  
}   
  
  
class Player implements Runnable {   
  
    private int id;   
       
    private CountDownLatch begin;   
       
    private CountDownLatch end;   
  
    public Player(int id, CountDownLatch begin, CountDownLatch end) {   
        super();   
        this.id = id;   
        this.begin = begin;   
        this.end = end;   
     }   
  
    public void run() {   
        try {   
             begin.await();//必须等到裁判countdown到0的时候才开始   
             Thread.sleep((long)(Math.random()*100));//模拟跑步需要的时间   
             System.out.println("Play "+id+" has arrived. ");   
               
         } catch (InterruptedException e) {   
             e.printStackTrace();   
         } finally {   
             end.countDown();//向评委报告跑到终点了   
         }   
     }   
}  
  
  
RedisTemplate和StringRedisTemplate  
跟JdbcTemplate一样封装了对Redis的一些常用的操作，
当然StringRedisTemplate跟RedisTemplate功能类似那么肯定就会有人问，
为什么会需要两个Template呢，一个不就够了吗？其实他们两者之间的区别主要在于他们使用的序列化类。

RedisTemplate使用的是 JdkSerializationRedisSerializer
StringRedisTemplate使用的是 StringRedisSerializer

RedisTemplate使用的序列类在在操作数据的时候，比如说存入数据会将数据先序列化成字节数组
然后在存入Redis数据库，这个时候打开Redis查看的时候，你会看到你的数据不是以可读的形式
展现的，而是以字节数组显示  
  
 共享Session-spring-session-data-redis
分布式系统中，sessiong共享有很多的解决方案，其中托管到缓存中应该是最常用的方案之一，

Spring Session官方说明
Spring Session provides an API and implementations for managing a user’s session information.

如何使用
1、引入依赖

<dependency>
    <groupId>org.springframework.session</groupId>
    <artifactId>spring-session-data-redis</artifactId>
</dependency>
2、Session配置：

@Configuration
@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 86400*30)
public class SessionConfig {
}
maxInactiveIntervalInSeconds: 设置Session失效时间，使用Redis Session之后，原Boot的server.session.timeout属性不再生效

好了，这样就配置好了，我们来测试一下

3、测试

添加测试方法获取sessionid

@RequestMapping("/uid")
    String uid(HttpSession session) {
        UUID uid = (UUID) session.getAttribute("uid");
        if (uid == null) {
            uid = UUID.randomUUID();
        }
        session.setAttribute("uid", uid);
        return session.getId();
    }
登录redis 输入 keys '*sessions*'

t<spring:session:sessions:db031986-8ecc-48d6-b471-b137a3ed6bc4
t(spring:session:expirations:1472976480000
其中 1472976480000为失效时间，意思是这个时间后session失效，db031986-8ecc-48d6-b471-b137a3ed6bc4 为sessionId,登录http://localhost:8080/uid 发现会一致，就说明session 已经在redis里面进行有效的管理了。

如何在两台或者多台中共享session
其实就是按照上面的步骤在另一个项目中再次配置一次，启动后自动就进行了session共享。 
  
  springboot spring data jpa使用枚举

使用枚举的时候，我们希望数据库中存储的是枚举对应的String类型，而不是枚举的索引值，
需要在属性上面添加 @Enumerated(EnumType.STRING) 注解
  
basePath:http://localhost:8080/test/

getContextPath:/test 
getServletPath:/test.jsp 
getRequestURI:/test/test.jsp 
getRequestURL:http://localhost:8080/test/test.jsp 
getRealPath:D:\Tomcat 6.0\webapps\test\ 
getServletContext().getRealPath:D:\Tomcat 6.0\webapps\test\ 
getQueryString:p=fuck  
  
 在Hibernate Validator 4.1+中，@NotNull, @NotEmpty和@NotBlank之间的区别 
 
  首先是简要描述：

@NotNull://CharSequence, Collection, Map 和 Array 对象不能是 null, 但可以是空集（size = 0）。
@NotEmpty://CharSequence, Collection, Map 和 Array 对象不能是 null 并且相关对象的 size 大于 0。
@NotBlank://String 不是 null 且去除两端空白字符后的长度（trimmed length）大于 0。
为了大家更好地理解，下面让我们看下这些注解都是怎么定义的（在version 4.1中）：

1、@NotNull：

定义如下：

@Constraint(validatedBy = {NotNullValidator.class})

这个类中有一个isValid方法是这么定义的：
public boolean isValid(Object object, ConstraintValidatorContext constraintValidatorContext) {
 return object != null;  
}
对象不是null就行，其他的不保证。



2、@NotEmpty：

定义如下：

@NotNull  
@Size(min = 1)
也就是说，@NotEmpty除了@NotNull之外还需要保证@Size(min=1)，这也是一个注解，这里规定最小长度等于1，也就是类似于集合非空。



3、@NotBlank：

@NotNull  
@Constraint(validatedBy = {NotBlankValidator.class})
类似地，除了@NotNull之外，还有一个类的限定，这个类也有isValid方法：

if ( charSequence == null ) {  //curious 
  return true;   
}   
return charSequence.toString().trim().length() > 0;  
有意思的是，当一个string对象是null时方法返回true，但是当且仅当它的trimmed length等于零时返回false。即使当string是null时该方法返回true，但是由于@NotBlank还包含了@NotNull，所以@NotBlank要求string不为null。


给大家一些栗子帮助理解记忆：

String name = null;
@NotNull: false
@NotEmpty: false
@NotBlank: false

String name = "";
@NotNull: true
@NotEmpty: false
@NotBlank: false

String name = " ";
@NotNull: true
@NotEmpty: true
@NotBlank: false

String name = "Great answer!";
@NotNull: true
@NotEmpty: true
@NotBlank: true

mybatis plus
是@tableName("user"),它是指定与数据库表的关联,
这里的注解意味着你的数据库里应该有一个名为user的表与之对应,
并且数据表的列名应该就是User类的属性,
对于User类中有而user表中没有的属性
需要加第二个注解@TableField(exist = false),表示排除User类中的属性.

UUID含义是通用唯一识别码 (Universally Unique Identifier)，
这 是一个软件建构的标准，也是被开源软件基金会 (Open Software Foundation, OSF) 的组织
在分布式计算环境 (Distributed Computing Environment, DCE) 领域的一部份。
UUID 的目的，是让分布式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指定。
如此一来，每个人都可以建立不与其它人冲突的 UUID。在这样的情况下，就不需考虑数据库建立时的名称重复问题。
目前最广泛应用的 UUID，即是微软的 Microsoft's Globally Unique Identifiers (GUIDs)，
而其他重要的应用，则有 Linux ext2/ext3 档案系统、LUKS 加密分割区、GNOME、KDE、Mac OS X 等等。

UUID.randomUUID().toString()是javaJDK提供的一个自动生成主键的方法。
UUID(Universally Unique Identifier)全局唯一标识符,是指在一台机器上生成的数字，
它保证对在同一时空中的所有机器都是唯一的，是由一个十六位的数字组成,表现出来的形式。
由以下几部分的组合：当前日期和时间(UUID的第一个部分与时间有关，如果你在生成一个UUID之后，
过几秒又生成一个UUID，则第一个部分不同，其余相同)，时钟序列，
全局唯一的IEEE机器识别号（如果有网卡，从网卡获得，没有网卡以其他方式获得），
UUID的唯一缺陷在于生成的结果串会比较长。

 Java已经实现了MD5、SHA1算法。利用java.security.MessageDigest类就可以获取字符串和文件的MD5以及SHA1结果。  
  
// 拿到一个MD5转换器（如果想要SHA1参数换成”SHA1”）
MessageDigest algorithm = MessageDigest.getInstance("MD5");  
  
  MD5是常用的加密算法，也经常用于校验信息完整，如文件的完整性。用术语讲，MD5是一种消息摘要算法(Message Digest Algorithm)。另外还有一种常用的消息摘要算法SHA1。如果想了解这些的话，可以去百度百科：MD5、SHA1、消息摘要算法。

 

         Java已经实现了MD5、SHA1算法。利用java.security.MessageDigest类就可以获取字符串和文件的MD5以及SHA1结果。

 

1.字符串的MD5（下面的代码有详细注释）

   public static String stringMD5(String input) {
 
      try {
 
         // 拿到一个MD5转换器（如果想要SHA1参数换成”SHA1”）
 
         MessageDigest messageDigest =MessageDigest.getInstance("MD5");
 
 
         // 输入的字符串转换成字节数组
 
         byte[] inputByteArray = input.getBytes();
 
 
 
         // inputByteArray是输入字符串转换得到的字节数组
 
         messageDigest.update(inputByteArray);
 
 
 
         // 转换并返回结果，也是字节数组，包含16个元素
 
         byte[] resultByteArray = messageDigest.digest();
 
 
 
         // 字符数组转换成字符串返回
 
         return byteArrayToHex(resultByteArray);
 
        
 
      } catch (NoSuchAlgorithmException e) {
 
         return null;
 
      }
 
   }


  

   //下面这个函数用于将字节数组换成成16进制的字符串

   public static String byteArrayToHex(byte[] byteArray) {
 
      // 首先初始化一个字符数组，用来存放每个16进制字符
 
      char[] hexDigits = {'0','1','2','3','4','5','6','7','8','9', 'A','B','C','D','E','F' };
 
 
 
      // new一个字符数组，这个就是用来组成结果字符串的（解释一下：一个byte是八位二进制，也就是2位十六进制字符（2的8次方等于16的2次方））
 
      char[] resultCharArray =new char[byteArray.length * 2];
 
 
 
      // 遍历字节数组，通过位运算（位运算效率高），转换成字符放到字符数组中去
 
      int index = 0;
 
      for (byte b : byteArray) {
 
         resultCharArray[index++] = hexDigits[b>>> 4 & 0xf];
 
         resultCharArray[index++] = hexDigits[b& 0xf];
 
      }
 
 
 
      // 字符数组组合成字符串返回
 
      return new String(resultCharArray);
 
}


 

 

从上面代码可以看出，使用MessageDigest对字符串进行MD5算法的步骤是，先将字符串转换成字节数组，在进行MD5算法，最后返回的也是一个字节数组，要我们自己转成32位的字符串。

 

2.文件MD5

 

对文件进行MD5也可以像字符串MD5一样的，首先要把文件转成字节数组，后面和字符串MD5完全一样。

但是如果是一个特别大的文件，一下子把一个文件的数组全部读到内存中，那么估计内存也吃不消。

对于大文件，可以使用DigestInputStream。

 

public static String fileMD5(String inputFile) throws IOException {
 
 
 
      // 缓冲区大小（这个可以抽出一个参数）
 
      int bufferSize = 256 * 1024;
 
      FileInputStream fileInputStream = null;
 
      DigestInputStream digestInputStream = null;
 
 
 
      try {
 
         // 拿到一个MD5转换器（同样，这里可以换成SHA1）
 
         MessageDigest messageDigest =MessageDigest.getInstance("MD5");
 
 
 
         // 使用DigestInputStream
 
         fileInputStream = new FileInputStream(inputFile);
 
         digestInputStream = new DigestInputStream(fileInputStream,messageDigest);
 
 
 
         // read的过程中进行MD5处理，直到读完文件
 
         byte[] buffer =new byte[bufferSize];
 
         while (digestInputStream.read(buffer) > 0);
 
 
 
         // 获取最终的MessageDigest
 
         messageDigest= digestInputStream.getMessageDigest();
 
 
 
         // 拿到结果，也是字节数组，包含16个元素
 
         byte[] resultByteArray = messageDigest.digest();
 
 
 
         // 同样，把字节数组转换成字符串
 
         return byteArrayToHex(resultByteArray);
 
 
 
      } catch (NoSuchAlgorithmException e) {
 
         return null;
 
      } finally {
 
         try {
 
            digestInputStream.close();
 
         } catch (Exception e) {
 
         }
 
         try {
 
            fileInputStream.close();
 
         } catch (Exception e) {
 
         }
 
      }
 
   }


 

   上面的方法本人亲测过大小约4G的文件，得出的MD5值和网上下载的一个MD5小工具得到的MD5值一样，说明上面的方式没有什么问题。不过取大文件的MD5很慢，4G的文件跑一下要一分钟（I5处理器 6G内存 64位XP系统 本本）。

 

附1：我在网上还看到一种给文件MD5的方式

public static String getFileMD5String(File file) throws IOException{
 FileInputStream in = new FileInputStream(file);
 FileChannel ch =in.getChannel();
 MappedByteBuffer byteBuffer =ch.map(FileChannel.MapMode.READ_ONLY, 0,file.length());
 messagedigest.update(byteBuffer);
 return byteArrayToHex (messagedigest.digest());
}
我也尝试过这样的方式，但是如果文件大于2G，那么这种方式会出现异常。所以不推荐。



附2：测试文件MD5的main方法


public static void main(String[] args) {
 
  long startTime = System.currentTimeMillis();
 
  try {
    System.out.println(fileMD5("E:/软件/VS2008ProEdition90DayTrialCHSX1435983.iso"));
  } catch (IOException e) {
    e.printStackTrace();
  }
 
  long endTime = System.currentTimeMillis();
 
  System.out.println((endTime - startTime)/1000);
}

toCharArray()将字符串对象中的字符转换为一个字符数组  
  
  
<!-- 当proxy-target-class为false时使用JDK动态代理 -->
<!-- 为true时使用cglib -->
<!-- cglib无法拦截接口方法 -->
<aop:aspectj-autoproxy proxy-target-class="false" /> 
  
MD5实现的算法的时候有一段

public static String md5Encode(String inputStr) {
		MessageDigest md5 = null;
		try {
			md5 = MessageDigest.getInstance("MD5");
			byte[] bytes = inputStr.getBytes("UTF-8");
			byte[] md5Bytes = md5.digest(bytes);
			StringBuffer hexValue = new StringBuffer();
			for (int i = 0; i < md5Bytes.length; i++) {
				
				int value = ((int) md5Bytes[i]) & 0xff;
				
				if (value < 16) {
					hexValue.append("0");
				}
				hexValue.append(Integer.toHexString(value));
				
			}
			return hexValue.toString();
			
		} catch (Exception e) {
			return "";
		}
		
	}  
  
跨站请求伪造CSRF攻击原理
1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A;

2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A;

3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B;

4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A;

5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。
网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。  
  
 二、CSRF漏洞防御

CSRF漏洞防御主要可以从三个层面进行，即服务端的防御、用户端的防御和安全设备的防御。

1、 服务端的防御

.1.1 验证HTTP Referer字段

根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。
在通常情况下，访问一个安全受限页面的请求必须来自于同一个网站。
比如某银行的转账是通过用户访问
http://bank.test/test?page=10&userID=101&money=10000
页面完成，用户必须先登录bank.test，然后通过点击页面上的按钮来触发转账事件。
当用户提交请求时，该转账请求的Referer值就会是转账按钮所在页面的URL(本例中，通常是以bank. test域名开头的地址)。
而如果攻击者要对银行网站实施CSRF攻击，他只能在自己的网站构造请求，当用户通过攻击者的网站发送请求到银行时，
该请求的Referer是指向攻击者的网站。因此，要防御CSRF攻击，银行网站只需要对于每一个转账请求验证其Referer值，
如果是以bank. test开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果Referer是其他网站的话，
就有可能是CSRF攻击，则拒绝该请求。

1.2 在请求地址中添加token并验证

CSRF攻击之所以能够成功，是因为攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于Cookie中，
因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的Cookie来通过安全验证。
由此可知，抵御CSRF攻击的关键在于：在请求中放入攻击者所不能伪造的信息，并且该信息不存在于Cookie之中。
鉴于此，系统开发者可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器来验证这个token，
如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求。

1.3 在HTTP头中自定义属性并验证

自定义属性的方法也是使用token并进行验证，和前一种方法不同的是，这里并不是把token以参数的形式置于HTTP请求之中，
而是把它放到HTTP头中自定义的属性里。通过XMLHttpRequest这个类，可以一次性给所有该类请求加上csrftoken这个HTTP头属性，
并把token值放入其中。这样解决了前一种方法在请求中加入token的不便，同时，通过这个类请求的地址不会被记录到浏览器的地址栏，
也不用担心token会通过Referer泄露到其他网站。

2、 其他防御方法

1. CSRF攻击是有条件的，当用户访问恶意链接时，认证的cookie仍然有效，所以当用户关闭页面时要及时清除认证cookie，对支持TAB模式(新标签打开网页)的浏览器尤为重要。

2. 尽量少用或不要用request()类变量，获取参数指定request.form()还是request. querystring ()，这样有利于阻止CSRF漏洞攻击，此方法只不能完全防御CSRF攻击，只是一定程度上增加了攻击的难度。

代码示例：

Java 代码示例

下文将以 Java 为例，对上述三种方法分别用代码进行示例。无论使用何种方法，在服务器端的拦截器必不可少，它将负责检查到来的请求是否符合要求，然后视结果而决定是否继续请求或者丢弃。在 Java 中，拦截器是由 Filter 来实现的。我们可以编写一个 Filter，并在 web.xml 中对其进行配置，使其对于访问所有需要 CSRF 保护的资源的请求进行拦截。

在 filter 中对请求的 Referer 验证代码如下

清单 1. 在 Filter 中验证 Referer

 // 从 HTTP 头中取得 Referer 值
 String referer=request.getHeader("Referer");
 // 判断 Referer 是否以 bank.example 开头
 if((referer!=null) &&(referer.trim().startsWith(“bank.example”))){
    chain.doFilter(request, response);
 }else{
request.getRequestDispatcher(“error.jsp”).forward(request,response);
 } 
以上代码先取得 Referer 值，然后进行判断，当其非空并以 bank.example 开头时，则继续请求，否则的话可能是 CSRF 攻击，转到 error.jsp 页面。

如果要进一步验证请求中的 token 值，代码如下

清单 2. 在 filter 中验证请求中的 token

HttpServletRequest req = (HttpServletRequest)request;
 HttpSession s = req.getSession();
 // 从 session 中得到 csrftoken 属性
 String sToken = (String)s.getAttribute(“csrftoken”);
 if(sToken == null){
    // 产生新的 token 放入 session 中
    sToken = generateToken();
    s.setAttribute(“csrftoken”,sToken);
    chain.doFilter(request, response);
 } else{
    // 从 HTTP 头中取得 csrftoken
    String xhrToken = req.getHeader(“csrftoken”);
    // 从请求参数中取得 csrftoken
    String pToken = req.getParameter(“csrftoken”);
    if(sToken != null && xhrToken != null && sToken.equals(xhrToken)){
        chain.doFilter(request, response);
    }else if(sToken != null && pToken != null && sToken.equals(pToken)){
        chain.doFilter(request, response);
    }else{
request.getRequestDispatcher(“error.jsp”).forward(request,response);
    }
 } 
首先判断 session 中有没有 csrftoken，如果没有，则认为是第一次访问，session 是新建立的，这时生成一个新的 token，放于 session 之中，并继续执行请求。如果 session 中已经有 csrftoken，则说明用户已经与服务器之间建立了一个活跃的 session，这时要看这个请求中有没有同时附带这个 token，由于请求可能来自于常规的访问或是 XMLHttpRequest 异步访问，我们分别尝试从请求中获取 csrftoken 参数以及从 HTTP 头中获取 csrftoken 自定义属性并与 session 中的值进行比较，只要有一个地方带有有效 token，就判定请求合法，可以继续执行，否则就转到错误页面。生成 token 有很多种方法，任何的随机算法都可以使用，Java 的 UUID 类也是一个不错的选择。

除了在服务器端利用 filter 来验证 token 的值以外，我们还需要在客户端给每个请求附加上这个 token，这是利用 js 来给 html 中的链接和表单请求地址附加 csrftoken 代码，其中已定义 token 为全局变量，其值可以从 session 中得到。

清单 3. 在客户端对于请求附加 token

function appendToken(){
    updateForms();
    updateTags();
 }

 function updateForms() {
    // 得到页面中所有的 form 元素
    var forms = document.getElementsByTagName('form');
    for(i=0; i<forms.length; i++) {
        var url = forms[i].action;
        // 如果这个 form 的 action 值为空，则不附加 csrftoken
        if(url == null || url == "" ) continue;
        // 动态生成 input 元素，加入到 form 之后
        var e = document.createElement("input");
        e.name = "csrftoken";
        e.value = token;
        e.type="hidden";
        forms[i].appendChild(e);
    }
 }
 function updateTags() {
    var all = document.getElementsByTagName('a');
    var len = all.length;
    // 遍历所有 a 元素
    for(var i=0; i<len; i++) {
        var e = all[i];
        updateTag(e, 'href', token);
    }
 }
 function updateTag(element, attr, token) {
    var location = element.getAttribute(attr);
    if(location != null && location != '' '' ) {
        var fragmentIndex = location.indexOf('#');
        var fragment = null;
        if(fragmentIndex != -1){
            //url 中含有只相当页的锚标记
            fragment = location.substring(fragmentIndex);
            location = location.substring(0,fragmentIndex);
        }               

        var index = location.indexOf('?');
        if(index != -1) {
            //url 中已含有其他参数
            location = location + '&csrftoken=' + token;
        } else {
            //url 中没有其他参数
            location = location + '?csrftoken=' + token;
        }
        if(fragment != null){
            location += fragment;
        }
element.setAttribute(attr, location);
    }
 } 
在客户端 html 中，主要是有两个地方需要加上 token，一个是表单 form，另一个就是链接 a。这段代码首先遍历所有的 form，在 form 最后添加一隐藏字段，把 csrftoken 放入其中。然后，代码遍历所有的链接标记 a，在其 href 属性中加入 csrftoken 参数。注意对于 a.href 来说，可能该属性已经有参数，或者有锚标记。因此需要分情况讨论，以不同的格式把 csrftoken 加入其中。

如果你的网站使用 XMLHttpRequest，那么还需要在 HTTP 头中自定义 csrftoken 属性，利用 dojo.xhr 给 XMLHttpRequest 加上自定义属性代码如下：

清单 4. 在 HTTP 头中自定义属性

var plainXhr = dojo.xhr;// 重写 dojo.xhr 方法
 dojo.xhr = function(method,args,hasBody) {
    // 确保 header 对象存在
    args.headers = args.header || {};
    tokenValue = '<%=request.getSession(false).getAttribute("csrftoken")%>';
    var token = dojo.getObject("tokenValue");
    // 把 csrftoken 属性放到头中
    args.headers["csrftoken"] = (token) ? token : "  ";
    return plainXhr(method,args,hasBody);
 }; 
这里改写了 dojo.xhr 的方法，首先确保 dojo.xhr 中存在 HTTP 头，然后在 args.headers 中添加 csrftoken 字段，并把 token 值从 session 里拿出放入字段中。

PHP代码示例：

请看下面一个简单的应用，它允许用户购买钢笔或铅笔。界面上包含下面的表单：

<form action="buy.php" method="POST">
  <p>
  Item:
  <select name="item">
    <option name="pen">pen</option>
    <option name="pencil">pencil</option>
  </select><br />
  Quantity: <input type="text" name="quantity" /><br />
  <input type="submit" value="Buy" />
  </p></form> 
下面的buy.php程序处理表单的提交信息：

<?php
  session_start();
  $clean = array();
  if (isset($_REQUEST['item'] && isset($_REQUEST['quantity']))
  {
    /* Filter Input ($_REQUEST['item'], $_REQUEST['quantity']) */
    if (buy_item($clean['item'], $clean['quantity']))
    {
      echo '<p>Thanks for your purchase.</p>';
    }
    else
    {
      echo '<p>There was a problem with your order.</p>';
    }
  }?> 
攻击者会首先使用这个表单来观察它的动作。例如，在购买了一支铅笔后，攻击者知道了在购买成功后会出现感谢信息。注意到这一点后，攻击者会尝试通过访问下面的URL以用GET方式提交数据是否能达到同样的目的：

http://store.example.org/buy.php?item=pen&quantity=1

如果能成功的话，攻击者现在就取得了当合法用户访问时，可以引发购买的URL格式。在这种情况下，进行跨站请求伪造攻击非常容易，因为攻击者只要引发受害者访问该URL即可。

请看下面对前例应用更改后的代码：

php
  session_start();
  $token = md5(uniqid(rand(), TRUE));
  $_SESSION['token'] = $token;
  $_SESSION['token_time'] = time();?> 
表单：

<form action="buy.php" method="POST">
  <input type="hidden" name="token" value="<?php echo $token; ?>" />
  <p>
  Item:
  <select name="item">
    <option name="pen">pen</option>
    <option name="pencil">pencil</option>
  </select><br />
  Quantity: <input type="text" name="quantity" /><br />
  <input type="submit" value="Buy" />
  </p></form> 
通过这些简单的修改，一个跨站请求伪造攻击就必须包括一个合法的验证码以完全模仿表单提交。由于验证码的保存在用户的session中的，攻击者必须对每个受害者使用不同的验证码。这样就有效的限制了对一个用户的任何攻击，它要求攻击者获取另外一个用户的合法验证码。使用你自己的验证码来伪造另外一个用户的请求是无效的。

该验证码可以简单地通过一个条件表达式来进行检查：

<?php
  if (isset($_SESSION['token']) && $_POST['token'] == $_SESSION['token'])
  {
    /* Valid Token */
  }?> 
你还能对验证码加上一个有效时间限制，如5分钟：

<?php
  $token_age = time() - $_SESSION['token_time'];
  if ($token_age <= 300)
  {
    /* Less than five minutes has passed. */
  }?> 
通过在你的表单中包括验证码，你事实上已经消除了跨站请求伪造攻击的风险。可以在任何需要执行操作的任何表单中使用这个流程。 

iframe 用于在网页内显示网页。 
  iframe常用属性:
1.frameborder:是否显示边框，1(yes),0(no)
2.height:框架作为一个普通元素的高度，建议在使用css设置。
3.width:框架作为一个普通元素的宽度，建议使用css设置。
4.name:框架的名称，window.frames[name]时专用的属性。
5.scrolling:框架的是否滚动。yes,no,auto。
6.src：内框架的地址，可以使页面地址，也可以是图片的地址。
7.srcdoc , 用来替代原来HTML body里面的内容。但是IE不支持, 不过也没什么卵用
8.sandbox: 对iframe进行一些列限制，IE10+支持
  
 开始使用DataTables很简单，只需要引入两个文件， 一个css样式文件和DataTables本身的脚本文件。
 在DataTables CDN上，可以使用下面这两个文件： 

css  http://cdn.datatables.net/1.10.15/css/jquery.dataTables.min.css
js   http://cdn.datatables.net/1.10.15/js/jquery.dataTables.min.js
2、然后在初始化

$(document).ready(function(){
     $('#myTable').DataTable();
});
//这样就可以成功的创建了一个表格了
3、运用datatable是看中它的方便和它的功能　
主要功能有【搜索、排序、显示条数、分页、固定头部、固定几列、打印、导出excel、导出pdf、导出图片、等】 
  
classes目录用于存放编译后的class文件,
lib用于存放依赖的jar包  
  
controller转发jsp传递数据使用
org.springframework.ui.ModelMap;
或者
java.util.Map;
都是可以的
通过debug可以看出使用Map时会被程序转换为map	BindingAwareModelMap

request.getParameterNames()方法是将发送请求页面中form表单里所有具有name属性的表单对象获取(包括button).
		    * 返回一个Enumeration类型的枚举.通过Enumeration的hasMoreElements()方法遍历.
		    * 再由nextElement()方法获得枚举的值.此时的值是form表单中所有控件的name属性的值.
		    * 最后通过request.getParameter()方法获取表单控件的value值.

打印request中所有参数
		//request.getParameterNames()方法是将发送请求页面中form表单里所有具有name属性的表单对象获取(包括button).返回一个Enumeration类型的枚举.
		Enumeration pNames=request.getParameterNames();
		System.out.println("controller.equipment.EquipmentController.queryEquipment() : ");
		while(pNames.hasMoreElements()){
		    String name=(String)pNames.nextElement();
		    String value=request.getParameter(name);
		   System.out.print(name + "=" + value);
		}
		System.out.println("中断");  
  
@PathVariable 映射 URL 绑定的占位符
带占位符的 URL 是 Spring3.0 新增的功能，该功能在SpringMVC 向 REST 目标挺进发展过程中具有里程碑的意义
通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过@PathVariable(“xxx“) 绑定到操作方法的入参中。
实例： 
SpringMVCTest.java

//@PathVariable可以用来映射URL中的占位符到目标方法的参数中
//把路径的一部分当作参数使用
@RequestMapping("/testPathVariable/{id}")
    public String testPathVariable(@PathVariable("id") Integer id)
    {
        System.out.println("testPathVariable:"+id);
        return SUCCESS;
    }

	index.jsp

<a href="springmvc/testPathVariable/1">testPathVariable</a>  
  
  
  如果jsp通过el表达式需要访问一个对象不存在的属性时(user中不存在hasPrev这个属性)
  <c:if test="${requestScope.user.hasPrev }">
			&nbsp;&nbsp;<a href="${ctx}/equipment/1">首页</a>&nbsp;&nbsp;
		</c:if>
  那么相应该对象需要拥有一个该(虚拟)属性的is方法
  // ${requestScope.page.hasPrev}
	public boolean isHasPrev() {
		return id.equals("1");
	}
	该方法可能需要满足以下特征:
	1.返回值为boolean
	2.无参
	3.方法名为:is+属性名
  
 Java的serialization提供了一种持久化对象实例的机制。
 当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。
 为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。
 当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然而非transient型的变量是被包括进去的。 
 
如果DispacherServlet的url不限制为*.do改为/ 
那么静态资源请求也会被一并接收导致无法获取静态资源,
需要在spring-mvc.xml中添加: 

	<mvc:resources location="/js/" mapping="/js/**"/>  
  
  手机号正则表达式
  phone.replaceAll("(\\d{3})\\d{4}(\\d{4})", "$1****$2");
  
 在Java中，一个变量重新new，重新分配空间进行复用，和重新定义一个变量使用哪个好？
例如：


// 方式一
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
sdf.parse(time);
sdf = new SimpleDateFormat("yyyy-MM-dd");
sdf.parse(time2);
// 方式二
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
sdf.parse(time);
SimpleDateFormat sdf2 = new SimpleDateFormat("yyyy-MM-dd");
sdf2.parse(time2); 
  看上去两者并没有什么区别，其实有一个内存分配的问题，
  方式1，对于SimpleDateFormat的分配空间只分配了一个，
  方式二，分配了两个SimpleDateFormat，方式一节省个内存


 System.out.println(HttpServletRequest.class.toString());
System.out.println(request.getClass().toString());
 interface javax.servlet.http.HttpServletRequest
class org.apache.catalina.connector.RequestFacade 
  
spring.resources.chain.strategy.content.enabled
是否开启内容版本策略，默认为false
spring.resources.chain.strategy.content.paths
指定要应用的版本的路径，多个以逗号分隔，默认为:[/**]

 <html xmlns:th="http://www.thymeleaf.org"> 
  
Java使用mysql-jdbc连接MySQL出现如下警告：
　　Establishing SSL connection without server's identity verification is not recommended. 
According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection 
must be established by default if explicit option isn't set. 
For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. 
You need either to explicitly disable SSL by setting useSSL=false, 
or set useSSL=true and provide truststore for server certificate verification.
　　在mysql连接字符串url中加入ssl=true或者false即可，如下所示。
　　url=jdbc:mysql://127.0.0.1:3306/framework?characterEncoding=utf8&useSSL=true  
  
1，Spring事务回滚机制是这样的：当所拦截的方法有指定异常抛出，事务才会自动进行回滚！

      我们需要注意的地方有四点： 如果你在开发当中引入Spring进行事务管理，但是事务没能正常的自动回滚，可以对照下面四点，缺一不可！

                    ①被拦截方法-—— 注解式：方法或者方法所在类被@Transactional注解；

                                                   拦截配置式：<tx:method />应该包含对该方法，名称格式的定义；

                                                                       且方法需要在expression定义的范围内；

                    ②异常—— 该方法的执行过程必须出现异常，这样事务管理器才能被触发，并对此做出处理；

                    ③指定异常——  默认配置下，事务只会对Error与RuntimeException及其子类这些UNChecked异常，做出回滚。

                                              一般的Exception这些Checked异常不会发生回滚（如果一般Exception想回滚要做出配置）；  
  
一，为什么框架中根本没有对Exception的一般子类进行回滚配置，异常发生时，事务都进行了回滚 ，说好的只会对RuntimeException（Unchecked 非受检异常）回滚呢？ 

    此时，我们就有必要了解一下，RuntimeException所包含的子类具体有哪些：

             

   这时，或许你就明白了 ： 平常代码运行阶段经常遇到的那些异常，其实都是RuntimeException的子类。

            受检异常（Checked）一般在编译期就被检出，这就给你造成了一个Spring对于所有异常都会发生回滚的误解。

             下面给出一些受检CHECKED异常：
              

二，为什么我在执行方法的时候出现了SQL执行的Exception，默认配置的情况下，事务还是发生了回滚 ？                                       

              下结论之前，我们应该仔细查看异常信息：      
              下面我会给出 一个例子：类似于直播软件中，“礼物的购买事务”，其中有三个动作：
              ①Mygift数量的增加            ②Customer余额的减少         ③consumption消费明细的增加

    int a=consumpDao.insert(s);//插入消费明细  
    int b=customerDao.insert(customer);//此处实际应该update(customer),不然会出现重复主键的异常  
    int d=0;  
    if(mygift==null){//判断礼物类型是否存在，第一次插入，而后更新  
        m.setMySum(s.getGiftSum());  
        d=mygiftDao.insert(m);  
    }else{  
        mygift.setMySum(mygift.getMySum()+s.getGiftSum());  
        d=mygiftDao.update(mygift);  
    }  
    if(a*b*d==1){  
        json.put("result",0);  
        json.put("msg", "购买成功");  
        json.put("data", "");  
    }else{  
        json.put("result",-1);  
        json.put("msg", "购买失败");  
        json.put("data", "");  
        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();  
    }  
}  
                 在程序28行，明确指出：
[java] view plain copy
int a=consumpDao.insert(s);//插入消费明细  
int b=customerDao.insert(customer);//此处实际应该update(customer),不然会出现重复主键的异常  
                 程序运行之前，Consumption消费记录中只有一条数据。
                           
                 程序运行，出现异常，具体如下：
[html] view plain copy
[Request processing failed; nested exception is org.springframework.dao.DuplicateKeyException:   
### Error updating database.  Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrityConstraintViolationException: Duplicate entry '1' for key 1  
                对应事务中的三个动作，理论发生：      

                   ①Consumption消费明细的增加 执行成功，②Customer余额的减少SQL语句在执行的时候发生异常，③Mygift数量增加 执行成功

                程序运行后，Consumption消费记录并没有出现第二条：

                  所以此时，该事务发生了回滚。org.springframework.dao.DuplicateKeyException 应该是RuntimeException的子类

三，作出结论，是SQL异常属于RuntimeException的子类？还是默认配置一般异常也会回滚呢？                            
                   ① 查看接口文档java.lang.SqlException, 
                        java.lang.Object
                             |____java.lang.Throwable
                                  |____ java.lang.Exception
                                       |____ java.lang.SQLException
                        可以看出java.lang.SqlException,确实是Exception的直接子类，属于CHECKED受检异常，事务是不会因为它发生回滚的！

                   ② 实际上，当我们在项目开发中加入了Spring框架以后，SQL异常都被org.springframework重写，正如上面的重复主键的SQL异                                      常。
                       产生原因：很显然该异常原因属于一般异常，而被Spring捕捉后抛出其他自定义的RuntimeException
[html] view plain copy
### Error updating database.  Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrityConstraintViolationException: Duplicate entry '1' for key 1  
                      抛出的异常：
[html] view plain copy
[Request processing failed; nested exception is org.springframework.dao.DuplicateKeyException:   
                      我们知道 org.springframework.dao.DuplicateKeyException来自spring-tx-4.0.0.RELEASE.jar
                      反编译可见：
                      java.lang.Object
                               |____java.lang.Throwable
                                    |____ java.lang.Exception
                                         |____ java.lang.RuntimeException
                                              |____ org.springframework.core.NestedRuntimeException
                                                  |____org.springframework.dao.DataAccessException
                                                       |____  org.springframework.dao.NonTransientDataAccessException
                                                           |____org.springframework.dao.DataIntegrityViolationException
                                                               |____org.springframework.dao.DuplicateKeyException
                     同样方法可以查得：org.springframework.dao中的异常都是RuntimeException的子类
                     得出结论：Spring框架下，所有SQL异常都被org.springframework重写为RuntimeException，事务因此也会发生回滚！  
  
  
 它们之间的执行顺序为：静态代码块—>非静态代码块—>构造方法。

静态代码块只在第一次加载类的时候执行一次，之后不再执行；而非静态代码块和构造函数都是在每new一次就执行一次，只不过非静态代码块在构造函数之前执行而已。

如果存在子类，则加载顺序为先父类后子类。

看如下的代码：

package com.ykp.test;

class ClassA {
    public ClassA() {
        System.out.println("父类构造函数");
    }

    {
        System.out.println("父类非静态代码块1");
    }
    {
        System.out.println("父类非静态代码块2");
    }
    static {
        System.out.println("父类静态代码块 1");
    }
    static {
        System.out.println("父类静态代码块 2");
    }
}

public class ClassB extends ClassA {
    public ClassB() {
        System.out.println("子类构造函数");
    }

    {
        System.out.println("子类非静态代码块2");
    }
    {
        System.out.println("子类非静态代码块1");
    }
    static {
        System.out.println("子类静态代码块 2");
    }
    static {
        System.out.println("子类静态代码块 1");
    }

    public static void main(String[] args) {
        System.out.println("....主方法开始....");
        new ClassB();
        System.out.println("************");
        new ClassB();
        System.out.println("....主方法结束....");
    }
}
执行结果：

父类静态代码块 1
父类静态代码块 2
子类静态代码块 2
子类静态代码块 1
....主方法开始....
父类非静态代码块1
父类非静态代码块2
父类构造函数
子类非静态代码块2
子类非静态代码块1
子类构造函数
************
父类非静态代码块1
父类非静态代码块2
父类构造函数
子类非静态代码块2
子类非静态代码块1
子类构造函数
....主方法结束....
从结果可以看出，首先加载类，加载的时候先加载父类，然后子类，类加载的时候就执行静态代码快，也就是说静态代码块是在类加载的时候就加载的，而且只加载一次。如果存在多个执行顺序按照代码的先后来。

对于非静态代码块，是在new的时候加载的，只是在构造函数之前加载而已。如果存在多个执行顺序按照代码的先后来。 
  
  
 PreparedStatement 的 execute方法和executeUpdate方法区别 
 用于执行 INSERT、UPDATE 或 DELETE 语句以及 SQL DDL（数据定义语言）语句，例如 CREATE TABLE 和 DROP TABLE。INSERT、UPDATE 或 DELETE 语句的效果是修改表中零行或多行中的一列或多列。executeUpdate 的返回值是一个整数（int），指示受影响的行数（即更新计数）。对于 CREATE TABLE 或 DROP TABLE 等不操作行的语句，executeUpdate 的返回值总为零。 


方法execute 
可用于执行任何SQL语句，返回一个boolean值，表明执行该SQL语句是否返回了ResultSet。如果执行后第一个结果是ResultSet，则返回true，否则返回false。但它执行SQL语句时比较麻烦，通常我们没有必要使用execute方法来执行SQL语句，而是使用executeQuery或executeUpdate更适合，但如果在不清楚SQL语句的类型时则只能使用execute方法来执行该SQL语句了 
显然方法execute多了判断是否有结果集返回 
  
  
HTTP1.1中启用Cache-Control 来控制页面的缓存与否，这里介绍几个常用的参数：

no-cache，浏览器和缓存服务器都不应该缓存页面信息；
public，浏览器和缓存服务器都可以缓存页面信息；
no-store，请求和响应的信息都不应该被存储在对方的磁盘系统中；
must-revalidate，对于客户机的每次请求，代理服务器必须想服务器验证缓存是否过时  
  
如果父类方法为static那么子类继承重写当他向上造型时调用的仍然是父类的,他已经失去了多态性  
class StaticSuper {
    public static String staticGet() {
        return "Base staticGet()";
    }

    public String dynamicGet() {
        return "Base dynamicGet()";
    }
}

class StaticSub extends StaticSuper {
    public static String staticGet() {
        return "Derived staticGet()";
    }

    public String dynamicGet() {
        return "Derived dynamicGet()";
    }
}

public class StaticPolymorphism {

    public static void main(String[] args) {
        StaticSuper sup = new StaticSub();
        System.out.println(sup.staticGet());
        System.out.println(sup.dynamicGet());
    }

}

输出：
Base staticGet()
Derived dynamicGet()  
  
 在父类构造函数内部调用具有多态行为的函数将导致无法预测的结果，因为此时子类对象还没初始化，此时调用子类方法不会得到我们想要的结果。

class Glyph {
    void draw() {
        System.out.println("Glyph.draw()");
    }
    Glyph() {
        System.out.println("Glyph() before draw()");
        draw();
        System.out.println("Glyph() after draw()");
    }
}

class RoundGlyph extends Glyph {
    private int radius = 1;

    RoundGlyph(int r) {
        radius = r;
        System.out.println("RoundGlyph.RoundGlyph(). radius = " + radius);
    }

    void draw() {
        System.out.println("RoundGlyph.draw(). radius = " + radius);
    }
}

public class PolyConstructors {

    public static void main(String[] args) {
        new RoundGlyph(5);

    }

}

输出：

Glyph() before draw()
RoundGlyph.draw(). radius = 0
Glyph() after draw()
RoundGlyph.RoundGlyph(). radius = 5 
  
（1）在其他任何事物发生之前，将分配给对象的存储空间初始化成二进制0；
（2）调用基类构造函数。从根开始递归下去，因为多态性此时调用子类覆盖后的draw()方法（要在调用RoundGlyph构造函数之前调用），由于步骤1的缘故，我们此时会发现radius的值为0；
（3）按声明顺序调用成员的初始化方法；
（4）最后调用子类的构造函数。  
  
where标记的作用类似于动态sql中的set标记，他的作用主要是用来简化sql语句中where条件判断的书写的，如下所示：

　　<select id="selectByParams" parameterType="map" resultType="user">

　　　　select * from user

　　　　<where>

　　　　　　<if test="id != null ">id=#{id}</if>

　　　　　　<if test="name != null and name.length()>0" >and name=#{name}</if>

　　　　　　<if test="gender != null and gender.length()>0">and gender = #{gender}</if>

　　　　</where>

　　</select>　　　　　

　　在上述SQL中加入ID的值为null的话，那么打印出来的SQL为：select * from user where name="xx" and gender="xx"

　　where 标记会自动将其后第一个条件的and或者是or给忽略掉  
  
在网站上生成springboot工程后需要在pom中自行导入web

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
  
@SpringBootApplication注释是相当于使用
	@EnableAutoConfiguration：启用Spring Boot的自动配置机制
	@ComponentScan：@Component在应用程序所在的程序包上启用扫描（请参阅最佳做法）
	@Configuration：允许在上下文中注册额外的bean或导入其他配置类  
与他们的默认属性  	  
	  
禁用特定的自动配置类(在类上添加下方注解,感觉应该使用全名称限定)	  
@EnableAutoConfiguration（exclude = {DataSourceAutoConfiguration.class}）  
如果类不在类路径上，则可以使用excludeName注释的属性并指定完全限定名称。
可以使用
	spring.autoconfigure.exclude
属性控制要排除的自动配置类列表 。  
  
控制banner(启动时控制台所打印的横幅)的显示设置  

.yml

	spring:
	  main:
		banner-mode: "off"

.properties

	spring.main.banner-mode: "off" 
	
也可以通过添加banner.jpg/banner.png/banner.txt文件来替换内容
  
yml默认utf8 如果使用gbk运行会报错  
  
springboot更改访问端口和访问前缀

.yml

	server:
	  servlet:
		context-path: /demo
	  port: 9090
  
.properties

	server.port:9090
	server.servlet.context-path: /demo 
	  
  
springboot中配置文件properties添加属性,在class中
在属性上方添加@Value("${user.name}")注解进行注入  
  
springboot如果properties中配置了很多属性则可以进行类型安全配置(用一个类去映射properties配置文件)  

如果是Application.properties  
只需要添加一个通用注解@Component
和映射注解(如果有相同前缀可以通过prefix属性进行配置)@ConfigurationProperties(prefix="前缀")  
  
如果不是Application.properties    
则需要额外添加一个@PropertySource("classpath:文件路径")
  
springboot 多环境配置
如果使用单独文件则文件名格式为:
	application-环境名.properties
在主配置文件application.properties中使用:
	spring.profiles.active= 环境名 (如果出现spring.profiles.active[]= ,则把[]删除即可)
  
SpringBoot
一、	Spring介绍
1.1、SpringBoot简介
在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！
Spring Boot让我们的Spring应用变的更轻量化。比如：你可以仅仅依靠一个Java类来运行一个Spring引用。你也可以打包你的应用为jar并通过使用java -jar来运行你的Spring Web应用。
Spring Boot的主要优点：
为所有Spring开发者更快的入门
开箱即用，提供各种默认配置来简化项目配置
内嵌式容器简化Web项目
没有冗余代码生成和XML配置的要求
本章主要目标完成Spring Boot基础项目的构建，并且实现一个简单的Http请求处理，通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。
1.2、系统要求：
Java1.8及以上
Spring Framework 4.1.5及以上
本文采用Java 1.8.0_73、Spring Boot 1.3.2调试通过。
二、快速入门

2.1、创建一个Maven工程
名为”springboot-helloworld” 类型为Jar工程项目
 
2.2、pom文件引入依赖
<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>1.3.3.RELEASE</version>
	</parent>
	<dependencies>
	  <!—SpringBoot web 组件 -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
	</dependencies>

spring-boot-starter-parent作用
在pom.xml中引入spring-boot-start-parent,spring官方的解释叫什么stater poms,它可以提供dependency management,也就是说依赖管理，引入以后在申明其它dependency的时候就不需要version了，后面可以看到。
spring-boot-starter-web作用
springweb 核心组件
spring-boot-maven-plugin作用
 如果我们要直接Main启动spring，那么以下plugin必须要添加，否则是无法启动的。如果使用maven 的spring-boot:run的话是不需要此配置的。（我在测试的时候，如果不配置下面的plugin也是直接在Main中运行的。）

2.3、编写HelloWorld服务
创建package命名为com.itmayiedu.controller（根据实际情况修改）
创建HelloController类，内容如下


@RestController
@EnableAutoConfiguration
public class HelloController {
	@RequestMapping("/hello")
	public String index() {
		return "Hello World";
	}	
public static void main(String[] args) {
		SpringApplication.run(HelloController.class, args);
	}
}
2.4、@RestController
在上加上RestController 表示修饰该Controller所有的方法返回JSON格式,直接可以编写
Restful接口
2.5、@EnableAutoConfiguration
注解:作用在于让 Spring Boot   根据应用所声明的依赖来对 Spring 框架进行自动配置
        这个注解告诉Spring Boot根据添加的jar依赖猜测你想如何配置Spring。由于spring-boot-starter-web添加了Tomcat和Spring MVC，所以auto-configuration将假定你正在开发一个web应用并相应地对Spring进行设置。
2.6 SpringApplication.run(HelloController.class, args);
   标识为启动类
2.7、SpringBoot启动方式1
Springboot默认端口号为8080

@RestController
@EnableAutoConfiguration
public class HelloController {
	@RequestMapping("/hello")
	public String index() {
		return "Hello World";
	}	
public static void main(String[] args) {
		SpringApplication.run(HelloController.class, args);
	}
}


启动主程序，打开浏览器访问http://localhost:8080/index，可以看到页面输出Hello World
2.8、SpringBoot启动方式2
@ComponentScan(basePackages = "com.itmayiedu.controller")---控制器扫包范围
@ComponentScan(basePackages = "com.itmayiedu.controller")
@EnableAutoConfiguration
public class App {
	public static void main(String[] args) {
		SpringApplication.run(App.class, args);
	}
}



三、	Web开发
3.1、静态资源访问
在我们开发Web应用的时候，需要引用大量的js、css、图片等静态资源。
默认配置
Spring Boot默认提供静态资源目录位置需置于classpath下，目录名需符合如下规则：
/static
/public
/resources	
/META-INF/resources
举例：我们可以在src/main/resources/目录下创建static，在该位置放置一个图片文件。启动程序后，尝试访问http://localhost:8080/D.jpg。如能显示图片，配置成功。
3.2、全局捕获异常
@ExceptionHandler 表示拦截异常
•	@ControllerAdvice 是 controller 的一个辅助类，最常用的就是作为全局异常处理的切面类
•	@ControllerAdvice 可以指定扫描范围
•	@ControllerAdvice 约定了几种可行的返回值，如果是直接返回 model 类的话，需要使用 @ResponseBody 进行 json 转换
o	返回 String，表示跳到某个 view
o	返回 modelAndView
o	返回 model + @ResponseBody

@ControllerAdvice
public class GlobalExceptionHandler {
	@ExceptionHandler(RuntimeException.class)
	@ResponseBody
	public Map<String, Object> exceptionHandler() {
		Map<String, Object> map = new HashMap<String, Object>();
		map.put("errorCode", "101");
		map.put("errorMsg", "系統错误!");
		return map;
	}
}

3.3、渲染Web页面

渲染Web页面
在之前的示例中，我们都是通过@RestController来处理请求，所以返回的内容为json对象。那么如果需要渲染html页面的时候，要如何实现呢？
模板引擎
在动态HTML实现上Spring Boot依然可以完美胜任，并且提供了多种模板引擎的默认配置支持，所以在推荐的模板引擎下，我们可以很快的上手开发动态网站。
Spring Boot提供了默认配置的模板引擎主要有以下几种：
•	Thymeleaf
•	FreeMarker
•	Velocity
•	Groovy
•	Mustache
Spring Boot建议使用这些模板引擎，避免使用JSP，若一定要使用JSP将无法实现Spring Boot的多种特性，具体可见后文：支持JSP的配置
当你使用上述模板引擎中的任何一个，它们默认的模板配置路径为：src/main/resources/templates。当然也可以修改这个路径，具体如何修改，可在后续各模板引擎的配置属性中查询并修改。
3.4、使用Freemarker模板引擎渲染web视图
3.4.1、pom文件引入:
<!-- 引入freeMarker的依赖包. -->
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-freemarker</artifactId>
</dependency>
3.4.2、后台代码
在src/main/resources/创建一个templates文件夹,后缀为*.ftl
	@RequestMapping("/index")
	public String index(Map<String, Object> map) {
	    map.put("name","美丽的天使...");
		return "index";
	}

3.4.3、前台代码

<!DOCTYPE html>
<html>
<head lang="en">
<meta charset="UTF-8" />
<title></title>
</head>
<body>
	  ${name}
</body> 
</html>
3.4.4、Freemarker其他用法
@RequestMapping("/freemarkerIndex")
	public String index(Map<String, Object> result) {
		result.put("name", "yushengjun");
		result.put("sex", "0");
		List<String> listResult = new ArrayList<String>();
		listResult.add("zhangsan");
		listResult.add("lisi");
		listResult.add("itmayiedu");
		result.put("listResult", listResult);
		return "index";
	}

<!DOCTYPE html>
<html>
<head lang="en">
<meta charset="UTF-8" />
<title>首页</title>
</head>
<body>
	  ${name}
<#if sex=="1">
            男
      <#elseif sex=="2">
            女
     <#else>
        其他      
	  
	  </#if>	  
	 <#list userlist as user>
	   ${user}
	 </#list>
</body> 
</html>

3.4.5、Freemarker配置
新建application.properties文件
########################################################
###FREEMARKER (FreeMarkerAutoConfiguration)
########################################################
spring.freemarker.allow-request-override=false
spring.freemarker.cache=true
spring.freemarker.check-template-location=true
spring.freemarker.charset=UTF-8
spring.freemarker.content-type=text/html
spring.freemarker.expose-request-attributes=false
spring.freemarker.expose-session-attributes=false
spring.freemarker.expose-spring-macro-helpers=false
#spring.freemarker.prefix=
#spring.freemarker.request-context-attribute=
#spring.freemarker.settings.*=
spring.freemarker.suffix=.ftl
spring.freemarker.template-loader-path=classpath:/templates/
#comma-separated list
#spring.freemarker.view-names= # whitelist of view names that can be resolved

3.5、使用JSP渲染Web视图
3.5.1、pom文件引入以下依赖
<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>1.3.3.RELEASE</version>
	</parent>
	<dependencies>
		<!-- SpringBoot 核心组件 -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-tomcat</artifactId>
		</dependency>
		<dependency>
			<groupId>org.apache.tomcat.embed</groupId>
			<artifactId>tomcat-embed-jasper</artifactId>
		</dependency>
	</dependencies>

3.5.2、在application.properties创建以下配置
spring.mvc.view.prefix=/WEB-INF/jsp/
spring.mvc.view.suffix=.jsp

3.5.3、后台代码
@Controller
public class IndexController {
	@RequestMapping("/index")
	public String index() {
		return "index";
	}
}




注意:创建SpringBoot整合JSP，一定要为war类型，否则会找不到页面.










四、	数据访问
4.1、springboot整合使用JdbcTemplate
4.1.1 pom文件引入
<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>1.5.2.RELEASE</version>
	</parent>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-jdbc</artifactId>
		</dependency>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>5.1.21</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
	</dependencies>
4.1.2 application.properties新增配置
spring.datasource.url=jdbc:mysql://localhost:3306/test
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.jdbc.Driver


4.1.3 UserService类
@Service
public class UserServiceImpl implements UserService {
	@Autowired
	private JdbcTemplate jdbcTemplate;
	public void createUser(String name, Integer age) {
		System.out.println("ssss");
		jdbcTemplate.update("insert into users values(null,?,?);", name, age);
	}
}

4.1.4 App类
@ComponentScan(basePackages = "com.itmayiedu")
@EnableAutoConfiguration
public class App {
	public static void main(String[] args) {
		SpringApplication.run(App.class, args);
	}
}	

注意: spring-boot-starter-parent要在1.5以上
4.2、springboot整合使用mybatis
4.2.1、pom文件引入
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>1.3.2.RELEASE</version>
		<relativePath /> <!-- lookup parent from repository -->
	</parent>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.mybatis.spring.boot</groupId>
			<artifactId>mybatis-spring-boot-starter</artifactId>
			<version>1.1.1</version>
		</dependency>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>5.1.21</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
	</dependencies>

4.2.2、配置文件引入
spring.datasource.url=jdbc:mysql://localhost:3306/test
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.jdbc.Driver


4.2.3、Mapper代码
public interface UserMapper {
	@Select("SELECT * FROM USERS WHERE NAME = #{name}")
	User findByName(@Param("name") String name);
	@Insert("INSERT INTO USERS(NAME, AGE) VALUES(#{name}, #{age})")
	int insert(@Param("name") String name, @Param("age") Integer age);
}


4.2.4、启动方式
@ComponentScan(basePackages = "com.itmayiedu")
@MapperScan(basePackages = "com.itmayiedu.mapper")
@SpringBootApplication
public class App {
	public static void main(String[] args) {
		SpringApplication.run(App.class, args);
	}
}


4.3、springboot整合使用springjpa
4.3.1 pom文件引入依赖
<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>1.4.2.RELEASE</version>
	</parent>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>5.1.21</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
	</dependencies>

4.3.2 创建User实体类
@Entity(name = "users")
public class User {
	@Id
	@GeneratedValue
	private Integer id;
	@Column
	private String name;
	@Column
	private Integer age;
      // ..get/set方法
}

4.3.3 创建UserDao
public interface UserDao extends JpaRepository<User, Integer> {
}

4.3.4 创建IndexController
@RestController
public class IndexController {
	@Autowired
	private UserDao userDao;
	@RequestMapping("/index")
	public String index(Integer id) {
		User findUser = userDao.findOne(id);
		System.out.println(findUser.getName());
		return "success";
	}
}
4.3.5 启动项目
@ComponentScan(basePackages = { "com.itmayiedu" })
@EnableJpaRepositories(basePackages = "com.itmayiedu.dao")
@EnableAutoConfiguration
@EntityScan(basePackages = "com.itmayiedu.entity")
public class App {
	public static void main(String[] args) {
		SpringApplication.run(App.class, args);
	}
}




4.4、springboot整合多数据源
同学们思考下，你们在项目中有使用到多数据源吗？


4.4.1配置文件中新增两个数据源
spring.datasource.test1.driverClassName = com.mysql.jdbc.Driver
spring.datasource.test1.url = jdbc:mysql://localhost:3306/test01?useUnicode=true&characterEncoding=utf-8
spring.datasource.test1.username = root
spring.datasource.test1.password = root

spring.datasource.test2.driverClassName = com.mysql.jdbc.Driver
spring.datasource.test2.url = jdbc:mysql://localhost:3306/test02?useUnicode=true&characterEncoding=utf-8
spring.datasource.test2.username = root
spring.datasource.test2.password = root

4.4.2配置文件中新增两个数据源
@Configuration // 注册到springboot容器中
@MapperScan(basePackages = "com.itmayiedu.user1", sqlSessionFactoryRef = "test1SqlSessionFactory")
public class DataSource1Config {

	/**
	 * 
	 * @methodDesc: 功能描述:(配置test1数据库)
	 * @author: 余胜军
	 * @param: @return
	 * @createTime:2017年9月17日 下午3:16:44
	 * @returnType:@return DataSource
	 * @copyright:上海每特教育科技有限公司
	 * @QQ:644064779
	 */
	@Bean(name = "test1DataSource")
	@Primary
	@ConfigurationProperties(prefix = "spring.datasource.test1")
	public DataSource testDataSource() {
		return DataSourceBuilder.create().build();
	}

	/**
	 * 
	 * @methodDesc: 功能描述:(test1 sql会话工厂)
	 * @author: 余胜军
	 * @param: @param
	 *             dataSource
	 * @param: @return
	 * @param: @throws
	 *             Exception
	 * @createTime:2017年9月17日 下午3:17:08
	 * @returnType:@param dataSource
	 * @returnType:@return
	 * @returnType:@throws Exception SqlSessionFactory
	 * @copyright:上海每特教育科技有限公司
	 * @QQ:644064779
	 */
	@Bean(name = "test1SqlSessionFactory")
	@Primary
	public SqlSessionFactory testSqlSessionFactory(@Qualifier("test1DataSource") DataSource dataSource)
			throws Exception {
		SqlSessionFactoryBean bean = new SqlSessionFactoryBean();
		bean.setDataSource(dataSource);
//		bean.setMapperLocations(
//				new PathMatchingResourcePatternResolver().getResources("classpath:mybatis/mapper/test1/*.xml"));
		return bean.getObject();
	}

	/**
	 * 
	 * @methodDesc: 功能描述:(test1 事物管理)
	 * @author: 余胜军
	 * @param: @param
	 *             dataSource
	 * @param: @return
	 * @param: @throws
	 *             Exception
	 * @createTime:2017年9月17日 下午3:17:08
	 * @returnType:@param dataSource
	 * @returnType:@return
	 * @returnType:@throws Exception SqlSessionFactory
	 * @copyright:上海每特教育科技有限公司
	 * @QQ:644064779
	 */
	@Bean(name = "test1TransactionManager")
	@Primary
	public DataSourceTransactionManager testTransactionManager(@Qualifier("test1DataSource") DataSource dataSource) {
		return new DataSourceTransactionManager(dataSource);
	}

	@Bean(name = "test1SqlSessionTemplate")
	public SqlSessionTemplate testSqlSessionTemplate(
			@Qualifier("test1SqlSessionFactory") SqlSessionFactory sqlSessionFactory) throws Exception {
		return new SqlSessionTemplate(sqlSessionFactory);
	}

}

4.4.2创建分包Mapper 
public interface User1Mapper {
	@Insert("insert into users values(null,#{name},#{age});")
	public int addUser(@Param("name") String name, @Param("age") Integer age);
}
4.4.3启动项目
@ComponentScan(basePackages = "com.itmayiedu")
@EnableAutoConfiguration
public class App {
	public static void main(String[] args) {
		SpringApplication.run(App.class, args);
	}
}





No qualifying bean of type [javax.sql.DataSource] is defined: expected single matching bean but found 2: test1DataSource,test2DataSource
五、	事物管理
5.1.1springboot整合事物管理
 springboot默认集成事物,只主要在方法上加上@Transactional即可
5.1.2SpringBoot分布式事物管理
使用springboot+jta+atomikos 分布式事物管理
5.1.2.1新增配置文件信息
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-jta-atomikos</artifactId>
</dependency>

5.1.2.2新增配置文件信息
# Mysql 1
mysql.datasource.test.url = jdbc:mysql://localhost:3306/test01?useUnicode=true&characterEncoding=utf-8
mysql.datasource.test.username = root
mysql.datasource.test.password = root

mysql.datasource.test.minPoolSize = 3
mysql.datasource.test.maxPoolSize = 25
mysql.datasource.test.maxLifetime = 20000
mysql.datasource.test.borrowConnectionTimeout = 30
mysql.datasource.test.loginTimeout = 30
mysql.datasource.test.maintenanceInterval = 60
mysql.datasource.test.maxIdleTime = 60
mysql.datasource.test.testQuery = select 1


# Mysql 2
mysql.datasource.test2.url =jdbc:mysql://localhost:3306/test02?useUnicode=true&characterEncoding=utf-8
mysql.datasource.test2.username =root
mysql.datasource.test2.password =root

mysql.datasource.test2.minPoolSize = 3
mysql.datasource.test2.maxPoolSize = 25
mysql.datasource.test2.maxLifetime = 20000
mysql.datasource.test2.borrowConnectionTimeout = 30
mysql.datasource.test2.loginTimeout = 30
mysql.datasource.test2.maintenanceInterval = 60
mysql.datasource.test2.maxIdleTime = 60
mysql.datasource.test2.testQuery = select 1


5.1.2.3 读取配置文件信息
package com.itmayiedu.config;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "mysql.datasource.test")
public class DBConfig1 {

	private String url;
	private String username;
	private String password;
	private int minPoolSize;
	private int maxPoolSize;
	private int maxLifetime;
	private int borrowConnectionTimeout;
	private int loginTimeout;
	private int maintenanceInterval;
	private int maxIdleTime;
	private String testQuery;
}
package com.itmayiedu.config;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "mysql.datasource.test1")
public class DBConfig2 {

	private String url;
	private String username;
	private String password;
	private int minPoolSize;
	private int maxPoolSize;
	private int maxLifetime;
	private int borrowConnectionTimeout;
	private int loginTimeout;
	private int maintenanceInterval;
	private int maxIdleTime;
	private String testQuery;
}




5.1.2.4 创建多数据源
@Configuration
// basePackages 最好分开配置 如果放在同一个文件夹可能会报错
@MapperScan(basePackages = "com.itmayiedu.test01", sqlSessionTemplateRef = "testSqlSessionTemplate")
public class TestMyBatisConfig1 {

	// 配置数据源
	@Primary
	@Bean(name = "testDataSource")
	public DataSource testDataSource(DBConfig1 testConfig) throws SQLException {
		MysqlXADataSource mysqlXaDataSource = new MysqlXADataSource();
		mysqlXaDataSource.setUrl(testConfig.getUrl());
		mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true);
		mysqlXaDataSource.setPassword(testConfig.getPassword());
		mysqlXaDataSource.setUser(testConfig.getUsername());
		mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true);

		AtomikosDataSourceBean xaDataSource = new AtomikosDataSourceBean();
		xaDataSource.setXaDataSource(mysqlXaDataSource);
		xaDataSource.setUniqueResourceName("testDataSource");

		xaDataSource.setMinPoolSize(testConfig.getMinPoolSize());
		xaDataSource.setMaxPoolSize(testConfig.getMaxPoolSize());
		xaDataSource.setMaxLifetime(testConfig.getMaxLifetime());
		xaDataSource.setBorrowConnectionTimeout(testConfig.getBorrowConnectionTimeout());
		xaDataSource.setLoginTimeout(testConfig.getLoginTimeout());
		xaDataSource.setMaintenanceInterval(testConfig.getMaintenanceInterval());
		xaDataSource.setMaxIdleTime(testConfig.getMaxIdleTime());
		xaDataSource.setTestQuery(testConfig.getTestQuery());
		return xaDataSource;
	}

	@Bean(name = "testSqlSessionFactory")
	public SqlSessionFactory testSqlSessionFactory(@Qualifier("testDataSource") DataSource dataSource)
			throws Exception {
		SqlSessionFactoryBean bean = new SqlSessionFactoryBean();
		bean.setDataSource(dataSource);
		return bean.getObject();
	}

	@Bean(name = "testSqlSessionTemplate")
	public SqlSessionTemplate testSqlSessionTemplate(
			@Qualifier("testSqlSessionFactory") SqlSessionFactory sqlSessionFactory) throws Exception {
		return new SqlSessionTemplate(sqlSessionFactory);
	}
}

package com.itmayiedu.datasource;

import java.sql.SQLException;

import javax.sql.DataSource;

import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.SqlSessionTemplate;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import com.atomikos.jdbc.AtomikosDataSourceBean;
import com.itmayiedu.config.DBConfig1;
import com.mysql.jdbc.jdbc2.optional.MysqlXADataSource;

@Configuration
// basePackages 最好分开配置 如果放在同一个文件夹可能会报错
@MapperScan(basePackages = "com.itmayiedu.test02", sqlSessionTemplateRef = "test2SqlSessionTemplate")
public class TestMyBatisConfig2 {

	// 配置数据源
	@Bean(name = "test2DataSource")
	public DataSource testDataSource(DBConfig1 testConfig) throws SQLException {
		MysqlXADataSource mysqlXaDataSource = new MysqlXADataSource();
		mysqlXaDataSource.setUrl(testConfig.getUrl());
		mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true);
		mysqlXaDataSource.setPassword(testConfig.getPassword());
		mysqlXaDataSource.setUser(testConfig.getUsername());
		mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true);

		AtomikosDataSourceBean xaDataSource = new AtomikosDataSourceBean();
		xaDataSource.setXaDataSource(mysqlXaDataSource);
		xaDataSource.setUniqueResourceName("test2DataSource");

		xaDataSource.setMinPoolSize(testConfig.getMinPoolSize());
		xaDataSource.setMaxPoolSize(testConfig.getMaxPoolSize());
		xaDataSource.setMaxLifetime(testConfig.getMaxLifetime());
		xaDataSource.setBorrowConnectionTimeout(testConfig.getBorrowConnectionTimeout());
		xaDataSource.setLoginTimeout(testConfig.getLoginTimeout());
		xaDataSource.setMaintenanceInterval(testConfig.getMaintenanceInterval());
		xaDataSource.setMaxIdleTime(testConfig.getMaxIdleTime());
		xaDataSource.setTestQuery(testConfig.getTestQuery());
		return xaDataSource;
	}

	@Bean(name = "test2SqlSessionFactory")
	public SqlSessionFactory testSqlSessionFactory(@Qualifier("test2DataSource") DataSource dataSource)
			throws Exception {
		SqlSessionFactoryBean bean = new SqlSessionFactoryBean();
		bean.setDataSource(dataSource);
		return bean.getObject();
	}

	@Bean(name = "test2SqlSessionTemplate")
	public SqlSessionTemplate testSqlSessionTemplate(
			@Qualifier("test2SqlSessionFactory") SqlSessionFactory sqlSessionFactory) throws Exception {
		return new SqlSessionTemplate(sqlSessionFactory);
	}
}

5.1.2.4 启动加载配置
@EnableConfigurationProperties(value = { DBConfig1.class, DBConfig2.class })


六、	日志管理
6.1使用log4j记录日志
6.1.2新建log4j配置文件
#log4j.rootLogger=CONSOLE,info,error,DEBUG
log4j.rootLogger=info,error,CONSOLE,DEBUG
log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender     
log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout     
log4j.appender.CONSOLE.layout.ConversionPattern=%d{yyyy-MM-dd-HH-mm} [%t] [%c] [%p] - %m%n     
log4j.logger.info=info
log4j.appender.info=org.apache.log4j.DailyRollingFileAppender
log4j.appender.info.layout=org.apache.log4j.PatternLayout     
log4j.appender.info.layout.ConversionPattern=%d{yyyy-MM-dd-HH-mm} [%t] [%c] [%p] - %m%n  
log4j.appender.info.datePattern='.'yyyy-MM-dd
log4j.appender.info.Threshold = info   
log4j.appender.info.append=true   
#log4j.appender.info.File=/home/admin/pms-api-services/logs/info/api_services_info
log4j.appender.info.File=/Users/dddd/Documents/testspace/pms-api-services/logs/info/api_services_info
log4j.logger.error=error  
log4j.appender.error=org.apache.log4j.DailyRollingFileAppender
log4j.appender.error.layout=org.apache.log4j.PatternLayout     
log4j.appender.error.layout.ConversionPattern=%d{yyyy-MM-dd-HH-mm} [%t] [%c] [%p] - %m%n  
log4j.appender.error.datePattern='.'yyyy-MM-dd
log4j.appender.error.Threshold = error   
log4j.appender.error.append=true   
#log4j.appender.error.File=/home/admin/pms-api-services/logs/error/api_services_error
log4j.appender.error.File=/Users/dddd/Documents/testspace/pms-api-services/logs/error/api_services_error
log4j.logger.DEBUG=DEBUG
log4j.appender.DEBUG=org.apache.log4j.DailyRollingFileAppender
log4j.appender.DEBUG.layout=org.apache.log4j.PatternLayout     
log4j.appender.DEBUG.layout.ConversionPattern=%d{yyyy-MM-dd-HH-mm} [%t] [%c] [%p] - %m%n  
log4j.appender.DEBUG.datePattern='.'yyyy-MM-dd
log4j.appender.DEBUG.Threshold = DEBUG   
log4j.appender.DEBUG.append=true   
#log4j.appender.DEBUG.File=/home/admin/pms-api-services/logs/debug/api_services_debug
log4j.appender.DEBUG.File=/Users/dddd/Documents/testspace/pms-api-services/logs/debug/api_services_debug



6.2使用AOP统一处理Web请求日志
6.2.1POM文件新增依赖
	<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-aop</artifactId>
	</dependency>

6.2.2POM文件新增依赖
@Aspect
@Component
public class WebLogAspect {
	private Logger logger = LoggerFactory.getLogger(getClass());
	@Pointcut("execution(public * com.itmayiedu.controller..*.*(..))")
	public void webLog() {
	}
	@Before("webLog()")
	public void doBefore(JoinPoint joinPoint) throws Throwable {
		// 接收到请求，记录请求内容
		ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
		HttpServletRequest request = attributes.getRequest();
		// 记录下请求内容
		logger.info("URL : " + request.getRequestURL().toString());
		logger.info("HTTP_METHOD : " + request.getMethod());
		logger.info("IP : " + request.getRemoteAddr());
		Enumeration<String> enu = request.getParameterNames();
		while (enu.hasMoreElements()) {
			String name = (String) enu.nextElement();
			logger.info("name:{},value:{}", name, request.getParameter(name));
		}
	}
	@AfterReturning(returning = "ret", pointcut = "webLog()")
	public void doAfterReturning(Object ret) throws Throwable {
		// 处理完请求，返回内容
		logger.info("RESPONSE : " + ret);
	}
}


七、	缓存支持
7.1注解配置与EhCache使用
7.1.1 pom文件引入
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-cache</artifactId>
</dependency>

7.1.2新建ehcache.xml 文件
<?xml version="1.0" encoding="UTF-8"?>
<ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:noNamespaceSchemaLocation="http://ehcache.org/ehcache.xsd"
	updateCheck="false">
	<diskStore path="java.io.tmpdir/Tmp_EhCache" />

	<!-- 默认配置 -->
	<defaultCache maxElementsInMemory="5000" eternal="false"
		timeToIdleSeconds="120" timeToLiveSeconds="120"
		memoryStoreEvictionPolicy="LRU" overflowToDisk="false" />

	<cache name="baseCache" maxElementsInMemory="10000"
		maxElementsOnDisk="100000" />

</ehcache>
配置信息介绍
1.	    <!--  
2.	       name:缓存名称。  
3.	       maxElementsInMemory：缓存最大个数。  
4.	       eternal:对象是否永久有效，一但设置了，timeout将不起作用。  
5.	       timeToIdleSeconds：设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。  
6.	       timeToLiveSeconds：设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。  
7.	       overflowToDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。  
8.	       diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。  
9.	       maxElementsOnDisk：硬盘最大缓存个数。  
10.	       diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.  
11.	       diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。  
12.	       memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。  
13.	       clearOnFlush：内存数量最大时是否清除。  
14.	    --> 




7.1.3代码使用Cacheable
@CacheConfig(cacheNames = "baseCache")
public interface UserMapper {
	@Select("select * from users where name=#{name}")
	@Cacheable
	UserEntity findName(@Param("name") String name);
}
7.1.4清除缓存
@Autowired
private CacheManager cacheManager;
@RequestMapping("/remoKey")
public void remoKey() {
	cacheManager.getCache("baseCache").clear();
}




使用Redis做集中式缓存

八、	其他内容

8.1、使用@Scheduled创建定时任务
在Spring Boot的主类中加入@EnableScheduling注解，启用定时任务的配置
@Component
public class ScheduledTasks {
    private static final SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm:ss");
    @Scheduled(fixedRate = 5000)
    public void reportCurrentTime() {
        System.out.println("现在时间：" + dateFormat.format(new Date()));
    }
}


8.2、使用@Async实现异步调用
启动加上@EnableAsync ,需要执行异步方法上加入	@Async
8.3、自定义参数
配置文件值
name=itmayiedu.com

配置文件值
	@Value("${name}")
	private String name;
@ResponseBody
	@RequestMapping("/getValue")
	public String getValue() {
		return name;
	}

8.4、多环境配置
spring.profiles.active=pre

application-dev.properties：开发环境
application-test.properties：测试环境
application-prod.properties：生产环境
8.5、修改端口号
server.port=8888 
server.context-path=/itmayiedu
8.6、SpringBoot yml 使用
创建application.yml
server:
  port:  8090
  context-path: /itmayiedu


8.7、发布打包
使用mvn package 打包
使用java –jar 包名
如果报错没有主清单,在pom文件中新增
	<build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<source>1.8</source>
					<target>1.8</target>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<maimClass>com.itmayiedu.app.App</maimClass>
				</configuration>
				<executions>
					<execution>
						<goals>
							<goal>repackage</goal>
						</goals>
					</execution>
				</executions>

			</plugin>
		</plugins>
	</build>

 Spring Tool Suite是Eclipse IDE的一个发行版，增加了诸多能辅助Spring开发的特性。
 你可以从
 http://spring.io/tools/sts
下载Spring Tool Suite。

hibernate注解 @GeneratedValue

提供主键值的生成策略的规范。
所述@GeneratedValue注释可以应用于实体的主键属性或字段或与结合@Id注释。

@GeneratedValue注释的使用只需要支持简单的主键。 

使用 注释@GeneratedValue不支持派生主键。 

两个属性
① generator  ---  java.lang.String  
  在指定的使用（可选）主键生成器的名称SequenceGenerator 或TableGenerator注解。 

② strategy --- GenerationType   
   （可选）持久性提供程序必须用于生成注释实体主键的主键生成策略。
    GenerationType  的值。 


Strategy - 表示主键生成策略，取值有：


GenerationType.AUTO 
- 根据底层数据库自动选择（默认），若数据库支持自动增长类型，则为自动增长。


GenerationType.INDENTITY 
- 根据数据库的Identity字段生成，支持DB2、MySQL、 MS、SQL  
- Server、SyBase与HyperanoicSQL数据库的Identity  类型主键。

GenerationType.SEQUENCE 
- 使用Sequence来决定主键的取值，适合Oracle、DB2等支持Sequence的数据库， 
- 一般结合@SequenceGenerator使用。 
- -- 注：(Oracle没有自动增长类型，只能用Sequence)

GenerationType.TABLE   
-  使用指定表来决定主键取值，结合@TableGenerator使用。


例如：
    @Id
    @GeneratedValue(strategy =  
                         GenerationType.INDENTITY) 
    private int id;

保护应用程序
Spring Boot自动配置让应用程序的安全工作变得易如反掌，你要做的只是添加Security起步
依赖。以Gradle为例，应添加如下依赖：
compile("org.springframework.boot:spring-boot-starter-security")
如果使用Maven，那么你要在项目的 <dependencies> 块中加入如下 <dependency> ：
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-security</artifactId>
</dependency>
这样就搞定了！重新构建应用程序后运行即可，现在这就是一个安全的Web应用程序了！
Security起步依赖在应用程序的Classpath里添加了Spring Secuirty（和其他一些东西）。Classpath里
有Spring Security后，自动配置就能介入其中创建一个基本的Spring Security配置。
试着在浏览器里打开该应用程序，你马上就会看到HTTP基础身份验证对话框。此处的用户
名是user，密码就有点麻烦了。密码是在应用程序每次运行时随机生成后写入日志的，你需要查
找日志消息（默认写入标准输出），找到此类内容：
Using default security password: d9d8abe5-42b5-4f20-a32a-76ee3df658d9

Spring Boot起步依赖
起步依赖
（Group ID： org.springframework.boot ）
传递依赖
spring-boot-starter   org.springframework.boot:spring-boot
 org.springframework.boot:spring-boot-autoconfigure
 org.springframework.boot:spring-boot-starter-
logging
 org.springframework:spring-core
(excludes commons-logging:commons-logging)
 org.yaml:snakeyaml
spring-boot-starter-actuator   org.springframework.boot:spring-boot-starter
 org.springframework.boot:spring-boot-actuator
spring-boot-starter-amqp   org.springframework.boot:spring-boot-starter
 org.springframework:spring-messaging
 org.springframework.amqp:spring-rabbit
spring-boot-starter-aop   org.springframework.boot:spring-boot-starter
 org.springframework:spring-aop
 org.aspectj:aspectjrt
 org.aspectj:aspectjweaver
spring-boot-starter-artemis   org.springframework.boot:spring-boot-starter
 org.springframework:spring-jms
 org.apache.activemq:artemis-jms-client
附录 B
164 附录 B Spring Boot起步依赖
（续）
起步依赖
（ Group ID：org.springframework.boot ）
传递依赖
spring-boot-starter-batch   org.springframework.boot:spring-boot-starter
 org.hsqldb:hsqldb
 org.springframework:spring-jdbc
 org.springframework.batch:spring-batch-core
spring-boot-starter-cache   org.springframework.boot:spring-boot-starter
 org.springframework:spring-context
 org.springframework:spring-context-support
spring-boot-starter-cloud-connectors   org.springframework.boot:spring-boot-starter
 org.springframework.cloud:spring-cloud-spring-
service-connector
 org.springframework.cloud:spring-cloud-cloudf-
oundry-connector
 org.springframework.cloud:spring-cloud-heroku-
connector
 org.springframework.cloud:spring-cloud-local-
config-connector
spring-boot-starter-data-elasticsearch   org.springframework.boot:spring-boot-starter
 org.springframework.data:spring-data-elasticsearch
spring-boot-starter-data-gemfire   org.springframework.boot:spring-boot-starter
 com.gemstone.gemfire:gemfire
(excludes commons-logging:commons-logging)
 org.springframework.data:spring-data-gemfire
spring-boot-starter-data-jpa   org.springframework.boot:spring-boot-starter
 org.springframework.boot:spring-boot-starter-aop
 org.springframework.boot:spring-boot-starter-
jdbc
 org.hibernate:hibernate-entitymanager(excludes
org.jboss.spec.javax.transaction:jboss-transac-
tion-api_1.2_spec)
 javax.transaction:javax.transaction-api
 org.springframework.data:spring-data-jpa
 org.springframework:spring-aspects
spring-boot-starter-data-mongodb   org.springframework.boot:spring-boot-starter
 org.mongodb:mongo-java-driver
 org.springframework.data:spring-data-mongodb
spring-boot-starter-data-rest   org.springframework.boot:spring-boot-starter
 org.springframework.boot:spring-boot-starter-web
 com.fasterxml.jackson.core:jackson-annotations
 com.fasterxml.jackson.core:jackson-databind
 org.springframework.data:spring-data-rest-webmvc
spring-boot-starter-data-solr   org.springframework.boot:spring-boot-starter
 org.apache.solr:solr-solrj (excludes log4j:log4j)
 org.springframework.data:spring-data-solr
 org.apache.httpcomponents:httpmime
附录 B Spring Boot起步依赖 165
1
2
3
4
5
6
7
8
（续）
起步依赖
（ Group ID：org.springframework.boot ）
传递依赖
spring-boot-starter-freemarker   org.springframework.boot:spring-boot-starter
 org.springframework.boot:spring-boot-starter-web
 org.freemarker:freemarker
 org.springframework:spring-context-support
spring-boot-starter-groovy-templates   org.springframework.boot:spring-boot-starter
 org.springframework.boot:spring-boot-starter-web
 org.codehaus.groovy:groovy-templates
spring-boot-starter-hateoas   org.springframework.boot:spring-boot-starter-web
 org.springframework.hateoas:spring-hateoas
 org.springframework.plugin:spring-plugin-core
spring-boot-starter-hornetq   org.springframework.boot:spring-boot-starter
 org.springframework:spring-jms
 org.hornetq:hornetq-jms-client
spring-boot-starter-integration   org.springframework.boot:spring-boot-starter
 org.springframework.boot:spring-boot-starter-aop
 org.springframework.integration:spring-integration-
core
 org.springframework.integration:spring-integration-
file
 org.springframework.integration:spring-integration-
http
 org.springframework.integration:spring-integration-ip
 org.springframework.integration:spring-integration-
stream
spring-boot-starter-jdbc   org.springframework.boot:spring-boot-starter
 org.apache.tomcat:tomcat-jdbc
 org.springframework:spring-jdbc
spring-boot-starter-jersey   org.springframework.boot:spring-boot-starter
 org.springframework.boot:spring-boot-starter-
tomcat
 org.springframework.boot:spring-boot-starter-
validation
 com.fasterxml.jackson.core:jackson-databind
 org.springframework:spring-web
 org.glassfish.jersey.core:jersey-server
 org.glassfish.jersey.containers:jersey-container-
servlet-core
 org.glassfish.jersey.containers:jersey-container-servlet
 org.glassfish.jersey.ext:jersey-bean-validation(exclu
des javax.el:javax.el-api, org.glassfish.web:javax.
el)
 org.glassfish.jersey.ext:jersey-spring3
 org.glassfish.jersey.media:jersey-media-json-
jackson
spring-boot-starter-jetty   org.eclipse.jetty:jetty-servlets
 org.eclipse.jetty:jetty-webapp
 org.eclipse.jetty.websocket:websocket-server
 org.eclipse.jetty.websocket:javax-websocket-
server-impl
166 附录 B Spring Boot起步依赖
（续）
起步依赖
（ Group ID：org.springframework.boot ）
传递依赖
spring-boot-starter-jooq   org.springframework.boot:spring-boot-starter
 org.springframework.boot:spring-boot-starter-jdbc
 org.springframework:spring-tx
 org.jooq:jooq
spring-boot-starter-jta-atomikos   org.springframework.boot:spring-boot-starter
 com.atomikos:transactions-jms
 com.atomikos:transactions-jta(excludes
org.apache.geronimo.specs:geronimo-jta_1.0.1B_spec)
 com.atomikos:transactions-jdbc
 javax.transaction:javax.transaction-api
spring-boot-starter-jta-bitronix   org.springframework.boot:spring-boot-starter
 javax.jms:jms-api
 javax.transaction:javax.transaction-api
 org.codehaus.btm:btm (excludes javax.transaction:jta)
spring-boot-starter-log4j   org.slf4j:jcl-over-slf4j
 org.slf4j:jul-to-slf4j
 org.slf4j:slf4j-log4j12
 log4j:log4j
spring-boot-starter-log4j2   org.apache.logging.log4j:log4j-slf4j-impl
 org.apache.logging.log4j:log4j-api
 org.apache.logging.log4j:log4j-core
 org.slf4j:jcl-over-slf4j
 org.slf4j:jul-to-slf4j
spring-boot-starter-logging   ch.qos.logback:logback-classic
 org.slf4j:jcl-over-slf4j
 org.slf4j:jul-to-slf4j
 org.slf4j:log4j-over-slf4j
spring-boot-starter-mail   org.springframework.boot:spring-boot-starter
 org.springframework:spring-context
 org.springframework:spring-context-support
 com.sun.mail:javax.mail
spring-boot-starter-mobile   org.springframework.boot:spring-boot-starter
 org.springframework.boot:spring-boot-starter-web
 org.springframework.mobile:spring-mobile-device
spring-boot-starter-mustache   org.springframework.boot:spring-boot-starter
 org.springframework.boot:spring-boot-starter-web
 com.samskivert:jmustache
spring-boot-starter-redis   org.springframework.boot:spring-boot-starter
 org.springframework.data:spring-data-redis
 redis.clients:jedis
附录 B Spring Boot起步依赖 167
1
2
3
4
5
6
7
8
（续）
起步依赖
（Group ID： org.springframework.boot ）
传递依赖
spring-boot-starter-remote-shell   org.springframework.boot:spring-boot-starter
 org.springframework.boot:spring-boot-starter-actuator
 org.crashub:crash.cli
 org.crashub:crash.connectors.ssh(excludes
org.codehaus.groovy:groovy-all)
 org.crashub:crash.connectors.telnet (excludes javax.
servlet:servlet-api,log4j:log4j,commons-logging:
commonslogging)
 org.crashub:crash.embed.spring(excludes org.spring-
framework:spring-web,org.codehaus.groovy:groovy-all)
 org.crashub:crash.plugins.cron (excludes
org.codehaus.groovy:groovy-all)
 org.crashub:crash.plugins.mail (excludes
org.codehaus.groovy:groovy-all)
 org.crashub:crash.shell(excludes org.codehaus.groovy:
groovy-all)
 org.codehaus.groovy:groovy
spring-boot-starter-security   org.springframework.boot:spring-boot-starter
 org.springframework:spring-aop
 org.springframework.security:spring-security-config
 org.springframework.security:spring-security-web
spring-boot-starter-social-facebook   org.springframework.boot:spring-boot-starter
 org.springframework.boot:spring-boot-starter-web
 org.springframework.social:spring-social-config
 org.springframework.social:spring-social-core
 org.springframework.social:spring-social-web
 org.springframework.social:spring-social-facebook
spring-boot-starter-social-linkedin   org.springframework.boot:spring-boot-starter
 org.springframework.boot:spring-boot-starter-web
 org.springframework.social:spring-social-config
 org.springframework.social:spring-social-core
 org.springframework.social:spring-social-web
 org.springframework.social:spring-social-linkedin
spring-boot-starter-social-twitter   org.springframework.boot:spring-boot-starter
 org.springframework.boot:spring-boot-starter-web
 org.springframework.social:spring-social-config
 org.springframework.social:spring-social-core
 org.springframework.social:spring-social-web
 org.springframework.social:spring-social-twitter
spring-boot-starter-tes   junit:junit
 org.mockito:mockito-core
 org.hamcrest:hamcrest-core
 org.hamcrest:hamcrest-library
 org.springframework:spring-core(excludes
commons-logging:commons-logging)
 org.springframework:spring-test
168 附录 B Spring Boot起步依赖
（续）
起步依赖
（Group ID： org.springframework.boot ）
传递依赖
spring-boot-starter-thymeleaf   org.springframework.boot:spring-boot-starter
 org.springframework.boot:spring-boot-starter-web
 org.thymeleaf:thymeleaf-spring4
 nz.net.ultraq.thymeleaf:thymeleaf-layout-dialect
spring-boot-starter-tomcat   org.apache.tomcat.embed:tomcat-embed-core
 org.apache.tomcat.embed:tomcat-embed-el
 org.apache.tomcat.embed:tomcat-embed-logging-juli
 org.apache.tomcat.embed:tomcat-embed-websocket
spring-boot-starter-undertow   io.undertow:undertow-core
 io.undertow:undertow-servlet(excludes org.jboss.
spec.javax.servlet:jboss-servlet-api_3.1_spec)
 io.undertow:undertow-websockets-jsr
 javax.servlet:javax.servlet-api
 org.glassfish:javax.el
spring-boot-starter-validation   org.springframework.boot:spring-boot-starter
 org.apache.tomcat.embed:tomcat-embed-el
 org.hibernate:hibernate-validator
spring-boot-starter-velocity   org.springframework.boot:spring-boot-starter
 org.springframework.boot:spring-boot-starter-web
 commons-beanutils:commons-beanutils
 commons-collections:commons-collections
 commons-digester:commons-digester
 org.apache.velocity:velocity
 org.apache.velocity:velocity-tools
 org.springframework:spring-context-support
spring-boot-starter-web   org.springframework.boot:spring-boot-starter
 org.springframework.boot:spring-boot-starter-tomcat
 org.springframework.boot:spring-boot-starter-validation
 com.fasterxml.jackson.core:jackson-databind
 org.springframework:spring-web
 org.springframework:spring-webmvc
spring-boot-starter-websocket   org.springframework.boot:spring-boot-starter
 org.springframework.boot:spring-boot-starter-web
 org.springframework:spring-messaging
 org.springframework:spring-websocket
spring-boot-starter-ws   org.springframework.boot:spring-boot-starter
 org.springframework.boot:spring-boot-starter-web
 org.springframework:spring-jms
 org.springframework:spring-oxm
 org.springframework.ws:spring-ws-core
 org.springframework.ws:spring-ws-support
  
springboot resource目录下
static存放静态资源可以直接访问
templates存放的页面只能通过controller访问  
  
Mysql 如何设置字段自动获取当前时间  
1、将字段类型设为  TIMESTAMP 

2、将默认值设为  CURRENT_TIMESTAMP  
  
如果希望从一个带有模块路径的方法中重定向到另一个模块的方法需要把
return "redirect:showIndex";
改为
return "redirect:/showIndex";
  
int randNumber =rand.nextInt(MAX - MIN + 1) + MIN; 
// randNumber 将被赋值为一个 MIN 和 MAX 范围内的随机数

XML文档中包含类似"Elements look like <this>"的文本，其中的"<this>"将被解析程序解释成一个元素，而人们实际想要的是"<this>"所表示的原义文本。

1.CDATA区：它的全称为character data,以"<![CDATA[ "开始，以" ]]>" 结束，在两者之间嵌入不想被解析程序解析的原始数据，解析器不对CDATA区中的内容进行解析，而是

将这些数据原封不动地交给下游程序处理。  
  
application/x-www-form-urlencoded 

这应该是最常见的 POST 提交数据的方式了。
浏览器的原生 form 表单，如果不设置 enctype 属性，
那么最终就会以 application/x-www-form-urlencoded 方式提交数据。  
  
MERGE语句是SQL语句的一种。
在SQL Server、Oracle数据库中可用，MySQL、PostgreSQL中不可用。
MERGE是Oracle9i新增的语法，用来合并UPDATE和INSERT语句。
通过MERGE语句，根据一张表（原数据表，source table）
或子查询的连接条件对另外一张（目标表，target table）表进行查询，
连接条件匹配上的进行UPDATE，无法匹配的执行INSERT。
这个语法仅需要一次全表扫描就完成了全部工作，执行效率要高于INSERT+UPDATE。  
  
当更新次数+1大于999时  归0 sql应该怎么写  
  UPDATECOUNT = MOD(UPDATECOUNT + 1, 999),
  进行求余运算


下载mysql-8.0.12-winx64压缩包安装方法:
1.解压到目标路径后在path中配置bin路径
使用管理员启动cmd并移动到bin目录下
E:
cd E:\MYSQL\mysql-8.0.12-winx64\bin   
mysql命令
初始化mysql,这时会在控制台输出一个临时密码，把它存储起来 
mysqld --initialize --console
创建mysql服务
mysqld --install
启动服务
net start mysql
登陆
mysql -u root -p 
(输入临时密码)	
修改密码
alter user user() identified by "123456";
  
mysqld --skip-grant-tables 
删除mysql服务
sc delete MYSQL
停止服务
net stop mysql
  
window默认编码GBK
简体中文操作系统Windows XP、Windows 2000简体中文的
	缺省编码是GB18030，
Linux平台默认为UTF-8  
  
When spring integrates mybatis, if you want to print SQL on the console, you need to:

1.Create mybatis-config.xml

	<?xml version="1.0" encoding="UTF-8"?>
	<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
	<configuration>
		<settings>
			<!-- Print the SQL log implementation class as log4j-->			
			<setting name="logImpl" value="LOG4J" />
		</settings>
	</configuration> 

2.In spring-dao.xml (about mybatis configuration file)
	
	Add a property in sqlSessionFactoryBean:
		
		<property name="configLocation" 
			value="classpath:mybatis-config.xml"></property>


			
	public int deleteByIdTempODR077(WODR077Entity entity) {
		int iRet = -1;
		try {
			// 清空临时表[车型国标主数据上载临时表]
			sqlMapClient.delete("WODR077.deleteByPlan", entity);
			// 清空临时表[车型国标主数据上载LOG临时表]
			sqlMapClient.delete("WODR077.deleteByPlanLog", entity);
			iRet = 0;
		} catch (Exception e) {
			iRet = 1;
			logger.error(">>>>>>>>>>deleteByIdTempODR077() "
					+ "WODR077.deleteByIdTempODR077 " + e.getMessage(), e);
		}
		return iRet;
	}  
  
  
	List listUploadPath = wodr077Dao.queryUploadPath();
	int intUploadPath = Integer.parseInt(listUploadPath
			.get(0).toString());
	if (intUploadPath == 0) {
		// 读取参数码表获得【上载文件的保存路径】
		strUploadpath = ((WODR077Entity) ((List) listUploadPath
				.get(1)).get(0)).getUploadlog();
	} else {
		throw new RuntimeException();
	}  
  
  
If you want to judge the two backend data in the El expression, the format is as follows  
  
	<c:if test="${article.userId==sessionUser.id}">
  
动态代理有JDK动态代理和CGLIB动态代理
值得注意的是jdk代理需要借助接口才可以产生代理类,而CGLIB并不需要 
执行方法的时候:
	jdk代理使用的是:
		method.invoke(target, args);
	CGLIB代理使用的是:
		methodProxy.invokeSuper(proxy, args);
		
CGLIB的话是不能直接使用的如要导入jar包
如果你在非maven项目中使用单独使用CGLIB,在运行时会报错:

	java.lang.NoClassDefFoundError: org/objectweb/asm/Type
	
	大意为:
	
		JVM在编译的时候能找到调用方法或静态变量所在的类，
		但在运行的时候找不到此类而引发的错误。
		
	产生这个报错的原因为:
	
		很多java字节码操作和分析的第三方类库都引用了asm.jar文件，
		由于工程不是Maven管理的，无法解决以来传递问题，所以要手动引入asm.jar文件。
		把asm.jar文件添加到项目路径类，运行，然后就正常了。
		
	asm.jar文件:
	
		一般情况下，Class文件是通过javac编译器产生的，
		然后通过类加载器加载到虚拟机内，再通过执行引擎去执行。
		现在我们可以通过ASM的API直接生成符合Java虚拟机规范的Class字节流，
		这样，ASM做的事情一定程度上正是javac解释器做的工作。
		可以说ASM分析一个类、从字节码角度创建一个类、修改一个已经被编译过的类文件。
		那么，我们就可以通过ASM来实现诸如代码生成，代码混淆，代码转换等等以字节码为操作目标的工作
	
	jdk动态代理:
	
	public class JdkProxyExample implements InvocationHandler{
	//存储真实对象
	private Object target = null;
	//建立代理对象和真实对象之间的代理关系,并返回代理对象
	public Object bind(Object target){
		this.target = target;
		return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
	}
	//代理方法逻辑
	@Override
	public Object invoke(Object proxy, Method method, Object[] args)
			throws Throwable {
		System.out.println("进入代理逻辑方法");
		System.out.println("再调用真实对象之前的逻辑");
		Object obj = method.invoke(target, args);
		System.out.println("之后的服务");
		return obj;
	}
			
	public static void main(String[] args) {
			JdkProxyExample jdk = new JdkProxyExample();
			HelloWorld proxy = (HelloWorld)jdk.bind(new HelloWorldImpl());
			proxy.sayHelloWorld();
			
		}
  
	CGLIB动态代理:
	
	public class CglibProxyExample implements MethodInterceptor{
	
	//生成CGLIB代理对象
	public Object getProxy(Class cls){
		Enhancer enhancer = new Enhancer();
		enhancer.setSuperclass(cls);
		enhancer.setCallback(this);
		return enhancer.create();
	}
	
	//代理逻辑
	@Override
	public Object intercept(Object proxy, Method method, Object[] args,
			MethodProxy methodProxy) throws Throwable {
		System.out.println("进入代理类代理逻辑");
		System.out.println("调用真实对象之前");
		Object result = methodProxy.invokeSuper(proxy, args);
		System.out.println("调用真实对象之后");
		return result;
	}

	public static void main(String[] args) {
		CglibProxyExample cpe = new CglibProxyExample();
		ReflectServiceImpl obj = (ReflectServiceImpl)cpe.getProxy(ReflectServiceImpl.class);
		obj.sayHello("jinx!!!");
	}
}
  
 
观察者模式:
	被观察者:
	
	public class ProductList extends Observable{
		//产品列表
		private List<String> productList = null;
		//唯一实例-单例模式
		private static ProductList instance;
		
		private ProductList(){}
		//获取实例
		public static ProductList getInstance(){
			if(instance == null){
				instance = new ProductList();
				instance.productList = new ArrayList<String>();
			}
			return instance;
		}
		//添加观察者
		public void addProductListObserver(Observer observer){
			this.addObserver(observer);
		}
		//添加产品
		public void addProduct(String newProduct){
			productList.add(newProduct);
			System.out.println("产品列表增加新产品:"+newProduct);
			//通知观察者被观察者发生变化
			this.setChanged();
			//通知观察者发生相应动作并将新产品(参数)传递给观察者
			this.notifyObservers(newProduct);
		}
	}
	
	观察者:
	
	public class JdObserver implements Observer {

	@Override
	public void update(Observable o, Object product) {
		String newProduct = (String)product;
		System.out.println("发送新产品:"+newProduct+"同步到京东商场");
	}
	
	效果测试:
	
	public static void main(String[] args) {
		ProductList observable = ProductList.getInstance();
		JdObserver jd = new JdObserver();
		TbObserver tb = new TbObserver();
		observable.addObserver(jd);
		observable.addObserver(tb);
		observable.addProduct("新增产品");
	}

前台向后台异步传送数据	
数据拼接不能有空格,不然String类型(数字)数据无法用integer接收 
  
写在html标签中的lang属性作用：声明当前页面的语言类型。

如：

 <html lang='en'></html> //英文
1
 <html lang='zh'></html> //中文
1
 <html lang='ja'></html> //日文
1
 <html lang='en-us'></html> //美式英文
 
使用Redis
spring版本为4.3.2
	<!-- redis和java整合 -->
	<!-- https://mvnrepository.com/artifact/redis.clients/jedis -->
	<dependency>
		<groupId>redis.clients</groupId>
		<artifactId>jedis</artifactId>
		<version>2.9.0</version>
	</dependency>
	<!-- redis和spring整合 -->
	<!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis -->
	<dependency>
		<groupId>org.springframework.data</groupId>
		<artifactId>spring-data-redis</artifactId>
		<version>1.7.2.RELEASE</version>
	</dependency>  
  
spring配置Redis  

配置Redis需要先配置一个连接池

	<!-- 配置Redis -->
	<bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig">
		<!-- 最大连接数 -->
		<!-- extends org.apache.commons.pool2.impl.GenericObjectPoolConfig.maxTotal -->
		<property name="maxTotal" value="50"></property>
		<!-- 最大空闲数 -->
		<!-- extends org.apache.commons.pool2.impl.GenericObjectPoolConfig.maxIdle -->
		<property name="maxIdle" value="100"></property>
		<!-- 最大等待时长 -->
		<!-- extends org.apache.commons.pool2.impl.BaseObjectPoolConfig.maxWaitMillis -->
		<property name="maxWaitMillis" value="20000"></property>
	</bean>
	
使用spring提供的RedisTemplate需要配置RedisConnectionFactory的实现类

	<!-- Redis连接工厂实现类 -->
	<bean id="connectionFactory" 
		class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory">
		<!-- 配置连接池 -->
		<property name="poolConfig" ref="poolConfig"></property>
	</bean>
	
普通的连接无法保存对象,需要使用实现了RedisSerializer的序列化器
spring提供的RedisTemplate还有两个属性keySerializer,valueSerializer
	
	<!-- Redis value序列化器 -->
	<bean id="jdkSerializationRedisSerializer" 
		class="org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"/>
	<!-- Redis key序列化器 -->
	<bean id="stringRedisSerializer" 
		class="org.springframework.data.redis.serializer.StringRedisSerializer"/>
	<!-- 配置redis Temelate -->
	<bean id="RedisTemplate" class="org.springframework.data.redis.core.RedisTemplate">
		<!-- 配置Redis连接工厂实现类 -->
		<!-- extends org.springframework.data.redis.core.RedisAccessor.connectionFactory -->
		<property name="connectionFactory" ref="connectionFactory"></property>
		<!-- 配置Redis key序列化 -->
		<property name="keySerializer" ref="stringRedisSerializer"></property>
		<!-- 配置Redis value序列化 -->
		<property name="valueSerializer" ref="jdkSerializationRedisSerializer"></property>
	</bean>
  
这样就配置了一个RedisTemplate并且spring date redis 会用对应的序列化器去转化Redis的键值  
  
thymeleaf 
关于url路径问题
	标签中的url属性均要使用类似于th:src这种,用@{}包裹起来
		@{地址}只能访问同级地址(相同前缀)
		@{/地址}可以访问任意地址
  
ajax中的url
	script标签中需要额外添加(th:inline="javascript")
	<script type="text/javascript" th:inline="javascript">
	ajax url的写法[[@{地址(规则参照标签URL)}]]
	不管是ajax异步提交时的url还是成功后function中进行的页面跳转均不需要添加双引号
	url:[[@{login}]],
	location=[[@{/login}]];
  
关于thymeleaf引用页面片段
	被引用的div需要添加属性th:fragment="navigation(双引号内的类似于标记)"
	引用(注意两个引号前后的空格,前者为文件名,后者为片段名):
	<div th:include="文件名 :: 片段名"></div>
  
关于springboot连接数据库

mybatis和mysql

	spring.datasource.driver-class-name =com.mysql.jdbc.Driver
	spring.datasource.url =jdbc:mysql://localhost:3306/springboott1105?useUnicode=true&characterEncoding=utf8
	spring.datasource.username =root
	spring.datasource.password =123456
	
这个是配置的实体类(可以使用通配符)
	mybatis.typeAliasesPackage=com.example.demo.jinx.*.*Entity
这个是配置的mapper.xml的位置(再resource下,可以使用通配符)
	mybatis.mapperLocations=classpath:mappers/*.xml 

关于springboot添加拦截器
	create interceptor class implements HandlerInterceptor
	类上添加@Component

@Component
public class UrlInterceptor implements HandlerInterceptor {

	
	create configuration class implements WebMvcConfigurerAdapter
	类上添加@SpringBootConfiguration
	重写addInterceptors
	注入你的拦截器类
	registry.addInterceptor(你的拦截器).addPathPatterns("/**(需要拦截的路径(需要考录不包括的路径))");
  
@SpringBootConfiguration
public class TSpringMVCConfig extends WebMvcConfigurerAdapter{
	@Autowired
	UrlInterceptor urlInterceptor;

	@Override
	public void addInterceptors(InterceptorRegistry registry) {
		registry.addInterceptor(urlInterceptor).addPathPatterns("/**");
		super.addInterceptors(registry);
	}  
  
在HTML 中 相对路径

	“../”表示上一级目录开始
	“./”表示当前同级目录开始
	“/”表示根目录开始。  
  
关于thymeleaf的if else  
th:if：如果值是true，则打印整个节点
th:unless: 和th:if是相反功能，如果值为false,则打印整个节点  
  
th:if条件判断 
除了判断boolean值外，thymeleaf还认为如下表达式为true:

值非空
值是character，但是非0
值是非0数字
值是字符串，但是不是 “false”, “off” or “no”
值不是boolean值，数字，character 或 字符串
  
<!-- th:switch / th:case -->
<div th:switch="${user.name}">
  <p th:case="'admin'">User is an administrator</p>
  <!-- *: case的默认的选项 -->
  <p th:case="*">User is some other thing</p>
</div>
 
关于mybatis中进行模糊查询需要进行字符串的拼接
user like concat('%'+${user.userName}+'%')  
  
如果需要分页mybatis有一个专门处理分页的类
	RowBounds
他有两个参数
	offset(偏移量,即从第几行开始读取)
	limit(限制条数,读取几条)
他有两个构造方法一个有参一个无参
	public RowBounds (int offset,int limit)
使用时
	RowBounds rowBounds = new RowBounds(0,20);
	//当做参数传进去即可
	mapper.findByName(rowBounds);
	//在sql中并不需要myBatis可以自动识别他
不过需要注意的是这种方法仅限于少量查询,
因为他的原理是先查询然后把查询的结果再按照偏移量和limit进行返回,
所有在查询大量数据时,他虽然方便但性能并不是很好  
  
 移动设备优先
移动设备优先是 Bootstrap 3 的最显著的变化。

在之前的 Bootstrap 版本中（直到 2.x），您需要手动引用另一个 CSS，才能让整个项目友好的支持移动设备。

现在不一样了，Bootstrap 3 默认的 CSS 本身就对移动设备友好支持。

Bootstrap 3 的设计目标是移动设备优先，然后才是桌面设备。这实际上是一个非常及时的转变，因为现在越来越多的用户使用移动设备。

为了让 Bootstrap 开发的网站对移动设备友好，确保适当的绘制和触屏缩放，需要在网页的 head 之中添加 viewport meta 标签，如下所示：

<meta name="viewport" content="width=device-width, initial-scale=1.0">
width 属性控制设备的宽度。假设您的网站将被带有不同屏幕分辨率的设备浏览，那么将它设置为 device-width 可以确保它能正确呈现在不同设备上。

initial-scale=1.0 确保网页加载时，以 1:1 的比例呈现，不会有任何的缩放。

在移动设备浏览器上，通过为 viewport meta 标签添加 user-scalable=no 可以禁用其缩放（zooming）功能。

通常情况下，maximum-scale=1.0 与 user-scalable=no 一起使用。这样禁用缩放功能后，用户只能滚动屏幕，就能让您的网站看上去更像原生应用的感觉。

注意，这种方式我们并不推荐所有网站使用，还是要看您自己的情况而定！

<meta name="viewport" content="width=device-width, 
                                     initial-scale=1.0, 
                                     maximum-scale=1.0, 
                                     user-scalable=no">
  
Bootstrap 中定义了所有的 HTML 标题（h1 到 h6）的样式。
如果想再右边添加一个副标题(内联子标题),可以在标题的标签中添加small标签  
  
  <h1>你好，世界！<small>这是副标题</small></h1>
  
 idea激活码 
 http://idea.iteblog.com/key.php
	http://intellij.mandroid.cn/ 
　　	http://idea.imsxm.com/ 
　　	http://idea.iteblog.com/key.php 
  
  
用户名和邮箱地址的作用

用户名和邮箱地址是本地git客户端的一个变量，不随git库而改变。

每次commit都会用用户名和邮箱纪录。

github的contributions统计就是按邮箱来统计的。

修改密码

git config --global credential.helper store (输入这个命令后,以后只要在输入一次用户名密码)
查看用户名和邮箱地址：

$ git config user.name
$ git config user.email
修改用户名和邮箱地址：

$ git config --global user.name "username"
 
$ git config --global user.email "email"  



服务器上的 Git - 生成 SSH 公钥  
https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5  
  
git公司信息
shanshan
yuezepu@qq.com  
  
元数据

也叫元注解，是放在被定义的一个注解类的前面 ，是对注解一种限制。

谈下这两个： @Retention 和 @Target  

@Retention ：用来说明该注解类的生命周期。它有以下三个参数：

RetentionPolicy.SOURCE  : 注解只保留在源文件中

RetentionPolicy.CLASS  : 注解保留在class文件中，在加载到JVM虚拟机时丢弃

RetentionPolicy.RUNTIME  : 注解保留在程序运行期间，此时可以通过反射获得定义在某个类上的所有注解。

@Target :  用来说明该注解可以被声明在那些元素之前。

ElementType.TYPE：说明该注解只能被声明在一个类前。

ElementType.FIELD：说明该注解只能被声明在一个类的字段前。

ElementType.METHOD：说明该注解只能被声明在一个类的方法前。

ElementType.PARAMETER：说明该注解只能被声明在一个方法参数前。

ElementType.CONSTRUCTOR：说明该注解只能声明在一个类的构造方法前。

ElementType.LOCAL_VARIABLE：说明该注解只能声明在一个局部变量前。

ElementType.ANNOTATION_TYPE：说明该注解只能声明在一个注解类型前。

ElementType.PACKAGE：说明该注解只能声明在一个包名前。  
  
Mysql中经常用来存储日期的数据类型有三种：Date、Datetime、Timestamp。
Date数据类型：用来存储没有时间的日期。Mysql获取和显示这个类型的格式为“YYYY-MM-DD”。支持的时间范围为“1000-00-00”到“9999-12-31”。
Datetime类型：存储既有日期又有时间的数据。存储和显示的格式为 “YYYY-MM-DD HH:MM:SS”。支持的时间范围是“1000-00-00 00:00:00”到“9999-12-31 23:59:59”。
Timestamp类型：也是存储既有日期又有时间的数据。存储和显示的格式跟Datetime一样。支持的时间范围是“1970-01-01 00:00:01”到“2038-01-19 03:14:07”。
所有不符合上面所述格式的数据都会被转换为相应类型的0值。（0000-00-00或者0000-00-00 00:00:00）  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  